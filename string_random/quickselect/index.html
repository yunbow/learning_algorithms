<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>クイックセレクト (Quick Select)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">ランダム文字列問題</a></li>
        <li>クイックセレクト</li>
    </ul>

    <div class="container">
        <h1>クイックセレクト (Quick Select)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>クイックセレクトは、配列から k 番目に小さい（または大きい）要素を効率的に見つけるアルゴリズムです。クイックソートの分割手法を利用していますが、両方の部分配列を再帰的に処理するのではなく、ピボット位置に基づいて片方の部分配列のみを探索するため、平均的にはより効率的です。</p>
            
            <h3>基礎知識</h3>
            <p>クイックセレクトはクイックソートのパーティショニング（分割）戦略を活用していますが、全体のソートを行わずに特定の順位の要素を見つけることができます。基本的な考え方は、配列をピボット要素を中心に分割し、ピボットの最終位置と求めたい順位（k）を比較して、探索範囲を絞り込んでいくことです。</p>
            <p>このアルゴリズムも「分割統治法（Divide and Conquer）」の一種ですが、各ステップで問題サイズを平均的に半分程度に縮小することで、全体をソートせずに特定の順位の要素を効率的に特定できます。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ピボット（pivot）</strong>: 配列を分割するために選ばれる基準となる要素</li>
                <li><strong>パーティション（partition）</strong>: ピボットを基準に配列を「より小さい要素」と「より大きい要素」に分ける操作</li>
                <li><strong>k 番目の要素（k-th element）</strong>: 配列をソートした場合に k 番目の位置に来る要素</li>
                <li><strong>メディアン（median）</strong>: 配列の中央値（奇数個の要素なら中央、偶数個なら中央の2つの平均）</li>
                <li><strong>メディアン・オブ・メディアンズ（median of medians）</strong>: 線形時間で近似的な中央値を求めるアルゴリズム</li>
                <li><strong>インプレース（in-place）</strong>: 追加のメモリ領域をほとんど使わずに処理を行うこと</li>
                <li><strong>線形時間選択（linear-time selection）</strong>: 最悪の場合でも線形時間で動作する選択アルゴリズム</li>
                <li><strong>ランダム化（randomization）</strong>: ピボット選択などにランダム性を導入すること</li>
            </ul>
            
            <h3>特徴</h3>
            <p>クイックセレクトの主な特徴は以下の通りです：</p>
            <ul>
                <li>平均的には線形時間（O(n)）で動作する</li>
                <li>クイックソートのパーティショニング技術を利用している</li>
                <li>インプレースで実装可能（追加の配列を必要としない）</li>
                <li>最悪の場合は二次時間（O(n²)）になる可能性がある</li>
                <li>ピボット選択戦略により性能が大きく左右される</li>
                <li>ランダム化手法を使うことで最悪ケースの確率を下げられる</li>
                <li>メディアン・オブ・メディアンズ手法を用いると最悪でも線形時間を保証できる</li>
                <li>部分的なソートしか行わないため、全体ソートが不要な場合は効率的</li>
                <li>順位統計量（特定順位の要素）を見つけるための標準的なアルゴリズム</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>クイックセレクトは以下のような場面で特に有用です：</p>
            <ul>
                <li>配列の中央値（メディアン）を効率的に求める必要がある場合</li>
                <li>上位 k 個の要素や下位 k 個の要素を見つける問題</li>
                <li>k 番目に大きい（または小さい）要素を特定する必要がある場合</li>
                <li>要素の分位数（quartile）や百分位数（percentile）を計算する場合</li>
                <li>異常値検出のためのデータ解析</li>
                <li>画像処理における中央値フィルタの実装</li>
                <li>最適化問題やヒューリスティックアルゴリズムの一部として</li>
                <li>データストリームの k 番目に大きい要素を追跡する場合</li>
                <li>全体のソートが不要で特定順位の要素のみが必要な統計処理</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>クイックセレクトの基本的な手順は以下の通りです：</p>
            
            <h4>1. 初期化</h4>
            <ol>
                <li>配列と、求めたい順位 k（0-indexedで k は 0 から n-1 の範囲）を入力として受け取る</li>
                <li>探索範囲の左端（left）を配列の最初のインデックス（通常は0）に設定する</li>
                <li>探索範囲の右端（right）を配列の最後のインデックス（通常はn-1）に設定する</li>
            </ol>
            
            <h4>2. メインループ</h4>
            <ol>
                <li>左端が右端を超えるまで以下の処理を繰り返す：
                    <ul>
                        <li>配列からピボット要素を選択する（通常はランダムに選ぶか、左端・中央・右端の中央値を使用）</li>
                        <li>パーティショニング操作を実行し、ピボット要素を正しい最終位置 p に配置する
                            <ul>
                                <li>パーティショニング後、ピボットより小さい要素は全て左側に、大きい要素は全て右側に配置される</li>
                            </ul>
                        </li>
                        <li>ピボットの最終位置 p と探しているインデックス k を比較する</li>
                        <li>p = k の場合：
                            <ul>
                                <li>配列[k]が k 番目に小さい要素なので、それを結果として返す</li>
                            </ul>
                        </li>
                        <li>p > k の場合：
                            <ul>
                                <li>k 番目の要素はピボットより左側にあるので、右端を p-1 に更新する</li>
                            </ul>
                        </li>
                        <li>p < k の場合：
                            <ul>
                                <li>k 番目の要素はピボットより右側にあるので、左端を p+1 に更新する</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ol>
            
            <h4>3. 結果の返却</h4>
            <ol>
                <li>ループが終了し、k 番目の要素が見つかった場合、その要素を返す</li>
            </ol>
            
            <h4>パーティショニング手順（サブルーチン）</h4>
            <ol>
                <li>ピボット要素を選択し、一時的に保存する</li>
                <li>左端から始まるインデックス i と右端から始まるインデックス j を用意する</li>
                <li>以下の処理を i と j が交差するまで繰り返す：
                    <ul>
                        <li>ピボット以上の要素が見つかるまで i を右に進める</li>
                        <li>ピボット以下の要素が見つかるまで j を左に進める</li>
                        <li>i と j が交差していなければ、配列[i]と配列[j]を交換する</li>
                    </ul>
                </li>
                <li>ピボット要素を適切な位置（i または j）に配置する</li>
                <li>ピボットの最終位置を返す</li>
            </ol>
            
            <h4>メディアン・オブ・メディアンズによるピボット選択（最適化版）</h4>
            <ol>
                <li>配列を5要素ずつのグループに分割する</li>
                <li>各グループ内で要素をソートし、中央値（メディアン）を求める</li>
                <li>グループの中央値だけを集めた新しい配列を作成する</li>
                <li>その配列の中央値（メディアン・オブ・メディアンズ）を再帰的に求める</li>
                <li>求めた値をピボットとして使用する</li>
            </ol>
    
            <h3>計算量</h3>
            <p>クイックセレクトアルゴリズムの計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>平均の場合</strong>: O(n) - 各ステップでパーティションの位置が平均的にバランスよく選ばれる場合</li>
                <li><strong>最悪の場合（ナイーブ実装）</strong>: O(n²) - 毎回最も不均衡なパーティション分割になる場合</li>
                <li><strong>最悪の場合（メディアン・オブ・メディアンズ実装）</strong>: O(n) - 良いピボット選択により線形時間を保証</li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>反復実装</strong>: O(1) - インプレースで実装した場合、追加のメモリをほとんど使わない</li>
                <li><strong>再帰実装</strong>: O(log n) - 平均的な場合の再帰スタックの深さ</li>
                <li><strong>再帰実装（最悪の場合）</strong>: O(n) - 不均衡な分割が続く場合のスタック深さ</li>
            </ul>
            
            <p>クイックセレクトの平均的な線形時間（O(n)）の特性は、非常に効率的であることを意味します。全体をソートする必要がなく、各再帰ステップで探索範囲が平均的に半分になるため、配列全体を1回だけ走査する程度の計算量で済みます。</p>
            
            <p>通常のクイックセレクト実装では、最悪の場合に O(n²) の計算量になる可能性があります。これは、毎回最も不均衡なパーティション分割が発生する状況（例：すでにソート済みの配列で常に最小または最大の要素をピボットとして選んでしまう場合）で起こります。しかし、ランダムなピボット選択を採用することで、このような最悪のケースが発生する確率を非常に低くできます。</p>
            
            <p>さらに高度な実装である「メディアン・オブ・メディアンズ」アルゴリズムを用いたピボット選択を行うと、最悪の場合でも O(n) の時間計算量を保証できます。この方法は理論的には優れていますが、実際の実装では定数倍のオーバーヘッドが大きいため、一般的なケースではランダム化版クイックセレクトの方が実用的なことが多いです。</p>
            
            <p>クイックセレクトは、k 番目の要素を見つけるために配列全体をソートする必要がなく、必要な部分だけを効率的に探索できる点が最大の強みです。特に大規模なデータセットから中央値や特定の分位数を求める際に、ソートのO(n log n)ではなく線形時間O(n)で処理できる点は大きなアドバンテージとなります。</p>
        </div>
    </div>
</body>
</html>