<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FNV-1</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">ハッシュ文字列の問題</a></li>
        <li>FNV-1</li>
    </ul>
    <div class="container">
        <h1>FNV-1</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>FNV-1（Fowler-Noll-Vo）ハッシュは、Glenn Fowler、Landon Curt Noll、Phong Voによって開発された非暗号学的ハッシュ関数です。1991年に最初のバージョンが開発され、その後改良されて現在も広く使用されています。FNV-1は、実装の容易さ、高速性、良好な分散特性を兼ね備えたハッシュアルゴリズムとして知られています。</p>
            
            <h3>基礎知識</h3>
            <p>ハッシュ関数とは、任意のサイズのデータを固定長のビット列（ハッシュ値）に変換する関数です。FNV-1は、バイト列を入力として受け取り、固定サイズのハッシュ値を出力します。通常は32ビット（FNV-1-32）または64ビット（FNV-1-64）のハッシュ値が使用されますが、128ビット、256ビット、512ビットなどの拡張版も存在します。</p>
            <p>FNV-1の基本原理は、初期値（オフセットベース）からスタートし、入力データの各バイトに対して乗算と排他的論理和（XOR）の組み合わせを適用することで、高速にハッシュ値を計算する点にあります。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ハッシュ関数（hash function）</strong>: 任意長のデータを固定長の値に変換する関数</li>
                <li><strong>ハッシュ値（hash value）</strong>: ハッシュ関数の出力として得られる固定長のビット列</li>
                <li><strong>衝突（collision）</strong>: 異なる入力データが同じハッシュ値を生成すること</li>
                <li><strong>オフセットベース（offset basis）</strong>: FNV-1アルゴリズムで使用される初期値</li>
                <li><strong>FNVプライム（FNV prime）</strong>: FNV-1アルゴリズムで使用される素数定数</li>
                <li><strong>非暗号学的ハッシュ（non-cryptographic hash）</strong>: 暗号的安全性は保証されていないが、高速に計算できるハッシュ関数</li>
                <li><strong>アバランシュ効果（avalanche effect）</strong>: 入力の小さな変化が出力に大きな変化をもたらす特性</li>
            </ul>
            
            <h3>特徴</h3>
            <p>FNV-1ハッシュアルゴリズムの主な特徴は以下の通りです：</p>
            <ul>
                <li>実装が非常に単純（乗算と排他的論理和のみを使用）</li>
                <li>計算効率が高く、特に短い入力データに対して高速</li>
                <li>良好な分散特性を持ち、異なる入力に対して均一なハッシュ値分布を生成</li>
                <li>ハードウェア実装が容易（特殊な命令や大きなテーブルが不要）</li>
                <li>様々なビット長（32, 64, 128, 256, 512ビットなど）に対応可能</li>
                <li>FNV-1aという改良版も存在し、さらに優れた分散特性を持つ</li>
                <li>非暗号学的ハッシュ関数であり、暗号的安全性は保証されない</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>FNV-1ハッシュアルゴリズムは以下のような場面で特に有用です：</p>
            <ul>
                <li>ハッシュテーブル（連想配列、辞書）の実装</li>
                <li>データ構造における高速な検索と比較</li>
                <li>データの整合性チェック（非暗号的な用途）</li>
                <li>分散システムにおけるデータ分散（シャーディング）</li>
                <li>ネットワークプロトコルでのパケット処理</li>
                <li>リソース限定環境（組み込みシステムなど）での軽量なハッシュ計算</li>
                <li>キャッシュのインデックス付け</li>
                <li>重複検出（データ重複排除）</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>FNV-1ハッシュアルゴリズムの基本的な手順は以下の通りです：</p>
            <ol>
                <li>ハッシュ値をオフセットベース（初期値）で初期化する</li>
                <li>入力データの各バイトに対して以下の操作を行う：
                    <ol>
                        <li>現在のハッシュ値にFNVプライムを乗算する</li>
                        <li>結果と現在処理中のバイトとの排他的論理和（XOR）を取る</li>
                    </ol>
                </li>
                <li>すべてのバイトを処理したら、最終的なハッシュ値を返す</li>
            </ol>
            
            <p>FNV-1において、オフセットベースとFNVプライムはハッシュのビット長によって異なる定数値が使用されます：</p>
            
            <h4>一般的なFNV定数値:</h4>
            <ul>
                <li>FNV-1-32（32ビット）:
                    <ul>
                        <li>オフセットベース = 2166136261 (16進数: 811C9DC5)</li>
                        <li>FNVプライム = 16777619 (16進数: 01000193)</li>
                    </ul>
                </li>
                <li>FNV-1-64（64ビット）:
                    <ul>
                        <li>オフセットベース = 14695981039346656037 (16進数: CBF29CE484222325)</li>
                        <li>FNVプライム = 1099511628211 (16進数: 100000001B3)</li>
                    </ul>
                </li>
            </ul>
            
            <h4>具体例: FNV-1-32で文字列「ABC」をハッシュ化する場合</h4>
            <ol>
                <li>初期ハッシュ値 = 2166136261（オフセットベース）</li>
                <li>最初のバイト 'A' (ASCII: 65) の処理:
                    <ul>
                        <li>ハッシュ値 = 2166136261 × 16777619 = 36340275025595</li>
                        <li>ハッシュ値 = 36340275025595 XOR 65 = 36340275025658</li>
                    </ul>
                </li>
                <li>次のバイト 'B' (ASCII: 66) の処理:
                    <ul>
                        <li>ハッシュ値 = 36340275025658 × 16777619 = 609649775654793964</li>
                        <li>ハッシュ値 = 609649775654793964 XOR 66 = 609649775654794002</li>
                    </ul>
                </li>
                <li>最後のバイト 'C' (ASCII: 67) の処理:
                    <ul>
                        <li>ハッシュ値 = 609649775654794002 × 16777619 = 10228622361354532883918</li>
                        <li>ハッシュ値 = 10228622361354532883918 XOR 67 = 10228622361354532883853</li>
                    </ul>
                </li>
                <li>32ビットに切り詰める（モジュロ 2^32）と、最終的なハッシュ値は 1633995686</li>
            </ol>
            
            <p>なお、FNV-1の改良版であるFNV-1aアルゴリズムでは、各バイトとの排他的論理和を乗算の前に行います。これにより、入力の小さな変化がより大きなハッシュ値の変化をもたらす（アバランシュ効果の向上）という特性が得られます。</p>
            
            <h3>計算量</h3>
            <p>FNV-1ハッシュアルゴリズムの計算量は以下の特性を持ちます：</p>
            <ul>
                <li><strong>時間計算量</strong>: O(n) - nは入力データのバイト数</li>
                <li><strong>空間計算量</strong>: O(1) - 定数量のメモリのみを使用</li>
            </ul>
            
            <p>FNV-1の主な利点の一つは、その計算効率の高さです。各バイトの処理に必要な演算は乗算と排他的論理和のみであり、複雑な操作やテーブル参照は必要ありません。これにより、特に短い入力データに対して非常に高速に動作します。</p>
            
            <p>また、FNV-1は入力データを一度だけ走査するため、ストリーミングデータの処理にも適しています。大量のデータをメモリに保持することなく、バイトごとに逐次処理することが可能です。</p>
            
            <p>しかし、非暗号学的ハッシュ関数であるため、意図的に衝突を発生させることが可能であり、セキュリティが重要な用途（デジタル署名、パスワードハッシュなど）には適していません。そのような場合は、SHA-256やBLAKE2などの暗号学的ハッシュ関数を使用すべきです。</p>
        </div>
    </div>
</body>
</html>