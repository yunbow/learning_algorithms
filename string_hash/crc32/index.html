<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRC32</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">ハッシュ文字列の問題</a></li>
        <li>CRC32</li>
    </ul>
    <div class="container">
        <h1>CRC32</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>CRC32（Cyclic Redundancy Check 32-bit）は、データの整合性を検証するために広く使用されるチェックサム関数です。バイナリデータから32ビット（8桁の16進数）のハッシュ値を生成し、データ転送やストレージにおけるエラー検出に利用されます。</p>
            
            <h3>基礎知識</h3>
            <p>CRCは巡回冗長検査（Cyclic Redundancy Check）の略で、データ転送中に発生する可能性のあるエラーを検出するために設計されています。CRCは多項式除算の原理に基づいており、以下の特性を持っています：</p>
            <ul>
                <li><strong>エラー検出</strong>：単一ビットのエラーを100%検出できる</li>
                <li><strong>バースト（連続）エラー検出</strong>：CRC32の場合、32ビット長までのバーストエラーを検出可能</li>
                <li><strong>計算効率</strong>：高速に計算可能で、ハードウェア実装も容易</li>
                <li><strong>固定長出力</strong>：入力データの長さに関わらず、常に32ビットの結果を出力</li>
            </ul>
            <p>CRCは暗号学的ハッシュ関数ではなく、意図的なデータ改ざんに対する耐性は低いですが、偶発的なデータ破損を検出するのに非常に効果的です。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>多項式（polynomial）</strong>：CRC計算の基礎となる、ビット列を表現する数学的多項式</li>
                <li><strong>生成多項式（generator polynomial）</strong>：CRC計算で使用される特定の多項式で、CRC32では特定の33ビットの値が使用される</li>
                <li><strong>レジスタ（register）</strong>：CRC計算中に現在の状態を保持する32ビットの値</li>
                <li><strong>ビット反転（bit inversion）</strong>：すべてのビットを0→1、1→0に変換する操作</li>
                <li><strong>シフト演算（shift operation）</strong>：ビット列を左または右に移動させる操作</li>
                <li><strong>XOR演算（exclusive OR）</strong>：2つのビットが異なる場合に1、同じ場合に0を返す論理演算</li>
                <li><strong>チェックサム（checksum）</strong>：データから計算された検証値の総称</li>
                <li><strong>CRCテーブル（CRC table）</strong>：計算を高速化するために使用される、事前計算された値の配列</li>
                <li><strong>初期値（initial value）</strong>：CRC計算を開始する前にレジスタに設定される値</li>
                <li><strong>最終XOR値（final XOR value）</strong>：計算完了後にレジスタとXOR演算される値</li>
            </ul>
            
            <h3>特徴</h3>
            <p>CRC32の主な特徴は以下の通りです：</p>
            <ul>
                <li><strong>32ビット出力</strong>：結果は通常8桁の16進数（00000000～FFFFFFFF）で表現される</li>
                <li><strong>標準多項式</strong>：一般的にIEEE 802.3で定義された多項式 0x104C11DB7（x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1）が使用される</li>
                <li><strong>異なるバリアント</strong>：複数のCRC32実装があり、初期値、最終XOR値、入力/出力反転の有無などが異なる</li>
                <li><strong>主なバリアント</strong>：
                    <ul>
                        <li>CRC-32（IEEE 802.3、Ethernet、ZIP、PNG等で使用）</li>
                        <li>CRC-32C（Castagnoli多項式を使用、iSCSI、SCTP等で使用）</li>
                        <li>CRC-32K（Koopman多項式を使用）</li>
                    </ul>
                </li>
                <li><strong>テーブル駆動実装</strong>：多くの実装では、計算を高速化するために256エントリのテーブルを使用</li>
                <li><strong>ハードウェアサポート</strong>：多くのプロセッサでCRC32計算を高速化する専用命令が提供されている</li>
                <li><strong>低い暗号強度</strong>：暗号学的ハッシュ関数（SHA-256など）に比べて衝突発見が容易</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>CRC32は以下のような様々な用途で使用されています：</p>
            <ul>
                <li><strong>データ転送プロトコル</strong>：Ethernet、Bluetooth、USB、HDLCなどの通信プロトコルでデータフレームの整合性チェック</li>
                <li><strong>ファイル形式</strong>：ZIP、PNG、GIF、JAR、PDFなどの多くのファイル形式でデータの整合性検証</li>
                <li><strong>ストレージシステム</strong>：ハードディスク、SSDなどのストレージデバイスでのデータ検証</li>
                <li><strong>ネットワークパケット</strong>：イーサネットフレームなどのネットワークパケットの整合性確認</li>
                <li><strong>簡易ハッシュ関数</strong>：高速なハッシュテーブル実装のための値生成</li>
                <li><strong>データ重複検出</strong>：大量データの中から重複を見つけるための簡易チェック</li>
                <li><strong>バックアップシステム</strong>：ファイルの変更検出やデータ検証</li>
                <li><strong>エラー検出コード</strong>：RAIDシステムや他のエラー検出システム</li>
            </ul>
            
            <p>CRC32の使用における留意点：</p>
            <ul>
                <li>CRC32は意図的な改ざんの検出には適していないため、セキュリティが重要な場面では暗号学的ハッシュ関数（SHA-2、SHA-3など）を使用すべき</li>
                <li>非常に大きなデータセットでは衝突（異なる入力から同じCRC値が生成される状況）の可能性が高まる</li>
                <li>用途に応じて適切なCRC32バリアント（標準CRC-32、CRC-32C、CRC-32Kなど）を選択する必要がある</li>
                <li>高信頼性が必要な場合は、CRC32だけでなく複数の検証手段を組み合わせることが推奨される</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>CRC32計算の基本的な手順は以下の通りです：</p>
            
            <h4>直接計算法</h4>
            <ol>
                <li><strong>初期化</strong>：
                    <ol>
                        <li>CRCレジスタを初期値（通常は0xFFFFFFFF）で初期化</li>
                        <li>使用する生成多項式を決定（標準CRC32の場合は0x104C11DB7）</li>
                    </ol>
                </li>
                <li><strong>処理</strong>：
                    <ol>
                        <li>入力データを1バイトずつ処理</li>
                        <li>現在のバイトをCRCレジスタの最上位バイトとXOR</li>
                        <li>結果のビットを左から順に8回処理：
                            <ol>
                                <li>CRCレジスタを左に1ビットシフト</li>
                                <li>シフト演算でレジスタから押し出されたビットが1だった場合、レジスタと生成多項式をXOR</li>
                            </ol>
                        </li>
                        <li>すべてのバイトが処理されるまで繰り返す</li>
                    </ol>
                </li>
                <li><strong>最終化</strong>：
                    <ol>
                        <li>CRCレジスタを最終XOR値（通常は0xFFFFFFFF）とXOR</li>
                        <li>結果の32ビット値がCRC32チェックサム</li>
                    </ol>
                </li>
            </ol>
            
            <h4>テーブル駆動法（一般的な実装）</h4>
            <ol>
                <li><strong>テーブル準備</strong>：
                    <ol>
                        <li>256エントリのテーブルを事前計算
                            <ul>
                                <li>各エントリはバイト値0～255それぞれに対する8ビット処理の結果を表す</li>
                                <li>これにより、1バイトごとに8回のビット処理を1回のテーブル参照に置き換え可能</li>
                            </ul>
                        </li>
                    </ol>
                </li>
                <li><strong>初期化</strong>：
                    <ol>
                        <li>CRCレジスタを初期値（通常は0xFFFFFFFF）で初期化</li>
                    </ol>
                </li>
                <li><strong>処理</strong>：
                    <ol>
                        <li>入力データを1バイトずつ処理</li>
                        <li>CRCレジスタの最下位バイトと現在のデータバイトをXOR</li>
                        <li>結果をテーブルのインデックスとして使用し、対応する値を取得</li>
                        <li>CRCレジスタを8ビット右シフト</li>
                        <li>シフトしたレジスタとテーブルから取得した値をXOR</li>
                        <li>結果を新しいCRCレジスタ値とする</li>
                        <li>すべてのバイトが処理されるまで繰り返す</li>
                    </ol>
                </li>
                <li><strong>最終化</strong>：
                    <ol>
                        <li>CRCレジスタを最終XOR値（通常は0xFFFFFFFF）とXOR</li>
                        <li>結果の32ビット値がCRC32チェックサム</li>
                    </ol>
                </li>
            </ol>
            
            <h4>スライス処理法（高速実装）</h4>
            <p>テーブル駆動法の拡張で、複数のバイトを一度に処理します。主に4つの256エントリテーブルを使用し、4バイトずつ処理します。</p>
            <ol>
                <li><strong>テーブル準備</strong>：
                    <ol>
                        <li>4つの256エントリテーブルを事前計算</li>
                    </ol>
                </li>
                <li><strong>初期化</strong>：
                    <ol>
                        <li>テーブル駆動法と同様</li>
                    </ol>
                </li>
                <li><strong>処理</strong>：
                    <ol>
                        <li>入力データを可能な限り4バイトずつ処理</li>
                        <li>現在のCRCレジスタと4バイトデータをXOR</li>
                        <li>結果の各バイトをインデックスとして4つのテーブルから値を取得</li>
                        <li>取得した4つの値をすべてXORして新しいCRCレジスタ値とする</li>
                        <li>残りのバイトは1バイトずつ標準的な方法で処理</li>
                    </ol>
                </li>
                <li><strong>最終化</strong>：
                    <ol>
                        <li>テーブル駆動法と同様</li>
                    </ol>
                </li>
            </ol>
            
            <h4>HW命令を使用した方法</h4>
            <p>現代のプロセッサ（Intel、AMDなど）は専用のCRC32命令を提供しています。</p>
            <ol>
                <li><strong>初期化</strong>：
                    <ol>
                        <li>CRCレジスタを初期値で初期化</li>
                    </ol>
                </li>
                <li><strong>処理</strong>：
                    <ol>
                        <li>専用命令（例：Intel/AMDのCRC32命令）を使用して、1バイト、2バイト、4バイト、または8バイトの単位でデータを処理</li>
                        <li>アーキテクチャに応じて最適なサイズのデータチャンクを選択</li>
                    </ol>
                </li>
                <li><strong>最終化</strong>：
                    <ol>
                        <li>通常のCRC32と同様</li>
                    </ol>
                </li>
            </ol>
            
            <p>CRC32計算ではバイトオーダー（エンディアン）に注意が必要です。多くの標準実装では以下の特性があります：</p>
            <ul>
                <li><strong>リトルエンディアン処理</strong>：バイトは最下位ビットから処理</li>
                <li><strong>入力反転</strong>：各入力バイトのビット順を反転して処理</li>
                <li><strong>出力反転</strong>：最終CRC値のビット順を反転</li>
            </ul>
            
            <p>異なるCRC32実装（CRC-32、CRC-32C、CRC-32K）は、生成多項式、初期値、最終XOR値、入力/出力反転の有無などのパラメータが異なります。</p>
            
            <h3>計算量</h3>
            <p>CRC32の計算量は以下の特性を持ちます：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>直接計算法</strong>：O(n*b) - nはデータサイズ（バイト数）、bはバイトあたりの処理ビット数（8）</li>
                <li><strong>テーブル駆動法</strong>：O(n) - 入力データサイズに比例</li>
                <li><strong>スライス処理法</strong>：O(n) - 定数係数がテーブル駆動法より小さい</li>
                <li><strong>HW命令を使用した方法</strong>：O(n) - 最も高速</li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>直接計算法</strong>：O(1) - 固定サイズの作業領域（レジスタ）のみ</li>
                <li><strong>テーブル駆動法</strong>：O(1) - 固定サイズのテーブル（256エントリ × 4バイト = 1KB）</li>
                <li><strong>スライス処理法</strong>：O(1) - 複数の固定サイズテーブル（4 × 256エントリ × 4バイト = 4KB）</li>
                <li><strong>HW命令を使用した方法</strong>：O(1) - 固定サイズの作業領域のみ</li>
            </ul>
            
            <p>パフォーマンス面での考慮事項：</p>
            <ul>
                <li>テーブル駆動法は直接計算法に比べて約8倍高速</li>
                <li>スライス処理法はテーブル駆動法に比べて約4倍高速</li>
                <li>ハードウェア命令はソフトウェア実装よりも大幅に高速（10倍以上）</li>
                <li>小さなデータセットでは、テーブル初期化のオーバーヘッドが問題になる可能性がある</li>
                <li>大きなデータセットでは、メモリアクセスパターンとキャッシュ利用効率が重要</li>
                <li>並列処理が可能なため、大きなデータセットは分割して処理し、結果を組み合わせることも可能</li>
            </ul>
            
            <p>CRC32は計算効率が良く、単純なビット操作で実装できるため、組み込みシステムや高速データ処理が必要な場面で広く使用されています。特にハードウェアサポートがある場合は、非常に高速に計算することができます。</p>
        </div>
    </div>
</body>
</html>