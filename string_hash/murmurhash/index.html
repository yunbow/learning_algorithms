<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MurmurHash</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">Kotlin問題</a></li>
        <li>MurmurHash</li>
    </ul>

    <div class="container">
        <h1>MurmurHash</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>MurmurHashは、非暗号化ハッシュ関数の一種で、高速な計算とバランスの良い分散特性を両立させることを目的として設計されました。「Murmur」という名前は、乗算（Multiply）と回転（Rotate）という操作を繰り返すことに由来しています。主に高速な一般用途のハッシングやデータの整合性検証、ハッシュテーブルの実装などに使用されています。</p>
            
            <h3>基礎知識</h3>
            <p>MurmurHashは、Austin Applebyによって2008年に開発され、その後改良が加えられてきました。このアルゴリズムの主な設計目標は、高速な実行速度と低い衝突率の両立です。特にMurmurHash3は広く採用されており、32ビット版と128ビット版が提供されています。</p>
            <p>このハッシュ関数は、一連のデータ（バイト列）を固定長のハッシュ値に変換します。シードと呼ばれる初期値を変更することで、同じ入力に対して異なるハッシュ値を生成することも可能です。MurmurHashは擬似乱数生成や分散システムでのデータのパーティショニングなど、多くの応用場面で活用されています。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ハッシュ関数（hash function）</strong>: 任意サイズの入力データを固定サイズの値に変換する関数</li>
                <li><strong>ハッシュ値（hash value）</strong>: ハッシュ関数によって生成された固定長の値</li>
                <li><strong>シード値（seed）</strong>: ハッシュ計算の初期値となる数値</li>
                <li><strong>衝突（collision）</strong>: 異なる入力データが同じハッシュ値を生成する現象</li>
                <li><strong>アバランシェ効果（avalanche effect）</strong>: 入力の小さな変化がハッシュ値の大きな変化をもたらす性質</li>
                <li><strong>ブロック処理（block processing）</strong>: 入力データを一定サイズのブロックに分割して処理する方法</li>
                <li><strong>ファイナライズ（finalization）</strong>: ハッシュ計算の最終段階で均一な分布を確保するための処理</li>
                <li><strong>非暗号化ハッシュ（non-cryptographic hash）</strong>: セキュリティよりも速度を重視したハッシュ関数</li>
                <li><strong>バイトオーダー（byte order）</strong>: マルチバイトデータの解釈順序（リトルエンディアン/ビッグエンディアン）</li>
            </ul>
            
            <h3>特徴</h3>
            <p>MurmurHashの主な特徴は以下の通りです：</p>
            <ul>
                <li>高速な計算速度（特に短い入力に対して効率的）</li>
                <li>良好な分散特性と低い衝突率</li>
                <li>優れたアバランシェ効果（入力の小さな変化がハッシュ値に大きく影響する）</li>
                <li>複数のバージョンとビット長のバリアント（32ビット、64ビット、128ビットなど）</li>
                <li>シード値による同一入力からの異なるハッシュ値生成</li>
                <li>プラットフォーム依存性が低い（一部のバージョンを除く）</li>
                <li>暗号化用途には不適切（意図的な衝突を生成できる可能性がある）</li>
                <li>一貫性のあるハッシュ分布（クラスタリングの発生が少ない）</li>
                <li>シンプルな実装と理解しやすいアルゴリズム構造</li>
                <li>メモリ使用量が少ない（状態管理が最小限）</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>MurmurHashは以下のような場面で特に有用です：</p>
            <ul>
                <li>ハッシュテーブル実装（HashMap、HashSetなど）のハッシュ関数</li>
                <li>Bloom Filter、Count-Min Sketchなどの確率的データ構造</li>
                <li>データの整合性検証（非セキュリティ用途）</li>
                <li>キャッシュシステムでのキーインデックス作成</li>
                <li>分散システムでのデータの分散とパーティショニング</li>
                <li>コンテンツの重複検出（ファイルやデータのフィンガープリント）</li>
                <li>擬似乱数生成（非暗号化用途）</li>
                <li>機械学習でのフィーチャーハッシング（特徴量圧縮）</li>
                <li>大規模データセットのクラスタリング</li>
                <li>データベースのインデックス作成やシャーディング</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>ここではMurmurHash3の32ビット版の基本的な手順を説明します。このバージョンは最も広く使用されているバリアントの一つです。</p>
            
            <h4>1. 初期化</h4>
            <ol>
                <li>32ビットのシード値を準備する</li>
                <li>入力データ（バイト列）を取得する</li>
                <li>ハッシュ値を初期化する（シード値を使用）</li>
                <li>マジック定数を定義する：
                    <ul>
                        <li>c1 = 0xcc9e2d51</li>
                        <li>c2 = 0x1b873593</li>
                        <li>r1 = 15 (回転ビット数1)</li>
                        <li>r2 = 13 (回転ビット数2)</li>
                        <li>m = 5 (乗算係数1)</li>
                        <li>n = 0xe6546b64 (加算定数)</li>
                    </ul>
                </li>
            </ol>
            
            <h4>2. ブロック処理</h4>
            <ol>
                <li>入力データを4バイト（32ビット）のブロックに分割する</li>
                <li>各ブロックに対して以下の処理を行う：
                    <ul>
                        <li>ブロックをリトルエンディアンの32ビットの整数として解釈する（k）</li>
                        <li>k = k * c1</li>
                        <li>k = (k << r1) | (k >> (32 - r1)) （左回転r1ビット）</li>
                        <li>k = k * c2</li>
                        <li>hash = hash ^ k</li>
                        <li>hash = (hash << r2) | (hash >> (32 - r2)) （左回転r2ビット）</li>
                        <li>hash = hash * m + n</li>
                    </ul>
                </li>
            </ol>
            
            <h4>3. 残りのバイト処理</h4>
            <ol>
                <li>4バイトのブロックに収まらなかった残りのバイト（0〜3バイト）を処理する：
                    <ul>
                        <li>残りのバイトを適切な位置に配置した32ビット値を作成する</li>
                        <li>この値にブロック処理と同様の混合操作を適用する</li>
                        <li>結果をハッシュ値とXOR演算する</li>
                    </ul>
                </li>
            </ol>
            
            <h4>4. ファイナライズ（Finalization）</h4>
            <ol>
                <li>ハッシュ値に入力データの長さを混ぜ込む</li>
                <li>アバランシェミキシングを適用して最終的なハッシュ値を生成する：
                    <ul>
                        <li>hash = hash ^ (hash >> 16)</li>
                        <li>hash = hash * 0x85ebca6b</li>
                        <li>hash = hash ^ (hash >> 13)</li>
                        <li>hash = hash * 0xc2b2ae35</li>
                        <li>hash = hash ^ (hash >> 16)</li>
                    </ul>
                </li>
            </ol>
            
            <h4>5. 結果の返却</h4>
            <ol>
                <li>最終的な32ビットハッシュ値を返す</li>
            </ol>
            
            <h4>MurmurHash3の128ビット版</h4>
            <p>128ビット版では、基本的な原理は同じですが、以下の点が異なります：</p>
            <ul>
                <li>4つの32ビットのハッシュ状態を並行して更新する</li>
                <li>16バイト（128ビット）のブロックを一度に処理する</li>
                <li>より複雑なファイナライズステップを使用する</li>
                <li>32ビット版と64ビット版のCPUアーキテクチャ向けに最適化された異なるバリアントがある</li>
            </ul>
    
            <h3>計算量</h3>
            <p>MurmurHashアルゴリズムの計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>平均・最悪の場合</strong>: O(n) - 入力データサイズに比例</li>
                <li>各バイトは基本的に一度だけ処理され、定数時間の操作のみが適用される</li>
                <li>入力データの長さに関係なく、ファイナライズステップは一定時間</li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>全ての場合</strong>: O(1) - 定数量のメモリのみを使用</li>
                <li>入力データサイズに関係なく、固定数の変数のみを使用（32ビット版では数個の32ビット変数）</li>
                <li>追加のバッファやデータ構造は不要</li>
            </ul>
            
            <p>MurmurHashの優れた点は、その計算効率と実用的な性能にあります。線形時間（O(n)）の計算量は避けられませんが（すべてのデータを少なくとも一度は読む必要があるため）、実際の実装では非常に効率的です。単純な演算（乗算、XOR、ビットシフト）のみを使用し、分岐予測ミスを最小限に抑える設計になっています。</p>
            
            <p>多くのプラットフォームやプログラミング言語でMurmurHashの実装が提供されており、特に短い入力に対して優れたパフォーマンスを発揮します。SHA-1やMD5などの暗号学的ハッシュ関数と比較すると、MurmurHashは数倍から数十倍高速です。これはセキュリティよりも速度と分散特性を重視した設計の結果です。</p>
            
            <p>ただし、MurmurHashは暗号学的に安全ではないため、パスワードのハッシュや安全が要求される用途には適していません。意図的に衝突を生成できる可能性があるため、悪意のある入力に対して脆弱性を持つことがあります。用途に応じて適切なハッシュ関数を選択することが重要です。</p>
        </div>
    </div>
</body>
</html>