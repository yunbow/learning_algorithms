<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ベルマン-フォード法 (Bellman-Ford)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">グラフの最短経路</a></li>
        <li>ベルマン-フォード法</li>
    </ul>
    <div class="container">
        <h1>ベルマン-フォード法 (Bellman-Ford)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>ベルマン-フォード法は、グラフ上の単一始点最短経路問題を解くためのアルゴリズムで、1950年代にRichard BellmanとLester Fordによって独立に発見されました。このアルゴリズムは辺の重みが負の値を持つ場合でも正しく動作する特徴があり、また負の閉路（負の重みの合計を持つ閉路）の検出にも利用できます。</p>
            
            <h3>基礎知識</h3>
            <p>最短経路問題とは、グラフ上の2つの頂点間で、辺の重みの合計が最小となる経路を見つける問題です。ベルマン-フォード法は、始点から他のすべての頂点への最短距離を計算します。</p>
            <p>このアルゴリズムは動的計画法の一種であり、「緩和（relaxation）」と呼ばれる操作を繰り返し適用することで最短経路を求めます。緩和とは、ある頂点を経由することで、別の頂点への最短距離が改善されるかどうかを確認する操作です。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>頂点（vertex）</strong>: グラフを構成する点</li>
                <li><strong>辺（edge）</strong>: 頂点同士を結ぶ線</li>
                <li><strong>重み（weight）</strong>: 辺に割り当てられた値（距離やコストなど）</li>
                <li><strong>緩和（relaxation）</strong>: 既知の経路よりも短い経路が見つかった場合に距離を更新する操作</li>
                <li><strong>負の閉路（negative cycle）</strong>: 辺の重みの合計が負となる閉路</li>
                <li><strong>動的計画法（dynamic programming）</strong>: 問題を部分問題に分割して解く手法</li>
                <li><strong>隣接リスト（adjacency list）</strong>: グラフの表現方法の一つで、各頂点から出る辺のリストを保持する</li>
            </ul>
            
            <h3>特徴</h3>
            <p>ベルマン-フォード法の主な特徴は以下の通りです：</p>
            <ul>
                <li>辺の重みが負の値を持つグラフでも正しく動作する</li>
                <li>負の閉路が存在するかどうかを検出できる</li>
                <li>実装が比較的シンプル</li>
                <li>すべての辺に対して繰り返し処理を行うため、疎なグラフでもダイクストラ法より非効率</li>
                <li>分散システムにおける距離ベクトルルーティングプロトコルの基礎となっている</li>
                <li>動的計画法の典型的な応用例としても知られている</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>ベルマン-フォード法は以下のような場面で特に有用です：</p>
            <ul>
                <li>負の辺の重みを持つグラフでの最短経路問題</li>
                <li>負の閉路の検出が必要な場合</li>
                <li>ネットワークルーティングプロトコル（RIP など）</li>
                <li>為替レート計算における裁定取引の検出</li>
                <li>制約充足問題の解法</li>
                <li>ロボット経路計画におけるコスト最小化</li>
                <li>VLSI設計における信号遅延の最適化</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>ベルマン-フォード法の基本的な手順は以下の通りです：</p>
            <ol>
                <li>グラフG = (V, E)と始点sを入力として受け取る</li>
                <li>すべての頂点vについて、距離d[v]を初期化する：
                    <ul>
                        <li>d[s] = 0（始点までの距離は0）</li>
                        <li>d[v] = ∞（その他の頂点までの距離は無限大）</li>
                    </ul>
                </li>
                <li>以下の操作を|V|-1回繰り返す（|V|は頂点の数）：
                    <ul>
                        <li>すべての辺(u, v) ∈ Eについて緩和操作を行う：
                            <ul>
                                <li>もし d[u] + weight(u, v) < d[v] ならば d[v] = d[u] + weight(u, v) に更新する</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>負の閉路の検出（オプション）：
                    <ul>
                        <li>すべての辺(u, v) ∈ Eについて、d[u] + weight(u, v) < d[v] となる辺があれば、グラフには負の閉路が存在する</li>
                    </ul>
                </li>
            </ol>
            
            <p>このアルゴリズムは|V|-1回の反復で、始点からすべての頂点への最短距離を正しく計算します。これは、最悪の場合でも最短経路に含まれる辺の数が高々|V|-1個であるという事実に基づいています。</p>
            
            <h4>具体例: 5頂点6辺のグラフでの実行</h4>
            <p>以下のグラフを考えます：</p>
            <ul>
                <li>頂点: A, B, C, D, E（Aを始点とする）</li>
                <li>辺と重み: (A,B,6), (A,C,4), (B,C,-2), (B,E,8), (C,D,3), (D,E,-3)</li>
            </ul>
            
            <p>ベルマン-フォード法の実行過程：</p>
            <ol>
                <li>初期化: d[A]=0, d[B]=∞, d[C]=∞, d[D]=∞, d[E]=∞</li>
                <li>第1回反復:
                    <ul>
                        <li>(A,B): d[B] = min(∞, 0+6) = 6</li>
                        <li>(A,C): d[C] = min(∞, 0+4) = 4</li>
                        <li>(B,C): d[C] = min(4, 6-2) = 4</li>
                        <li>(B,E): d[E] = min(∞, 6+8) = 14</li>
                        <li>(C,D): d[D] = min(∞, 4+3) = 7</li>
                        <li>(D,E): d[E] = min(14, 7-3) = 4</li>
                    </ul>
                </li>
                <li>第2回反復:
                    <ul>
                        <li>(B,C): d[C] = min(4, 6-2) = 4</li>
                        <li>(C,D): d[D] = min(7, 4+3) = 7</li>
                        <li>(その他の辺では更新なし)</li>
                    </ul>
                </li>
                <li>第3回および第4回反復: 距離の更新なし</li>
            </ol>
            
            <p>最終的な最短距離: d[A]=0, d[B]=6, d[C]=4, d[D]=7, d[E]=4</p>
            <p>このグラフには負の閉路が存在しないため、アルゴリズムは正しい最短距離を計算します。</p>
            
            <h3>計算量</h3>
            <p>ベルマン-フォード法の計算量は以下の特性を持ちます：</p>
            <ul>
                <li><strong>時間計算量</strong>: O(|V|×|E|)
                    <ul>
                        <li>|V|は頂点の数、|E|は辺の数</li>
                        <li>外側のループは|V|-1回実行</li>
                        <li>内側のループですべての辺を処理（O(|E|)）</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(|V|)
                    <ul>
                        <li>各頂点までの距離を格納するための配列が必要</li>
                        <li>経路復元のために前節点を記録する場合も同様にO(|V|)</li>
                    </ul>
                </li>
            </ul>
            
            <p>ベルマン-フォード法はダイクストラ法と比較すると一般的に効率が劣りますが、負の辺の重みを持つグラフにも適用できるという重要な利点があります。完全グラフの場合、|E| = O(|V|²)となるため、最悪の場合の時間計算量はO(|V|³)になりますが、実際のグラフは通常疎であり、|E| ≪ |V|²の関係が成り立つことが多いため、多くの実用的なケースでは計算量は理論上の最悪値よりもはるかに小さくなります。</p>
            
            <p>また、SPFA（Shortest Path Faster Algorithm）など、ベルマン-フォード法を改良したアルゴリズムも提案されており、平均的なケースでの実行効率を向上させることができます。</p>
        </div>
    </div>
</body>
</html>