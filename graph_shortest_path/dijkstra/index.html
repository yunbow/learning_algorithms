<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ダイクストラ法 (Dijkstra)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">グラフの最短経路</a></li>
        <li>ダイクストラ法</li>
    </ul>
    <div class="container">
        <h1>ダイクストラ法 (Dijkstra)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>ダイクストラ法（Dijkstra's algorithm）は、グラフ上の単一始点最短経路問題を解くためのアルゴリズムです。1956年にオランダの計算機科学者エドガー・W・ダイクストラによって考案されました。非負の辺の重みを持つグラフに対して、ある頂点から他のすべての頂点への最短経路を効率的に求めることができます。</p>
            
            <h3>基礎知識</h3>
            <p>グラフ理論における最短経路問題とは、グラフの2つの頂点間で最も距離（または時間、コストなど）が小さくなる経路を見つける問題です。ダイクストラ法は、始点から各頂点への最短距離を逐次的に確定していくことで、効率的に解を求めます。</p>
            <p>このアルゴリズムの基礎となる考え方は「貪欲法」と呼ばれるアプローチで、各ステップで最も良い選択（この場合は最も近い未確定頂点）を選ぶことで、最終的な最適解を構築していきます。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>グラフ（Graph）</strong>: 頂点（ノード）と辺（エッジ）の集合</li>
                <li><strong>頂点（Vertex/Node）</strong>: グラフの基本要素、交差点や地点などを表現</li>
                <li><strong>辺（Edge）</strong>: 頂点同士を結ぶ線、道路や経路などを表現</li>
                <li><strong>重み（Weight）</strong>: 辺に関連付けられた値（距離、時間、コストなど）</li>
                <li><strong>隣接（Adjacent）</strong>: 直接辺でつながっている頂点同士の関係</li>
                <li><strong>経路（Path）</strong>: 連続する辺を通って移動できる頂点の列</li>
                <li><strong>最短経路（Shortest Path）</strong>: 2頂点間で重みの合計が最小となる経路</li>
                <li><strong>優先度キュー（Priority Queue）</strong>: 最小（または最大）の要素を効率的に取り出せるデータ構造</li>
                <li><strong>緩和操作（Relaxation）</strong>: より短い経路が見つかった場合に距離を更新する操作</li>
            </ul>
            
            <h3>特徴</h3>
            <p>ダイクストラ法の主な特徴は以下の通りです：</p>
            <ul>
                <li>非負の辺の重みを持つグラフに対して正確な解を与える</li>
                <li>貪欲法に基づいており、各ステップで最も近い未確定の頂点を選択する</li>
                <li>優先度キューを使用することで計算効率を向上させることができる</li>
                <li>負の辺の重みを持つグラフには適用できない（その場合はベルマン-フォード法などを使用）</li>
                <li>単一始点から全頂点への最短経路を一度に計算できる</li>
                <li>実装が比較的簡単で理解しやすい</li>
                <li>最短経路だけでなく、その経路の具体的な道筋も記録できる</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>ダイクストラ法は以下のような場面で特に有用です：</p>
            <ul>
                <li>ナビゲーションシステムや地図アプリケーションでの経路探索</li>
                <li>通信ネットワークでのパケットルーティング</li>
                <li>ソーシャルネットワークでの人間関係の距離計算</li>
                <li>交通網の設計と最適化</li>
                <li>ロボットの経路計画</li>
                <li>物流システムでの配送経路最適化</li>
                <li>オンラインゲームにおけるキャラクターの移動経路計算</li>
                <li>ネットワークフロー問題や割り当て問題の解法の一部</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>ダイクストラ法の基本的な手順は以下の通りです：</p>
            <ol>
                <li>始点の距離を0、他のすべての頂点の距離を無限大に初期化する</li>
                <li>すべての頂点を「未確定」としてマークする</li>
                <li>現在の距離が最小の未確定頂点を選択する</li>
                <li>選択した頂点を「確定」としてマークする</li>
                <li>選択した頂点に隣接するすべての未確定頂点について、現在の距離と、選択した頂点を経由した場合の距離を比較し、より短い方で距離を更新する（緩和操作）</li>
                <li>未確定の頂点がなくなるか、残りの未確定頂点への距離がすべて無限大になるまで、ステップ3～5を繰り返す</li>
            </ol>
            
            <p>このプロセスが終了すると、始点から到達可能なすべての頂点への最短距離が計算されます。また、各頂点の「前の頂点」を記録しておくことで、実際の最短経路を再構築することも可能です。</p>
            
            <h4>具体例: シンプルなグラフでの最短経路計算</h4>
            <p>以下の5頂点からなるグラフで、頂点Aから他のすべての頂点への最短経路を考えます：</p>
            <ul>
                <li>頂点: A, B, C, D, E</li>
                <li>辺と重み: 
                    <ul>
                        <li>A→B: 重み4</li>
                        <li>A→C: 重み2</li>
                        <li>B→E: 重み3</li>
                        <li>C→B: 重み1</li>
                        <li>C→D: 重み2</li>
                        <li>D→E: 重み2</li>
                    </ul>
                </li>
            </ul>
            <p>ダイクストラ法の実行過程は以下のようになります：</p>
            <ol>
                <li>初期化: dist[A]=0, dist[B]=∞, dist[C]=∞, dist[D]=∞, dist[E]=∞</li>
                <li>頂点Aを選択し確定: 
                    <ul>
                        <li>A→B: dist[B] = min(∞, 0+4) = 4</li>
                        <li>A→C: dist[C] = min(∞, 0+2) = 2</li>
                    </ul>
                </li>
                <li>最小距離を持つ未確定頂点Cを選択し確定:
                    <ul>
                        <li>C→B: dist[B] = min(4, 2+1) = 3</li>
                        <li>C→D: dist[D] = min(∞, 2+2) = 4</li>
                    </ul>
                </li>
                <li>最小距離を持つ未確定頂点Bを選択し確定:
                    <ul>
                        <li>B→E: dist[E] = min(∞, 3+3) = 6</li>
                    </ul>
                </li>
                <li>最小距離を持つ未確定頂点Dを選択し確定:
                    <ul>
                        <li>D→E: dist[E] = min(6, 4+2) = 6</li>
                    </ul>
                </li>
                <li>最後に頂点Eを選択し確定</li>
            </ol>
            <p>最終結果: dist[A]=0, dist[B]=3, dist[C]=2, dist[D]=4, dist[E]=6</p>
            <p>つまり、頂点Aから各頂点への最短距離は、B=3, C=2, D=4, E=6となります。</p>
            
            <h3>計算量</h3>
            <p>ダイクストラ法の計算量は、実装方法と使用するデータ構造によって異なります：</p>
            <ul>
                <li><strong>時間計算量</strong>:
                    <ul>
                        <li>素朴な実装: O(V²) - Vは頂点の数</li>
                        <li>二分ヒープ（優先度キュー）を用いた実装: O((V+E)log V) - Eは辺の数</li>
                        <li>フィボナッチヒープを用いた実装: O(E + V log V)</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(V) - 距離の配列と訪問済みの頂点を記録するための空間</li>
            </ul>
            
            <p>グラフの密度によって、どの実装が最も効率的かが変わります。疎なグラフ（辺の数が頂点数の2乗より大幅に少ない場合）では優先度キューを用いた実装が効率的で、密なグラフ（辺の数が頂点数の2乗に近い場合）では単純な配列を使った実装が効率的な場合があります。</p>
            
            <p>実際のアプリケーションでは、ほとんどの場合、二分ヒープを用いた実装が良いバランスを提供し、広く使用されています。特に大規模なグラフでは、この実装によってアルゴリズムの実行時間が大幅に短縮されます。</p>
            
            <p>ダイクストラ法は理論的に保証された効率と正確さを兼ね備えているため、多くの実用的なシステムで広く採用されています。特に、非負の辺の重みを持つグラフにおいては、最適な最短経路アルゴリズムの一つとして認識されています。</p>
        </div>
    </div>
</body>
</html>