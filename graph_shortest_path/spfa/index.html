<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPFA (Shortest Path Faster)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">グラフの最短経路問題</a></li>
        <li>SPFA</li>
    </ul>

    <div class="container">
        <h1>SPFA (Shortest Path Faster)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>SPFAは、グラフにおける単一始点最短経路問題を解くためのアルゴリズムです。Bellman-Fordアルゴリズムを改良したもので、平均的にはより高速に動作します。負の重みを持つ辺が存在するグラフでも適用可能であり、負の閉路の検出も行うことができます。</p>
            
            <h3>基礎知識</h3>
            <p>SPFAは1994年に中国の段凡丁（Duan Fanding）によって提案されたアルゴリズムで、Bellman-Fordアルゴリズムのキュー最適化版とも言えます。Bellman-Fordアルゴリズムでは全ての辺を毎回調べますが、SPFAでは最短距離が更新された頂点から出る辺のみを調べることで、実行時間を短縮します。</p>
            <p>SPFAは基本的にキューを使用して実装され、距離が更新された頂点をキューに入れるという操作を繰り返します。これにより、変更の影響を受ける可能性のある頂点のみを処理するため、平均的には効率良く動作します。ただし、最悪の場合はBellman-Fordアルゴリズムと同じ計算量になります。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>単一始点最短経路（single-source shortest path）</strong>: 一つの始点から他の全ての頂点への最短経路を求める問題</li>
                <li><strong>緩和操作（relaxation）</strong>: ある頂点を経由して別の頂点への距離が短くなる場合に距離を更新する操作</li>
                <li><strong>距離配列（distance array）</strong>: 始点から各頂点までの現時点での最短距離を格納する配列</li>
                <li><strong>キュー（queue）</strong>: SPFAで使用されるデータ構造で、処理すべき頂点を管理する</li>
                <li><strong>負の閉路（negative cycle）</strong>: 合計重みが負になる閉路。存在すると最短経路が無限に短くなり得る</li>
                <li><strong>訪問フラグ（in-queue flag）</strong>: 頂点がキューに入っているかどうかを示すフラグ</li>
                <li><strong>再訪問回数（visit count）</strong>: 各頂点がキューに追加された回数を記録する値</li>
                <li><strong>隣接リスト（adjacency list）</strong>: グラフの表現方法の一つで、各頂点に隣接する頂点のリストを保持する</li>
            </ul>
            
            <h3>特徴</h3>
            <p>SPFAの主な特徴は以下の通りです：</p>
            <ul>
                <li>Bellman-Fordアルゴリズムの最適化版</li>
                <li>キューを使用して更新が必要な頂点のみを処理</li>
                <li>負の重みを持つ辺が存在するグラフでも正しく動作</li>
                <li>負の閉路を検出可能</li>
                <li>平均的にはDijkstraアルゴリズムより遅いが、負の辺がある場合に適用できる</li>
                <li>実装がシンプルで理解しやすい</li>
                <li>最悪の場合はO(VE)の時間計算量（Vは頂点数、Eは辺数）</li>
                <li>平均的なケースではO(E)に近い振る舞いを示すことが多い</li>
                <li>頂点の再訪問回数を制限することで無限ループを防止可能</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>SPFAは以下のような場面で特に有用です：</p>
            <ul>
                <li>負の重みを持つ辺が存在するグラフでの最短経路計算</li>
                <li>負の閉路の検出が必要な場合</li>
                <li>グラフの規模が中程度で、計算効率とシンプルな実装のバランスが求められる場合</li>
                <li>Dijkstraアルゴリズムが適用できない（負の辺が存在する）が、Bellman-Fordでは遅すぎる場合</li>
                <li>ネットワークルーティングなどの実際のアプリケーション</li>
                <li>競技プログラミングなどの問題解決（特に負の辺を含む問題）</li>
                <li>グラフが疎である（辺の数が頂点数の二乗より大幅に少ない）場合に効率的</li>
                <li>最短経路問題の教育的デモンストレーション</li>
                <li>様々なグラフアルゴリズムの基礎となる部分</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>SPFAの基本的な手順は以下の通りです：</p>
            
            <h4>1. 初期化</h4>
            <ol>
                <li>全ての頂点の距離を無限大（実装上は非常に大きな値）に設定する</li>
                <li>始点の距離を0に設定する</li>
                <li>キューを作成し、始点をキューに追加する</li>
                <li>各頂点がキューに入っているかどうかを示す訪問フラグの配列を作成し、始点の訪問フラグをtrueに設定する</li>
                <li>（オプション）各頂点のキューへの追加回数をカウントする配列を0で初期化する</li>
            </ol>
            
            <h4>2. 最短経路の計算</h4>
            <ol>
                <li>キューが空になるまで以下の処理を繰り返す：
                    <ul>
                        <li>キューから頂点uを取り出す</li>
                        <li>頂点uの訪問フラグをfalseに設定する</li>
                        <li>頂点uから出る全ての辺(u, v, weight)について以下を行う：
                            <ul>
                                <li>緩和操作: もし distance[u] + weight < distance[v] なら
                                    <ul>
                                        <li>distance[v] = distance[u] + weight に更新する</li>
                                        <li>頂点vがキューに入っていない場合（訪問フラグがfalse）：
                                            <ul>
                                                <li>頂点vをキューに追加する</li>
                                                <li>頂点vの訪問フラグをtrueに設定する</li>
                                                <li>（オプション）頂点vのキューへの追加回数をインクリメントする</li>
                                                <li>（オプション）頂点vのキューへの追加回数が頂点数以上になったら負の閉路が存在すると判断して処理を終了する</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ol>
            
            <h4>3. 結果の返却</h4>
            <ol>
                <li>全ての頂点に対する最短距離が計算されたら、distance配列を結果として返す</li>
                <li>（オプション）負の閉路が検出された場合は、その情報も返す</li>
            </ol>
            
            <h4>SPFAの改良: SLF (Small Label First)</h4>
            <p>キューの代わりにデックを使用し、新しく追加される頂点の距離が現在のキューの先頭の頂点の距離より小さい場合は、キューの先頭に追加する。そうでない場合は通常通りキューの末尾に追加する。これにより、処理の順序を最適化し、より早く収束させることができる。</p>
            
            <h4>SPFAの改良: LLL (Large Label Last)</h4>
            <p>キューから取り出した頂点の距離が、キュー内の頂点の平均距離よりも大きい場合、その頂点をキューの末尾に再度追加する。これにより、より小さな距離を持つ頂点を優先的に処理し、アルゴリズムの効率を向上させる。</p>
    
            <h3>計算量</h3>
            <p>SPFAアルゴリズムの計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>最良の場合</strong>: O(E) - 各辺が高々1回だけ考慮される場合（Eは辺数）</li>
                <li><strong>平均の場合</strong>: O(E) - 実際の多くのグラフでは線形時間に近い振る舞いを示す</li>
                <li><strong>最悪の場合</strong>: O(VE) - 頂点がキューに何度も追加される場合（Vは頂点数）</li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>O(V + E)</strong> - 距離配列、訪問フラグ配列、キュー、隣接リストの合計</li>
            </ul>
            
            <p>SPFAの時間計算量は最悪の場合O(VE)となり、これはBellman-Fordアルゴリズムと同じです。しかし、実際には多くのケースでO(E)に近い振る舞いを示すことが知られています。特に、グラフがランダムな構造を持つ場合や疎である場合に効率的です。</p>
            
            <p>ただし、特定のグラフ構造（例えば、意図的に構築された悪いケース）に対しては、キューへの再追加が頻繁に発生し、最悪ケースの計算量に近づくことがあります。このため、理論的な保証が必要な場合や、グラフの構造が不明な場合は、Dijkstra（負の辺がない場合）やBellman-Ford（理論的保証が必要な場合）などの代替アルゴリズムを検討することも重要です。</p>

            <p>負の閉路検出のためにキューへの追加回数をカウントする場合、各頂点がキューに追加される回数が頂点数（V）を超えると、グラフ内に負の閉路が存在すると判断できます。この検出機能は、SPFAがBellman-Fordアルゴリズムから継承している重要な特性です。</p>
            
            <p>SPFAの空間計算量はO(V + E)であり、主に距離配列、訪問フラグ配列、キュー、およびグラフの隣接リスト表現に起因します。これは多くの最短経路アルゴリズムと同様の空間要件です。</p>

            <p>まとめると、SPFAは負の辺を持つグラフでも使用できる柔軟性と、多くの実用的なケースでの効率性を兼ね備えたアルゴリズムですが、最悪ケースの性能保証は弱いという特徴があります。具体的な問題状況に応じて、他の最短経路アルゴリズムと比較検討することが重要です。</p>
        </div>
    </div>
</body>
</html>