<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>バイナリGCD (Binary GCD)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">最大公約数の問題</a></li>
        <li>バイナリGCD</li>
    </ul>

    <div class="container">
        <h1>バイナリGCD (Binary GCD)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>バイナリGCDアルゴリズム（ステインのアルゴリズムとも呼ばれる）は、二つの非負整数の最大公約数（GCD）を効率的に計算するためのアルゴリズムです。このアルゴリズムは除算を使用せず、シフト操作や減算などのより単純な操作のみを使用するため、特に除算が遅いシステムや大きな数値を扱う場合に有効です。</p>
            
            <h3>基礎知識</h3>
            <p>最大公約数（GCD）とは、二つ以上の整数の共通約数のうち最大のものです。例えば、12と18の最大公約数は6です。バイナリGCDアルゴリズムは、ユークリッドのアルゴリズムの代替手法として開発されました。</p>
            <p>このアルゴリズムは、コンピュータの二進数表現を活用し、除算操作を回避します。基本的なアイデアは、GCDに関する以下の数学的性質に基づいています：</p>
            <ul>
                <li>GCD(0, n) = n</li>
                <li>GCD(m, n) = GCD(n, m)</li>
                <li>m と n が共に偶数の場合、GCD(m, n) = 2 * GCD(m/2, n/2)</li>
                <li>m が偶数、n が奇数の場合、GCD(m, n) = GCD(m/2, n)</li>
                <li>m と n が共に奇数の場合、GCD(m, n) = GCD((m-n)/2, n) または GCD(m, (n-m)/2)</li>
            </ul>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>最大公約数（GCD: Greatest Common Divisor）</strong>: 二つ以上の整数の共通約数のうち最大のもの</li>
                <li><strong>ステインのアルゴリズム（Stein's Algorithm）</strong>: バイナリGCDアルゴリズムの別名</li>
                <li><strong>ビットシフト操作（bit shift operation）</strong>: 二進数表現において桁をずらす操作（右シフトは2で割ること、左シフトは2を掛けることに相当）</li>
                <li><strong>偶数（even number）</strong>: 2で割り切れる整数</li>
                <li><strong>奇数（odd number）</strong>: 2で割り切れない整数</li>
                <li><strong>互いに素（coprime / relatively prime）</strong>: 最大公約数が1である二つの整数</li>
                <li><strong>2進数表現（binary representation）</strong>: 数値を2を基数とする位取り記数法で表現する方法</li>
                <li><strong>ビット演算（bitwise operation）</strong>: 二進数のビット単位での論理演算</li>
                <li><strong>除算回避（division avoidance）</strong>: 計算コストの高い除算操作を使わずに結果を得る手法</li>
            </ul>
            
            <h3>特徴</h3>
            <p>バイナリGCDアルゴリズムの主な特徴は以下の通りです：</p>
            <ul>
                <li>除算操作を使用せず、シフト操作と減算のみを使用</li>
                <li>コンピュータのビット演算と相性が良い</li>
                <li>特に大きな数値や除算が遅いアーキテクチャで効率的</li>
                <li>ユークリッドのアルゴリズムより実装がやや複雑</li>
                <li>条件分岐が複数あるため、並列化が難しい場合がある</li>
                <li>再帰的または反復的に実装可能</li>
                <li>最悪の場合でもO(log^2 n)の計算量で動作</li>
                <li>多倍長整数の場合に特に有効</li>
                <li>モジュラー逆元の計算など、他の数論的アルゴリズムの基盤としても使用される</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>バイナリGCDアルゴリズムは以下のような場面で特に有用です：</p>
            <ul>
                <li>組み込みシステムなど、除算操作が高コストな環境</li>
                <li>暗号学のアプリケーションにおける大きな整数の最大公約数計算</li>
                <li>分数の約分（分子と分母の最大公約数を求める）</li>
                <li>有理数の演算</li>
                <li>RSA暗号など、公開鍵暗号方式のキー生成</li>
                <li>最小公倍数（LCM）の計算（GCDを使用して導出）</li>
                <li>連分数展開の計算</li>
                <li>多項式のGCD計算のアルゴリズムの基礎</li>
                <li>ハードウェア設計（HDLにおける効率的なGCD計算ユニット）</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>バイナリGCDアルゴリズムの基本的な手順は以下の通りです：</p>
            
            <h4>1. 前処理と特殊ケースの処理</h4>
            <ol>
                <li>入力として2つの非負整数 u と v を受け取る</li>
                <li>u = 0 の場合、GCD(0, v) = v を返す</li>
                <li>v = 0 の場合、GCD(u, 0) = u を返す</li>
                <li>u と v が同じ値の場合、GCD(u, v) = u を返す</li>
            </ol>
            
            <h4>2. 共通の因数2の抽出</h4>
            <ol>
                <li>共通の2の因数を数えるカウンタ k を 0 に初期化</li>
                <li>u と v の両方が偶数である間、以下を実行：
                    <ul>
                        <li>u を 2 で割る（ビット右シフト）</li>
                        <li>v を 2 で割る（ビット右シフト）</li>
                        <li>k を 1 増やす</li>
                    </ul>
                </li>
            </ol>
            
            <h4>3. 奇数への変換</h4>
            <ol>
                <li>u が偶数である間、u を 2 で割る（ビット右シフト）</li>
                <li>v が偶数である間、v を 2 で割る（ビット右シフト）</li>
                <li>この時点で、u と v はともに奇数</li>
            </ol>
            
            <h4>4. ユークリッド的ステップ</h4>
            <ol>
                <li>以下のループを v > 0 である間繰り返す：
                    <ul>
                        <li>v が偶数である間、v を 2 で割る（ビット右シフト）</li>
                        <li>u > v の場合：
                            <ul>
                                <li>u と v を交換する</li>
                            </ul>
                        </li>
                        <li>v = v - u を計算（この時点で v は偶数になる）</li>
                        <li>v = v / 2 を計算（ビット右シフト）</li>
                    </ul>
                </li>
            </ol>
            
            <h4>5. 結果の計算</h4>
            <ol>
                <li>最終的なGCDは u * 2^k</li>
                <li>つまり、u に 2 を k 回掛ける（ビット左シフト k 回）</li>
            </ol>
            
            <h4>アルゴリズムの流れ（例: GCD(48, 18)の計算）</h4>
            <ol>
                <li>48と18はともに正の数なので、特殊ケースではない</li>
                <li>両方とも2で割り切れるかを確認：
                    <ul>
                        <li>48 ÷ 2 = 24, 18 ÷ 2 = 9</li>
                        <li>k = 1（共通因数2を一つ抽出）</li>
                    </ul>
                </li>
                <li>24は偶数なので、奇数になるまで2で割る：
                    <ul>
                        <li>24 ÷ 2 = 12 ÷ 2 = 6 ÷ 2 = 3（奇数）</li>
                    </ul>
                </li>
                <li>9は奇数なので、そのまま</li>
                <li>ユークリッド的ステップ：
                    <ul>
                        <li>u = 3, v = 9</li>
                        <li>u < v なので交換しない</li>
                        <li>v = v - u = 9 - 3 = 6</li>
                        <li>v は偶数なので2で割る：v = 6 ÷ 2 = 3</li>
                        <li>u = 3, v = 3</li>
                        <li>u = v なので v = v - u = 0</li>
                        <li>v = 0 なのでループ終了</li>
                    </ul>
                </li>
                <li>結果の計算：
                    <ul>
                        <li>GCD = u * 2^k = 3 * 2^1 = 6</li>
                    </ul>
                </li>
            </ol>
    
            <h3>計算量</h3>
            <p>バイナリGCDアルゴリズムの計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>最良の場合</strong>: O(1) - 入力の一方が0または両方が等しい場合</li>
                <li><strong>平均の場合</strong>: O(log u * log v) - ビット操作の回数は入力のビット数に依存</li>
                <li><strong>最悪の場合</strong>: O(log^2 n) - nは入力の最大値で、各ステップでのビット操作がlog nに比例</li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>反復実装</strong>: O(1) - 固定数の変数のみを使用</li>
                <li><strong>再帰実装</strong>: O(log n) - 再帰の深さは入力のビット数に比例</li>
            </ul>
            
            <p>バイナリGCDアルゴリズムの時間計算量は、従来のユークリッドのアルゴリズム（O(log n)）と比較すると理論的には劣るように見えますが、実際の性能は実装環境によって大きく異なります。特に、除算操作がコストの高いアーキテクチャでは、バイナリGCDアルゴリズムが優れた性能を発揮することがあります。</p>
            
            <p>大きな整数を扱う場合、除算操作の計算コストは入力サイズに対して超線形に増加する傾向がありますが、バイナリGCDアルゴリズムで使用されるシフトと減算は比較的低コストです。そのため、暗号学的アプリケーションなど、非常に大きな整数を扱う場面では、バイナリGCDアルゴリズムが実用的な選択肢となります。</p>
            
            <p>また、バイナリGCDアルゴリズムは実装が比較的シンプルであり、除算命令が利用できない、または非常に遅い組み込みシステムなどでも効率的に動作します。一方で、現代のCPUは通常、効率的な除算ユニットを備えているため、一般的なアプリケーションでは従来のユークリッドのアルゴリズムとの性能差は小さくなる傾向があります。</p>
        </div>
    </div>
</body>
</html>