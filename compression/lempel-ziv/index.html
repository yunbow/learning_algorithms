<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>レンペル-ジブ法 (Lempel-Ziv)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">圧縮・解凍問題</a></li>
        <li>レンペル-ジブ法</li>
    </ul>

    <div class="container">
        <h1>レンペル-ジブ法 (Lempel-Ziv)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>レンペル-ジブ法は、1977年と1978年にアブラハム・レンペル（Abraham Lempel）とヤコブ・ジブ（Jacob Ziv）によって開発された可逆データ圧縮アルゴリズムです。このアルゴリズムは、データ内の繰り返しパターンを利用して効率的に情報を符号化することで、データサイズを削減します。後にテリー・ウェルチ（Terry Welch）らによって改良され、現在ではLZ77、LZ78、LZW、DEFLATE（LZ77の改良版）など、様々なバリエーションが存在します。</p>
            
            <h3>基礎知識</h3>
            <p>レンペル-ジブ法は、辞書ベースの圧縮アルゴリズムとして知られています。データ内の繰り返しパターンを識別し、それらを参照情報（オフセットと長さ、または辞書のインデックス）に置き換えることで圧縮を実現します。このアルゴリズムは、前方参照（既に処理したデータを参照する）を使用して冗長性を排除します。</p>
            <p>レンペル-ジブ法の主要な二つのアプローチであるLZ77とLZ78は、辞書の構築と参照方法に違いがあります。LZ77はスライディングウィンドウと呼ばれる固定サイズの過去のデータを参照する方法で、LZ78は明示的な辞書を動的に構築していく方法です。これらのアルゴリズムはテキスト、画像、プログラムファイルなど、様々な種類のデータ圧縮に広く利用されています。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>辞書（Dictionary）</strong>: データの圧縮と解凍に使用される参照情報の集合</li>
                <li><strong>スライディングウィンドウ（Sliding Window）</strong>: LZ77で使用される、過去のデータを参照するための固定サイズの領域</li>
                <li><strong>先読みバッファ（Look-ahead Buffer）</strong>: これから符号化するデータの領域</li>
                <li><strong>トークン（Token）</strong>: 圧縮データ内の基本単位で、通常は（オフセット、長さ、次の文字）または（辞書インデックス、次の文字）の形式</li>
                <li><strong>オフセット（Offset）</strong>: 過去のデータを参照する際の相対的な距離</li>
                <li><strong>長さ（Length）</strong>: 一致したデータの長さ</li>
                <li><strong>前方参照（Forward Reference）</strong>: すでに処理されたデータを参照する技術</li>
                <li><strong>エントリ（Entry）</strong>: 辞書に登録される文字列のパターン</li>
                <li><strong>可逆圧縮（Lossless Compression）</strong>: 圧縮と解凍の過程でデータが完全に復元される圧縮方式</li>
                <li><strong>圧縮率（Compression Ratio）</strong>: 元のデータサイズに対する圧縮後のデータサイズの比率</li>
                <li><strong>DEFLATE</strong>: LZ77とハフマン符号化を組み合わせた圧縮アルゴリズム（ZIP、GZIPなどで使用）</li>
                <li><strong>LZW（Lempel-Ziv-Welch）</strong>: LZ78を改良したアルゴリズムで、GIF画像やTIFFなどで使用される</li>
            </ul>
            
            <h3>特徴</h3>
            <p>レンペル-ジブ法の主な特徴は以下の通りです：</p>
            <ul>
                <li>可逆圧縮方式であり、データの損失なく完全に復元可能</li>
                <li>辞書ベースのアプローチにより、繰り返しパターンを効率的に符号化</li>
                <li>静的な辞書を必要とせず、データに応じて動的に辞書を構築</li>
                <li>符号化と復号化のプロセスが非対称（通常、解凍は圧縮よりも高速）</li>
                <li>一般的に実装が比較的シンプル</li>
                <li>テキストデータなど、繰り返しパターンを多く含むデータに対して高い圧縮効率</li>
                <li>ストリーミング処理に適しており、全データを一度に読み込む必要がない</li>
                <li>適応型アルゴリズムであり、データの統計的性質に事前知識を必要としない</li>
                <li>様々な応用分野に適応しやすく、多くの拡張やバリエーションが存在</li>
                <li>ハフマン符号化などの他の圧縮技術と組み合わせることで、さらに高い圧縮率の実現が可能</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>レンペル-ジブ法は以下のような場面で特に有用です：</p>
            <ul>
                <li>一般的なファイル圧縮（ZIP、GZIP、7z、RAR等）</li>
                <li>画像フォーマットの圧縮（GIF、PNG、TIFFなど）</li>
                <li>PDFファイルの圧縮</li>
                <li>ネットワーク通信でのデータ転送量削減（HTTPの圧縮、SSH通信など）</li>
                <li>データベースの圧縮ストレージ</li>
                <li>バックアップシステムでのストレージ効率化</li>
                <li>ソースコードやテキストファイルの圧縮</li>
                <li>組み込みシステムの限られたメモリ環境での効率的なデータ格納</li>
                <li>ディスクのデフラグやファイルシステムの最適化</li>
                <li>DNA配列やタンパク質配列などの生物学的データの圧縮</li>
                <li>ビデオストリーミングの一部のコーデック（圧縮技術の一部として）</li>
                <li>古いアーケードゲームや携帯機器向けゲームのデータ圧縮</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>レンペル-ジブ法には主に二つの主要なバリエーションがあります：LZ77とLZ78です。それぞれの具体的な手順を説明します。</p>
            
            <h4>1. LZ77（スライディングウィンドウベース）</h4>
            <ol>
                <li>圧縮処理：
                    <ul>
                        <li>入力データにスライディングウィンドウ（既に処理したデータ）と先読みバッファ（これから処理するデータ）を設定する</li>
                        <li>先読みバッファの先頭から、スライディングウィンドウ内で最長一致するパターンを探す</li>
                        <li>一致が見つかった場合：
                            <ul>
                                <li>その一致の情報を（オフセット、長さ、次の文字）というトリプルで符号化する</li>
                                <li>オフセット：スライディングウィンドウ内での位置（どれだけ前か）</li>
                                <li>長さ：一致した文字列の長さ</li>
                                <li>次の文字：一致の直後の文字</li>
                            </ul>
                        </li>
                        <li>一致が見つからない場合：
                            <ul>
                                <li>(0, 0, 次の文字)というトリプルを出力する</li>
                            </ul>
                        </li>
                        <li>ウィンドウを（長さ+1）文字分だけ前進させる</li>
                        <li>入力データが終わるまで上記の手順を繰り返す</li>
                    </ul>
                </li>
                <li>解凍処理：
                    <ul>
                        <li>受け取ったトリプル（オフセット、長さ、次の文字）をひとつずつ処理する</li>
                        <li>オフセットとは、すでに解凍したデータの末尾からの相対的な距離</li>
                        <li>長さ分の文字を、すでに解凍したデータから指定されたオフセット位置からコピーする</li>
                        <li>次の文字を追加する</li>
                        <li>すべてのトリプルを処理するまで繰り返す</li>
                    </ul>
                </li>
            </ol>
            
            <h4>例：LZ77での「abracadabra」の圧縮</h4>
            <ol>
                <li>最初は「a」→ (0,0,a) [一致なし、文字「a」]</li>
                <li>次に「b」→ (0,0,b) [一致なし、文字「b」]</li>
                <li>次に「r」→ (0,0,r) [一致なし、文字「r」]</li>
                <li>次に「a」→ (3,1,c) [3文字前に「a」がある、長さ1、次は「c」]</li>
                <li>次に「cada」→ (0,0,c), (0,0,a), (0,0,d), (0,0,a) [一致なし]</li>
                <li>次に「br」→ (7,2,a) [7文字前に「br」がある、長さ2、次は「a」]</li>
                <li>最後の「a」→ (9,1,EOFマーカー) [9文字前に「a」がある、長さ1]</li>
            </ol>

            <h4>2. LZ78（辞書ベース）</h4>
            <ol>
                <li>圧縮処理：
                    <ul>
                        <li>空の辞書から開始し、辞書のエントリには番号を付与する（通常は0から開始）</li>
                        <li>入力データを先頭から読み込み、辞書に存在する最長の接頭辞を見つける</li>
                        <li>見つかった接頭辞のインデックスとその直後の文字を（インデックス、次の文字）というペアで出力する</li>
                        <li>見つかった接頭辞に次の文字を加えた新しい文字列を辞書に追加する</li>
                        <li>入力データの残りから処理を続ける</li>
                        <li>データの終端に達するまで上記の手順を繰り返す</li>
                        <li>辞書が大きくなりすぎる場合は、リセットするか、古いエントリを削除するなどの対策を取る</li>
                    </ul>
                </li>
                <li>解凍処理：
                    <ul>
                        <li>圧縮時と同様の辞書を動的に構築しながら処理を行う</li>
                        <li>各（インデックス、次の文字）ペアを読み込む</li>
                        <li>インデックスから辞書エントリを取得し、それに次の文字を追加して出力する</li>
                        <li>同時に、この新しい文字列を辞書に追加する</li>
                        <li>すべてのペアを処理するまで繰り返す</li>
                    </ul>
                </li>
            </ol>
            
            <h4>例：LZ78での「abracadabra」の圧縮</h4>
            <ol>
                <li>辞書を空にする（辞書[0] = ""（空文字））</li>
                <li>「a」→ (0,a) [辞書に存在しないので、インデックス0と文字「a」]、辞書[1] = "a"</li>
                <li>「b」→ (0,b) [辞書に存在しないので、インデックス0と文字「b」]、辞書[2] = "b"</li>
                <li>「r」→ (0,r) [辞書に存在しないので、インデックス0と文字「r」]、辞書[3] = "r"</li>
                <li>「a」→ (1,c) [辞書[1]="a"、次は「c」]、辞書[4] = "ac"</li>
                <li>「a」→ (1,d) [辞書[1]="a"、次は「d」]、辞書[5] = "ad"</li>
                <li>「a」→ (1,b) [辞書[1]="a"、次は「b」]、辞書[6] = "ab"</li>
                <li>「r」→ (3,a) [辞書[3]="r"、次は「a」]、辞書[7] = "ra"</li>
                <li>最後に「a」→ (1,EOFマーカー) [辞書[1]="a"]</li>
            </ol>

            <h4>3. LZW（Lempel-Ziv-Welch、LZ78の改良版）</h4>
            <ol>
                <li>圧縮処理：
                    <ul>
                        <li>すべての可能な単一文字をあらかじめ辞書に登録する（ASCIIなら256エントリ）</li>
                        <li>現在の文字列Wを空に初期化する</li>
                        <li>入力から次の文字Kを読み取る</li>
                        <li>W+Kが辞書に存在するか確認する</li>
                        <li>存在する場合：W = W+K（現在の文字列を更新）</li>
                        <li>存在しない場合：
                            <ul>
                                <li>Wのインデックスを出力する</li>
                                <li>W+Kを辞書に新しいエントリとして追加する</li>
                                <li>W = K（現在の文字列をKにリセット）</li>
                            </ul>
                        </li>
                        <li>入力の終わりに達するまで手順3から繰り返す</li>
                        <li>最後に残ったWのインデックスを出力する</li>
                    </ul>
                </li>
                <li>解凍処理：
                    <ul>
                        <li>圧縮時と同じ初期辞書を用意する</li>
                        <li>最初のコードを読み取り、対応する文字列を出力する</li>
                        <li>前の文字列をOLDとする</li>
                        <li>次のコードを読み取る</li>
                        <li>そのコードが辞書に存在するか確認する</li>
                        <li>存在する場合：対応する文字列(S)を出力し、OLD+S[0]（Sの最初の文字）を辞書に追加する</li>
                        <li>存在しない場合：OLD+OLD[0]を計算し(S)、出力して、辞書に追加する</li>
                        <li>OLD = S（前の文字列を更新）</li>
                        <li>入力の終わりに達するまで手順4から繰り返す</li>
                    </ul>
                </li>
            </ol>
    
            <h3>計算量</h3>
            <p>レンペル-ジブ法のアルゴリズムの計算量は以下の通りです：</p>
            
            <h4>LZ77の計算量</h4>
            <ul>
                <li><strong>時間計算量</strong>:
                    <ul>
                        <li>圧縮: 素朴な実装ではO(n²)、ただし効率的なパターンマッチング（サフィックスツリーなど）を使用した場合はO(n)</li>
                        <li>解凍: O(n)（nは入力データの長さ）</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>:
                    <ul>
                        <li>圧縮・解凍共にO(W)（Wはウィンドウサイズ）</li>
                    </ul>
                </li>
            </ul>
            
            <h4>LZ78の計算量</h4>
            <ul>
                <li><strong>時間計算量</strong>:
                    <ul>
                        <li>圧縮: 平均的にはO(n)、最悪の場合はO(n×log n)（nは入力データの長さ）</li>
                        <li>解凍: O(n)</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>:
                    <ul>
                        <li>圧縮・解凍共にO(D)（Dは辞書サイズ、通常はn以下）</li>
                    </ul>
                </li>
            </ul>
            
            <h4>LZWの計算量</h4>
            <ul>
                <li><strong>時間計算量</strong>:
                    <ul>
                        <li>圧縮: 効率的な辞書実装（ハッシュテーブルなど）を使用した場合、平均O(n)</li>
                        <li>解凍: O(n)</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>:
                    <ul>
                        <li>圧縮・解凍共にO(D)（Dは辞書サイズ、通常は最大エントリ数で固定）</li>
                    </ul>
                </li>
            </ul>
            
            <p>レンペル-ジブ法（特にLZ77系）の実際の性能は、実装の詳細、パターンマッチングの効率性、入力データの特性に大きく依存します。例えば、多くの繰り返しパターンを含むテキストデータでは非常に高い圧縮率を達成できますが、ランダムデータや既に圧縮済みのデータに対しては効果が低いか、むしろサイズが増加する場合もあります。</p>
            
            <p>また、実際の応用では、レンペル-ジブ法は単独で使用されることは少なく、ハフマン符号化などのエントロピー符号化と組み合わせることで、より高い圧縮効率を実現することが一般的です。例えば、DEFLATEアルゴリズム（ZIP形式で使用）はLZ77とハフマン符号化を組み合わせたものです。</p>
            
            <p>現代の圧縮技術では、レンペル-ジブ法のコンセプトを発展させた様々なアルゴリズムが開発されており、特定の用途に最適化された実装が多数存在します。しかし、その基本原理はいずれも本稿で説明したレンペル-ジブ法に基づいています。</p>
        </div>
    </div>
</body>
</html>