<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ランレングス符号化 (Run-Length Encoding)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">圧縮・解凍問題</a></li>
        <li>ランレングス符号化</li>
    </ul>

    <div class="container">
        <h1>ランレングス符号化 (Run-Length Encoding)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>ランレングス符号化（Run-Length Encoding、RLE）は、データ圧縮のための最も単純なアルゴリズムの一つです。このアルゴリズムは、連続して繰り返される値を、その値と繰り返し回数のペアで置き換えることで圧縮を行います。特に、同じ値が連続して現れるデータに対して効果的な圧縮手法であり、実装が簡単で計算コストが低いという特徴があります。</p>
            
            <h3>基礎知識</h3>
            <p>ランレングス符号化は、データ内の冗長性を削減するための最も基本的な手法の一つです。このアルゴリズムは、連続する同じ値（ラン）を検出し、その値とその長さ（ランの長さ）のペアに置き換えます。例えば、「AAABBBCDDDD」というデータは「3A3B1C4D」と表現できます。つまり、3個の「A」、3個の「B」、1個の「C」、4個の「D」という意味です。</p>
            <p>この方法は特に、長い繰り返しがあるデータ（例えば、単色の領域が多い画像や、同じ文字が繰り返されるテキスト）に対して効果的です。しかし、ランダムなデータや頻繁に変化するデータでは、圧縮率が低下するどころか、かえってデータサイズが増加する可能性もあります。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ラン（Run）</strong>: データ内で連続して現れる同じ値の列</li>
                <li><strong>ランの長さ（Run Length）</strong>: 連続する同じ値の個数</li>
                <li><strong>符号化（Encoding）</strong>: 元のデータを圧縮形式に変換するプロセス</li>
                <li><strong>復号化（Decoding）</strong>: 圧縮されたデータを元の形式に戻すプロセス</li>
                <li><strong>圧縮率（Compression Ratio）</strong>: 元のデータサイズに対する圧縮後のデータサイズの比率</li>
                <li><strong>可逆圧縮（Lossless Compression）</strong>: 元のデータを完全に復元できる圧縮方式</li>
                <li><strong>連長圧縮（Run-Length Compression）</strong>: ランレングス符号化の別名</li>
                <li><strong>ランレングスペア（Run-Length Pair）</strong>: 値とその連続回数のペア（例：3A）</li>
                <li><strong>エスケープシーケンス（Escape Sequence）</strong>: 特定の制御情報を示すための特殊な記号や文字列</li>
                <li><strong>ランレングスリミット（Run-Length Limit）</strong>: 符号化する際の最大ラン長の制限</li>
            </ul>
            
            <h3>特徴</h3>
            <p>ランレングス符号化の主な特徴は以下の通りです：</p>
            <ul>
                <li>実装が非常に簡単で理解しやすい</li>
                <li>計算コストが低く、高速に処理できる</li>
                <li>可逆圧縮方式であり、元のデータを完全に復元できる</li>
                <li>連続した同じ値が多いデータに対して効果的</li>
                <li>ランダムなデータや変化の激しいデータでは非効率的</li>
                <li>最悪の場合、圧縮後のデータサイズが元のサイズより大きくなる可能性がある</li>
                <li>通常、バイナリデータよりもテキストや画像データに適している</li>
                <li>他の高度な圧縮アルゴリズムの前処理として使われることがある</li>
                <li>単独で使用される他、他の圧縮技術と組み合わせて使用されることもある</li>
                <li>復号化プロセスが非常に高速で単純</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>ランレングス符号化は以下のような場面で特に有用です：</p>
            <ul>
                <li>ファクシミリ（FAX）伝送での白黒画像の圧縮</li>
                <li>単色の領域が多いビットマップ画像（BMP）の圧縮</li>
                <li>PCXやTIFF形式などの画像ファイル形式</li>
                <li>単純なグラフィックや線画の保存</li>
                <li>アニメーションフレームの差分データの圧縮</li>
                <li>バイナリデータ内の長い連続した0や1の列の圧縮</li>
                <li>テレビ信号の水平走査線データの圧縮</li>
                <li>ゲームのスプライトや単純な背景画像の保存</li>
                <li>科学計算や測定データで、同じ値が連続する場合</li>
                <li>画像処理ソフトウェアでの一時的なデータ保存</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>ランレングス符号化の実装は、符号化（圧縮）と復号化（解凍）の2つのプロセスで構成されます：</p>
            
            <h4>1. 符号化（圧縮）プロセス</h4>
            <ol>
                <li>入力データの先頭から走査を開始する</li>
                <li>現在の文字（または値）を記録する</li>
                <li>同じ文字が連続する限り、カウンタを増加させる
                    <ul>
                        <li>初期カウント値は1</li>
                        <li>連続する同じ文字を見つけるたびにカウントを増加</li>
                    </ul>
                </li>
                <li>異なる文字が見つかったら：
                    <ul>
                        <li>現在のカウント値と文字のペアを出力する</li>
                        <li>新しい文字をカレント文字として記録する</li>
                        <li>カウンタを1にリセットする</li>
                    </ul>
                </li>
                <li>データの終端に達するまで、手順3と4を繰り返す</li>
                <li>最後に、最終的なカウント値と文字のペアを出力する</li>
            </ol>
            
            <h4>2. 復号化（解凍）プロセス</h4>
            <ol>
                <li>圧縮されたデータを先頭から順に読み込む</li>
                <li>カウント値（繰り返し回数）と文字のペアを読み取る</li>
                <li>読み取った文字をカウント値の回数だけ出力する</li>
                <li>圧縮データの終端に達するまで、手順2と3を繰り返す</li>
            </ol>
            
            <h4>例：テキストデータ「AAAABBBCCDEEEE」の圧縮</h4>
            <ol>
                <li>先頭から走査を開始し、「A」を記録する</li>
                <li>「A」が4回連続するため、カウンタは4になる</li>
                <li>「B」が現れたので、「4A」を出力し、現在の文字を「B」に変更、カウンタを1にリセット</li>
                <li>「B」が3回連続するため、カウンタは3になる</li>
                <li>「C」が現れたので、「3B」を出力し、現在の文字を「C」に変更、カウンタを1にリセット</li>
                <li>「C」が2回連続するため、カウンタは2になる</li>
                <li>「D」が現れたので、「2C」を出力し、現在の文字を「D」に変更、カウンタを1にリセット</li>
                <li>「D」は1回のみなので、「1D」を出力</li>
                <li>「E」が現れたので、現在の文字を「E」に変更、カウンタを1にリセット</li>
                <li>「E」が4回連続するため、カウンタは4になる</li>
                <li>データの終端なので、「4E」を出力</li>
                <li>最終的に、圧縮結果は「4A3B2C1D4E」となる</li>
            </ol>
            
            <h4>3. 実装上の考慮事項</h4>
            <ol>
                <li>カウント値の表現形式：
                    <ul>
                        <li>カウント値と文字をどのように区別するか（例：数字と文字の組み合わせ、特殊記号の使用など）</li>
                        <li>カウント値の最大値の制限（例：1バイトで表現する場合は最大255回）</li>
                        <li>カウント値が最大値を超える場合の処理方法（例：複数のランに分割）</li>
                    </ul>
                </li>
                <li>単一文字の処理：
                    <ul>
                        <li>ランの長さが1の場合、単に文字だけを出力する方が効率的な場合がある</li>
                        <li>カウント値「1」を省略するか否かの判断</li>
                    </ul>
                </li>
                <li>エスケープシーケンスの使用：
                    <ul>
                        <li>カウント値と文字を区別するための特殊記号の導入</li>
                        <li>エスケープ文字自体の処理方法</li>
                    </ul>
                </li>
                <li>バイナリデータの処理：
                    <ul>
                        <li>テキスト以外のバイナリデータに適用する場合の考慮事項</li>
                        <li>バイト値と繰り返し回数の効率的な表現方法</li>
                    </ul>
                </li>
                <li>効率化のための拡張：
                    <ul>
                        <li>繰り返しが少ない部分は圧縮せずにそのまま保存する方法</li>
                        <li>可変長カウント値の導入（短いランには短いカウント値を使用）</li>
                    </ul>
                </li>
            </ol>
    
            <h3>計算量</h3>
            <p>ランレングス符号化のアルゴリズムの計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>符号化（圧縮）プロセス</strong>: O(n)
                    <ul>
                        <li>n：入力データの長さ</li>
                        <li>データを1回だけ走査するため、線形時間</li>
                    </ul>
                </li>
                <li><strong>復号化（解凍）プロセス</strong>: O(n + m)
                    <ul>
                        <li>n：圧縮データの長さ</li>
                        <li>m：元のデータの長さ</li>
                        <li>ただし実際には、圧縮データを1回走査し、各ランを展開するだけなので実質O(m)</li>
                    </ul>
                </li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>符号化プロセス</strong>: O(1) または O(n)
                    <ul>
                        <li>インプレースで出力を生成する場合はO(1)の追加メモリ</li>
                        <li>新しい出力バッファを使用する場合はO(n)の追加メモリ</li>
                    </ul>
                </li>
                <li><strong>復号化プロセス</strong>: O(m)
                    <ul>
                        <li>復元されたデータを格納するためのメモリが必要</li>
                    </ul>
                </li>
            </ul>
            
            <h4>圧縮効率</h4>
            <ul>
                <li><strong>最良の場合</strong>: O(log n) のサイズに圧縮
                    <ul>
                        <li>例：「AAAAAAAAA...」（単一文字の繰り返し）は「nA」に圧縮可能</li>
                    </ul>
                </li>
                <li><strong>最悪の場合</strong>: 元のサイズの約2倍に膨張
                    <ul>
                        <li>例：「ABCDABCD...」（繰り返しのないデータ）は「1A1B1C1D1A1B1C1D...」となる</li>
                        <li>この問題を回避するため、多くの実装では短いランは圧縮しないなどの工夫がされている</li>
                    </ul>
                </li>
                <li><strong>平均的な場合</strong>: データの特性に大きく依存
                    <ul>
                        <li>連続性の高いデータほど効率良く圧縮される</li>
                        <li>ランダムなデータでは圧縮効率が低下する</li>
                    </ul>
                </li>
            </ul>
            
            <p>ランレングス符号化の最大の利点は、実装の単純さと処理速度の速さです。特に、FAX画像のような白黒の領域が多い画像では非常に効果的です。例えば、白黒のFAX画像では、長い白の領域（余白）と黒の領域（文字や線）が交互に現れることが多く、このような特性を持つデータに対してランレングス符号化は高い圧縮率を実現します。</p>
            
            <p>ただし、自然画像やテキストなどの変化が激しいデータでは、圧縮率が低下するだけでなく、最悪の場合はデータサイズが増加する可能性もあります。そのため、実際のアプリケーションでは、データの特性に合わせてランレングス符号化を使うか、より高度な圧縮アルゴリズム（ハフマン符号化、LZ77、LZ78など）を使うかを選択することが重要です。</p>
            
            <p>また、ランレングス符号化は、他の圧縮アルゴリズムと組み合わせて使用されることも多く、例えばJPEGフォーマットでは、DCTやハフマン符号化と組み合わせてランレングス符号化が使われています。このような組み合わせによって、より高い圧縮率を実現しています。</p>
        </div>
    </div>
</body>
</html>