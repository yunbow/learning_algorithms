<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LZW法 (Lempel-Ziv-Welch)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">圧縮・解凍問題</a></li>
        <li>LZW法</li>
    </ul>

    <div class="container">
        <h1>LZW法 (Lempel-Ziv-Welch)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>LZW法は、1984年にTerry Welchによって提案された可逆的なデータ圧縮アルゴリズムです。Abraham LempelとJacob Zivによる初期の辞書ベースの圧縮アルゴリズム（LZ77、LZ78）を改良したもので、特に文字列やテキストデータの効率的な圧縮に優れています。LZW法は、データ内の繰り返しパターンを動的に構築される辞書を用いて置き換えることで、効率的なデータ圧縮を実現します。</p>
            
            <h3>基礎知識</h3>
            <p>LZW法は辞書ベースの圧縮アルゴリズムであり、データを圧縮する過程で辞書（コードブック）を動的に構築します。最初の辞書には基本文字セット（例：ASCII文字）のみが含まれていますが、圧縮処理が進むにつれて、見つかった繰り返しパターンが辞書に追加されていきます。このアルゴリズムの特筆すべき点は、圧縮時に構築された辞書を明示的に保存する必要がなく、解凍時に同じ辞書を再構築できることです。</p>
            <p>LZW法はGIF画像フォーマット、PDF、TIFF、Unix の compress コマンドなど、多くの一般的なファイルフォーマットや圧縮ユーティリティで採用されてきました。特に繰り返しの多いデータに対して効果的であり、プログラムコードやテキストデータの圧縮に広く利用されてきました。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>辞書（Dictionary）</strong>: パターンとそれに対応するコードを格納するテーブル</li>
                <li><strong>コード（Code）</strong>: 辞書内のパターンを参照するための固定長の値</li>
                <li><strong>プレフィックス（Prefix）</strong>: すでに処理済みの文字列</li>
                <li><strong>文字（Character）</strong>: 入力データからの次の1文字</li>
                <li><strong>エントリ（Entry）</strong>: 辞書に登録されるパターンとそのコードのペア</li>
                <li><strong>初期辞書（Initial Dictionary）</strong>: アルゴリズム開始時に用意される基本文字セット</li>
                <li><strong>動的辞書構築（Dynamic Dictionary Building）</strong>: 圧縮/解凍プロセス中に辞書を更新する手法</li>
                <li><strong>辞書サイズ（Dictionary Size）</strong>: 辞書に格納できるエントリの最大数</li>
                <li><strong>コードワード（Codeword）</strong>: 出力される圧縮データの各単位</li>
                <li><strong>辞書リセット（Dictionary Reset）</strong>: 辞書が最大サイズに達した際に行われることがあるリセット操作</li>
                <li><strong>圧縮率（Compression Ratio）</strong>: 元のデータサイズに対する圧縮後のデータサイズの比率</li>
            </ul>
            
            <h3>特徴</h3>
            <p>LZW法の主な特徴は以下の通りです：</p>
            <ul>
                <li>辞書を動的に構築するため、データの特性に適応した圧縮が可能</li>
                <li>圧縮データに辞書を含める必要がなく、解凍時に同じ辞書を再構築できる</li>
                <li>固定長のコードを使用するため、圧縮データの処理が高速</li>
                <li>一度の走査で圧縮処理が完了する（複数パスを必要としない）</li>
                <li>繰り返しパターンの多いデータに対して高い圧縮率を実現</li>
                <li>オンラインアルゴリズムであり、ストリーミングデータの圧縮にも適用可能</li>
                <li>可逆圧縮であり、元のデータを完全に復元できる（ロスレス圧縮）</li>
                <li>辞書サイズの制限により、メモリ使用量をコントロールできる</li>
                <li>圧縮と解凍の処理が非対称（圧縮の方が計算コストが高い）</li>
                <li>特許の期限が切れており、現在は自由に実装・使用可能</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>LZW法は以下のような場面で特に有用です：</p>
            <ul>
                <li>テキストファイルやプログラムコードなど、繰り返しパターンの多いデータの圧縮</li>
                <li>GIF画像フォーマットでの画像データ圧縮</li>
                <li>PDFやTIFFなどのドキュメントフォーマットでのデータ圧縮</li>
                <li>データベースの列圧縮（特に文字列データ）</li>
                <li>ネットワーク通信での帯域幅節約（例：モデム通信）</li>
                <li>ストレージ容量が限られた環境でのデータ保存</li>
                <li>計算リソースが限られた環境での圧縮（解凍が軽量）</li>
                <li>高速な解凍処理が求められるアプリケーション</li>
                <li>バックアップシステムでのデータ圧縮</li>
                <li>アーカイブファイル形式（例：Unixのcompress）</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>LZW法は圧縮と解凍の2つのフェーズで構成されます：</p>
            
            <h4>1. 圧縮アルゴリズム</h4>
            <ol>
                <li>辞書の初期化：
                    <ul>
                        <li>入力データに現れる可能性のある全ての単一文字（例：ASCII文字0-255）を辞書に登録する</li>
                        <li>各文字に固有のコード値（例：0-255）を割り当てる</li>
                        <li>次に割り当てるコード値（例：256）を用意する</li>
                    </ul>
                </li>
                <li>圧縮処理：
                    <ul>
                        <li>現在の文字列W（最初は空）を初期化する</li>
                        <li>入力から次の文字Kを読み込む</li>
                        <li>W+K（Wの後にKを連結した文字列）が辞書に存在するか確認する：
                            <ul>
                                <li>存在する場合：W = W+K（現在の文字列を更新）</li>
                                <li>存在しない場合：
                                    <ul>
                                        <li>Wに対応するコードを出力する</li>
                                        <li>W+Kを新しいエントリとして辞書に追加し、次のコード値を割り当てる</li>
                                        <li>W = K（現在の文字列をKにリセット）</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>入力データの終わりに達するまで上記のステップを繰り返す</li>
                        <li>最後に残ったWに対応するコードを出力する</li>
                    </ul>
                </li>
                <li>辞書サイズ管理（オプション）：
                    <ul>
                        <li>辞書のサイズが最大値（例：4096エントリ）に達した場合：
                            <ul>
                                <li>辞書を初期状態にリセットする、または</li>
                                <li>これ以上エントリを追加しない、または</li>
                                <li>最も古いエントリを削除して新しいエントリ用のスペースを確保する</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ol>
            
            <h4>2. 解凍アルゴリズム</h4>
            <ol>
                <li>辞書の初期化：
                    <ul>
                        <li>圧縮時と同じ方法で、単一文字とそのコードで辞書を初期化する</li>
                        <li>次に割り当てるコード値を用意する</li>
                    </ul>
                </li>
                <li>解凍処理：
                    <ul>
                        <li>最初のコードを読み込み、対応する文字列（単一文字）を出力する</li>
                        <li>前のコードに対応する文字列を記録しておく（previous）</li>
                        <li>次のコードを読み込む（current）</li>
                        <li>currentが辞書に存在するか確認する：
                            <ul>
                                <li>存在する場合：対応する文字列を出力し、previousの文字列にcurrentの最初の文字を連結したものを辞書に追加する</li>
                                <li>存在しない場合（特殊なケース）：previousの文字列にpreviousの最初の文字を連結したものを出力し、それを辞書に追加する</li>
                            </ul>
                        </li>
                        <li>previous = current（次のイテレーションのために更新）</li>
                        <li>入力データの終わりに達するまで上記のステップを繰り返す</li>
                    </ul>
                </li>
                <li>辞書サイズ管理（オプション）：
                    <ul>
                        <li>圧縮時と同じ方針で辞書サイズを管理する</li>
                        <li>圧縮時に辞書リセットが行われた場合、解凍時も同じタイミングでリセットする必要がある</li>
                    </ul>
                </li>
            </ol>
            
            <h4>例：文字列 "ABABBABCABABBA" の圧縮</h4>
            <p>初期辞書には A=65, B=66, C=67 が含まれており、次のコードは 256 から始まるとします。</p>
            <ol>
                <li>W = 空, K = A → W+K = A（辞書に存在）→ W = A</li>
                <li>W = A, K = B → W+K = AB（辞書になし）→ 出力:65, 辞書に"AB"=256を追加, W = B</li>
                <li>W = B, K = A → W+K = BA（辞書になし）→ 出力:66, 辞書に"BA"=257を追加, W = A</li>
                <li>W = A, K = B → W+K = AB（辞書に存在）→ W = AB</li>
                <li>W = AB, K = B → W+K = ABB（辞書になし）→ 出力:256, 辞書に"ABB"=258を追加, W = B</li>
                <li>W = B, K = A → W+K = BA（辞書に存在）→ W = BA</li>
                <li>W = BA, K = B → W+K = BAB（辞書になし）→ 出力:257, 辞書に"BAB"=259を追加, W = B</li>
                <li>W = B, K = C → W+K = BC（辞書になし）→ 出力:66, 辞書に"BC"=260を追加, W = C</li>
                <li>W = C, K = A → W+K = CA（辞書になし）→ 出力:67, 辞書に"CA"=261を追加, W = A</li>
                <li>W = A, K = B → W+K = AB（辞書に存在）→ W = AB</li>
                <li>W = AB, K = A → W+K = ABA（辞書になし）→ 出力:256, 辞書に"ABA"=262を追加, W = A</li>
                <li>W = A, K = B → W+K = AB（辞書に存在）→ W = AB</li>
                <li>W = AB, K = B → W+K = ABB（辞書に存在）→ W = ABB</li>
                <li>W = ABB, K = A → W+K = ABBA（辞書になし）→ 出力:258, 辞書に"ABBA"=263を追加, W = A</li>
                <li>最後に残った W = A に対応するコードを出力: 65</li>
            </ol>
            <p>最終的な圧縮出力: 65, 66, 256, 257, 66, 67, 256, 258, 65</p>
            <p>元の14バイトのデータが9コードに圧縮されました（ただし、各コードは8ビットを超える可能性があるため、実際の圧縮率はコードのビット長に依存します）。</p>
    
            <h3>計算量</h3>
            <p>LZW法のアルゴリズムの計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>圧縮処理</strong>:
                    <ul>
                        <li>最悪の場合：O(n) - nは入力データの長さ</li>
                        <li>各文字は一度だけ処理される</li>
                        <li>辞書の検索と更新が定数時間で行える場合（ハッシュテーブルを使用）</li>
                    </ul>
                </li>
                <li><strong>解凍処理</strong>: O(n) - nは圧縮データのコード数</li>
                <li>辞書の実装によっては、検索時間が変わる可能性がある：
                    <ul>
                        <li>ハッシュテーブル：平均O(1)、最悪O(n)</li>
                        <li>トライ構造：O(L) - Lは文字列の最大長</li>
                    </ul>
                </li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>辞書のサイズ</strong>: O(2^b) - bはコードのビット長</li>
                <li>一般的な実装では12ビットコード（4096エントリ）が使用される</li>
                <li>各辞書エントリには文字列とコードを格納する必要がある</li>
                <li>最悪の場合、全ての可能な部分文字列が辞書に追加される</li>
                <li>実際には、辞書サイズに上限を設けることが多い</li>
                <li>解凍時には、辞書を効率的に表現するためのデータ構造が必要</li>
            </ul>
            
            <p>LZW法の効率性は入力データの特性に強く依存します。特に繰り返しパターンが多いデータ（テキスト、プログラムコード等）では高い圧縮率を達成できます。一方で、すでに圧縮されたデータ（JPEGなど）や完全にランダムなデータに対しては、圧縮の効果がなく、場合によっては元のデータより大きくなることもあります。</p>
            
            <p>また、辞書のサイズを制限することで、メモリ使用量を抑えることができますが、その代わりに圧縮率が低下する可能性があります。一般的な実装では、12ビットコード（4096エントリ）が使用されますが、より大きなコードワード（例：14ビット = 16384エントリ）を使用することで、より高い圧縮率を実現できることがあります。</p>
            
            <p>LZW法は実装が比較的シンプルで、圧縮と解凍のバランスが良いという特長があります。特に解凍処理が高速であるため、一度圧縮したデータを頻繁に参照するシナリオで効果的です。一方で、現代の圧縮アルゴリズム（例：DEFLATE, LZMA, Brotli）と比較すると圧縮率では劣ることが多いため、圧縮率が最重要視される場面では他のアルゴリズムが選択されることもあります。</p>
        </div>
    </div>
</body>
</html>