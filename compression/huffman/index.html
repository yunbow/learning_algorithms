<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ハフマン符号化 (Huffman Coding)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">圧縮・解凍問題</a></li>
        <li>ハフマン符号化</li>
    </ul>

    <div class="container">
        <h1>ハフマン符号化 (Huffman Coding)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>ハフマン符号化は、1952年にDavid A. Huffmanによって開発されたエントロピー符号化アルゴリズムです。このアルゴリズムは、各シンボル（文字など）の出現頻度に基づいて、可変長の接頭辞符号を割り当てることで、データの圧縮を実現します。頻度の高いシンボルには短いビット列を、頻度の低いシンボルには長いビット列を割り当てることで、全体の符号化サイズを最小化します。</p>
            
            <h3>基礎知識</h3>
            <p>ハフマン符号化は、情報理論の基本原理に基づいています。シャノン＝ファノ符号化の改良版とも言えるこのアルゴリズムは、最適な接頭辞符号を生成します。接頭辞符号とは、どのコードも他のコードの接頭辞とならないような符号体系で、これによりデコードの際に曖昧さが生じません。</p>
            <p>ハフマン符号化では、シンボルの出現頻度を用いて二分木（ハフマン木）を構築します。木の各葉ノードはシンボルを表し、根からその葉までのパス（左枝を0、右枝を1など）がそのシンボルの符号となります。頻度の高いシンボルほど木の浅い位置に配置されるため、短い符号が割り当てられます。</p>
            <p>このアルゴリズムは可逆圧縮の一種で、圧縮後のデータから元のデータを完全に復元することができます。多くのファイル圧縮形式（ZIP、JPEGなど）の一部として利用されており、テキスト、画像、音声など様々なデータ形式の圧縮に効果的です。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>エントロピー符号化</strong>: 情報のエントロピー（情報量）に基づいて、冗長性を取り除く符号化手法</li>
                <li><strong>接頭辞符号</strong>: どの符号も他の符号の接頭辞にならない符号体系</li>
                <li><strong>ハフマン木</strong>: ハフマン符号化で使用される特殊な二分木</li>
                <li><strong>ノード</strong>: ハフマン木を構成する要素で、シンボルと頻度情報を持つ</li>
                <li><strong>葉ノード</strong>: ハフマン木の末端に位置するノードで、元のシンボルを表す</li>
                <li><strong>内部ノード</strong>: 2つの子ノードを持つノードで、それらの頻度の和を表す</li>
                <li><strong>優先度キュー</strong>: ノードを頻度の昇順で管理するためのデータ構造</li>
                <li><strong>符号語</strong>: 各シンボルに割り当てられるビット列</li>
                <li><strong>符号表</strong>: シンボルと対応する符号語のマッピング</li>
                <li><strong>可変長符号</strong>: 異なる長さのビット列を使用する符号化方式</li>
                <li><strong>静的ハフマン符号化</strong>: データを2回走査し、1回目で頻度を計算、2回目で符号化を行う方式</li>
                <li><strong>適応型ハフマン符号化</strong>: データを1回だけ走査し、頻度と符号を動的に更新する方式</li>
            </ul>
            
            <h3>特徴</h3>
            <p>ハフマン符号化の主な特徴は以下の通りです：</p>
            <ul>
                <li>可変長符号を使用して、データサイズを効率的に削減する</li>
                <li>シンボルの出現頻度に基づいて最適な符号を生成する</li>
                <li>接頭辞符号を使用するため、デコードが一意に行える</li>
                <li>理論的に最適な符号化を実現する（個別のシンボルを符号化する場合）</li>
                <li>データの特性に応じて圧縮率が変動する（冗長性が高いほど圧縮率が高い）</li>
                <li>元のデータを完全に復元できる可逆圧縮である</li>
                <li>エンコードとデコードの両方が比較的高速に実行できる</li>
                <li>符号表（または木構造）をデータと共に保存する必要がある</li>
                <li>シンボル間の相関関係は考慮しない（単一シンボルの頻度のみを使用）</li>
                <li>適応型バージョンでは、データを一度だけ走査してリアルタイムに圧縮できる</li>
                <li>ビット単位の操作が必要なため、実装が少し複雑になる場合がある</li>
                <li>様々なデータ形式に適用可能で、汎用性が高い</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>ハフマン符号化は以下のような場面で特に有用です：</p>
            <ul>
                <li>テキストファイルの圧縮（特に頻度の偏りが大きい言語のテキスト）</li>
                <li>画像圧縮（JPEG、PNG等の一部として）</li>
                <li>音声・動画圧縮の前処理または一部として</li>
                <li>データ通信における帯域幅の削減</li>
                <li>ストレージ容量の効率的な使用</li>
                <li>アーカイブ形式（ZIP、ARJ、RAR等）の一部として</li>
                <li>FAXなどの通信規格での使用</li>
                <li>特定のパターンが繰り返し現れるデータの圧縮</li>
                <li>出現頻度に著しい偏りがあるシンボルセットの効率的な符号化</li>
                <li>リアルタイムデータ圧縮（適応型ハフマン符号化を使用）</li>
                <li>組み込みシステムにおける限られたリソースでのデータ圧縮</li>
                <li>他の圧縮アルゴリズムと併用した多段階圧縮処理</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>ハフマン符号化は、エンコード（圧縮）とデコード（解凍）の2つのフェーズで構成されます：</p>
            
            <h4>1. エンコード（圧縮）フェーズ</h4>
            <ol>
                <li>頻度計算：
                    <ul>
                        <li>入力データ内の各シンボル（文字など）の出現頻度をカウントする</li>
                        <li>各シンボルをノードとして表現し、その頻度を重みとして記録する</li>
                    </ul>
                </li>
                <li>ハフマン木の構築：
                    <ul>
                        <li>すべてのシンボルノードを優先度キュー（最小ヒープ）に挿入する</li>
                        <li>キューから最も低い頻度を持つ2つのノードを取り出す</li>
                        <li>これら2つのノードを子ノードとする新しい内部ノードを作成し、頻度は2つの子ノードの頻度の和とする</li>
                        <li>新しい内部ノードをキューに挿入する</li>
                        <li>キュー内のノードが1つになるまで、上記の手順を繰り返す</li>
                        <li>最後に残ったノードがハフマン木の根となる</li>
                    </ul>
                </li>
                <li>符号表の生成：
                    <ul>
                        <li>構築されたハフマン木を使用して、各シンボルの符号を決定する</li>
                        <li>根から各葉ノード（シンボル）へのパスをたどり、左枝を「0」、右枝を「1」として符号を生成する</li>
                        <li>各シンボルとその符号のマッピングを符号表として保存する</li>
                    </ul>
                </li>
                <li>データの符号化：
                    <ul>
                        <li>入力データの各シンボルを、符号表に基づいて対応する符号に置き換える</li>
                        <li>全ての符号を連結して圧縮されたビットストリームを生成する</li>
                        <li>復元のために必要な情報（符号表またはハフマン木の構造）を圧縮データに付加する</li>
                    </ul>
                </li>
            </ol>
            
            <h4>2. デコード（解凍）フェーズ</h4>
            <ol>
                <li>符号表またはハフマン木の復元：
                    <ul>
                        <li>圧縮データから符号表またはハフマン木の情報を読み取る</li>
                        <li>デコードに使用するハフマン木を再構築する</li>
                    </ul>
                </li>
                <li>データのデコード：
                    <ul>
                        <li>圧縮されたビットストリームを先頭から読み取る</li>
                        <li>ハフマン木の根から始め、「0」で左の子へ、「1」で右の子へ移動する</li>
                        <li>葉ノードに到達したら、対応するシンボルを出力し、根に戻る</li>
                        <li>ビットストリームの終わりに達するまで、このプロセスを繰り返す</li>
                    </ul>
                </li>
            </ol>
            
            <h4>例：文字列 "ABRACADABRA" の符号化</h4>
            <ol>
                <li>頻度計算：
                    <ul>
                        <li>A: 5回</li>
                        <li>B: 2回</li>
                        <li>R: 2回</li>
                        <li>C: 1回</li>
                        <li>D: 1回</li>
                    </ul>
                </li>
                <li>ハフマン木の構築：
                    <ul>
                        <li>最初の優先度キュー：[C:1, D:1, B:2, R:2, A:5]</li>
                        <li>C:1とD:1を結合 → 新ノードCD:2</li>
                        <li>優先度キュー：[CD:2, B:2, R:2, A:5]</li>
                        <li>CD:2とB:2を結合 → 新ノードCDB:4</li>
                        <li>優先度キュー：[R:2, CDB:4, A:5]</li>
                        <li>R:2とCDB:4を結合 → 新ノードRCDB:6</li>
                        <li>優先度キュー：[A:5, RCDB:6]</li>
                        <li>A:5とRCDB:6を結合 → 根ノード:11</li>
                    </ul>
                </li>
                <li>符号表の生成：
                    <ul>
                        <li>A: 0 （根の左側）</li>
                        <li>R: 10 （根の右側、その左側）</li>
                        <li>B: 110 （さらに右、左）</li>
                        <li>C: 1110 （さらに右、右、左）</li>
                        <li>D: 1111 （さらに右、右、右）</li>
                    </ul>
                </li>
                <li>データの符号化：
                    <ul>
                        <li>"ABRACADABRA" → 01101100111001101100</li>
                        <li>元のデータ：11文字×8ビット = 88ビット</li>
                        <li>圧縮後：20ビット（＋符号表の情報）</li>
                    </ul>
                </li>
            </ol>
    
            <h3>計算量</h3>
            <p>ハフマン符号化アルゴリズムの計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>頻度計算</strong>: O(n)
                    <ul>
                        <li>n：入力データの長さ</li>
                        <li>データを一度走査するだけで各シンボルの頻度をカウントできる</li>
                    </ul>
                </li>
                <li><strong>ハフマン木の構築</strong>: O(k log k)
                    <ul>
                        <li>k：一意なシンボルの数（アルファベットサイズ）</li>
                        <li>優先度キューの操作が log k の時間を要し、これを最大 k-1 回行う</li>
                    </ul>
                </li>
                <li><strong>符号表の生成</strong>: O(k)
                    <ul>
                        <li>木を深さ優先探索で走査して各シンボルの符号を生成</li>
                    </ul>
                </li>
                <li><strong>データの符号化</strong>: O(n)
                    <ul>
                        <li>各シンボルを対応する符号に置き換える（ハッシュテーブルを使用すれば定数時間）</li>
                    </ul>
                </li>
                <li><strong>データのデコード</strong>: O(n')
                    <ul>
                        <li>n'：圧縮されたデータの長さ（ビット数）</li>
                        <li>最悪の場合、各ビットごとに木を1ステップ進む</li>
                    </ul>
                </li>
                <li><strong>全体としての時間計算量</strong>: O(n + k log k)</li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>頻度テーブル</strong>: O(k)
                    <ul>
                        <li>各シンボルとその頻度を格納</li>
                    </ul>
                </li>
                <li><strong>ハフマン木</strong>: O(k)
                    <ul>
                        <li>k個の葉ノードと最大k-1個の内部ノードを持つ</li>
                    </ul>
                </li>
                <li><strong>符号表</strong>: O(k)
                    <ul>
                        <li>各シンボルとその符号のマッピングを格納</li>
                        <li>最悪の場合、符号の長さは O(k) になり得るが、平均的にはそれより短い</li>
                    </ul>
                </li>
                <li><strong>優先度キュー</strong>: O(k)
                    <ul>
                        <li>最大でもk個のノードを格納</li>
                    </ul>
                </li>
                <li><strong>圧縮データ</strong>: O(n') 
                    <ul>
                        <li>圧縮率によって変動するが、理想的には O(n') < O(n)</li>
                    </ul>
                </li>
                <li><strong>全体としての空間計算量</strong>: O(k + n')</li>
            </ul>
            
            <p>ハフマン符号化の効率は、データ内のシンボルの出現頻度の分布に大きく依存します。頻度の偏りが大きいほど、圧縮率は高くなります。例えば、少数のシンボルが高頻度で出現し、多数のシンボルが低頻度で出現するようなデータは、非常に効率的に圧縮されます。</p>
            
            <p>一方、すべてのシンボルがほぼ同じ頻度で出現する場合、圧縮効率は低下します。また、データサイズが小さい場合は、符号表や木構造の情報が相対的に大きくなり、圧縮の利点が薄れる可能性があります。</p>
            
            <p>ハフマン符号化は単一シンボルの頻度のみを考慮しており、シンボル間の相関関係は無視するため、より高度な圧縮アルゴリズム（辞書ベースのLZ77やLZ78など）と比較すると、特定のデータタイプでは圧縮率が劣ることがあります。しかし、その実装の単純さ、高速なエンコード/デコード、および理論的基盤の堅牢さから、依然として多くのアプリケーションで使用されています。</p>
        </div>
    </div>
</body>
</html>