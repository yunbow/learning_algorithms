<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>クイックソート (Quick Sort)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">配列の並べ替え問題</a></li>
        <li>クイックソート</li>
    </ul>
    <div class="container">
        <h1>クイックソート (Quick Sort)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>クイックソートは効率的な比較ソートアルゴリズムで、1960年代にイギリスのコンピュータ科学者トニー・ホーアによって開発されました。「分割統治法」の原理に基づき、平均的には他の多くのソートアルゴリズムよりも高速に動作するため、実用的なソート実装として広く採用されています。</p>
            
            <h3>基礎知識</h3>
            <p>ソートアルゴリズムとは、要素の集合を特定の順序（一般的には数値の昇順または降順、文字列のアルファベット順など）に並べ替えるためのアルゴリズムです。クイックソートは「分割統治法（Divide and Conquer）」と呼ばれる設計パラダイムを採用しています。</p>
            <p>分割統治法では、大きな問題を小さな部分問題に分割し、それぞれを解決してから結果を統合します。クイックソートの場合、配列をピボット（基準値）を中心に2つの部分配列に分割し、それぞれを再帰的にソートすることで全体をソートします。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ピボット（pivot）</strong>: 配列を分割するために選ばれる基準値</li>
                <li><strong>パーティション（partition）</strong>: ピボットを基準に配列を分割する処理</li>
                <li><strong>インプレースソート（in-place sort）</strong>: 追加のメモリをほとんど使わずに、元の配列上で直接ソートを行う方式</li>
                <li><strong>安定ソート（stable sort）</strong>: 同じ値を持つ要素の相対的な順序が保存されるソート</li>
                <li><strong>再帰（recursion）</strong>: アルゴリズムが自分自身を呼び出す技法</li>
                <li><strong>分割統治法（divide and conquer）</strong>: 問題を小さな部分問題に分割して解決する手法</li>
            </ul>
            
            <h3>特徴</h3>
            <p>クイックソートの主な特徴は以下の通りです：</p>
            <ul>
                <li>通常の実装では不安定ソート（同じ値の要素の順序が保持されない）</li>
                <li>インプレースで実装可能（追加のメモリ領域をほとんど必要としない）</li>
                <li>平均的な計算量は O(n log n) と優れている</li>
                <li>最悪の場合（既にソートされている配列など）の計算量は O(n²)</li>
                <li>再帰的なアプローチが一般的</li>
                <li>ピボット選択が性能に大きく影響する</li>
                <li>実際のコンピュータアーキテクチャ上で優れたキャッシュ効率を示す</li>
                <li>多くのプログラミング言語の標準ライブラリにおいてソート関数として採用されている</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>クイックソートは以下のような場面で特に有用です：</p>
            <ul>
                <li>大きな配列のソート（平均的に効率が良い）</li>
                <li>ランダムなデータの並べ替え</li>
                <li>メモリ使用量を最小限に抑えたいケース</li>
                <li>平均的なケースでの性能が重要な場合</li>
                <li>部分的にソートされたデータよりもランダムなデータに対して</li>
                <li>安定性が要求されないソート処理</li>
                <li>メモリアクセスの局所性が重要な環境</li>
                <li>実用的なシステムでの汎用ソートアルゴリズムとして</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>クイックソートの基本的な手順は以下の通りです：</p>
            <ol>
                <li>配列からピボット要素を選択する（一般的には配列の最初、最後、または中央の要素など）</li>
                <li>配列内の要素を「ピボットより小さい要素」と「ピボットより大きい要素」の2つのグループに分割する（パーティショニング）</li>
                <li>ピボットを2つのグループの間の正しい位置に配置する</li>
                <li>ピボットより小さい要素のグループに対して再帰的にクイックソートを適用する</li>
                <li>ピボットより大きい要素のグループに対して再帰的にクイックソートを適用する</li>
            </ol>
            
            <p>この再帰的なプロセスは、各部分配列のサイズが1以下になるまで続きます。</p>
            
            <h4>具体例: [7, 2, 1, 6, 8, 5, 3, 4]をソートする場合</h4>
            <ol>
                <li>最後の要素「4」をピボットとして選択します</li>
                <li>パーティショニング処理を行います：
                    <ul>
                        <li>ピボットより小さい要素: [2, 1, 3]</li>
                        <li>ピボットと等しい要素: [4]</li>
                        <li>ピボットより大きい要素: [7, 6, 8, 5]</li>
                    </ul>
                </li>
                <li>再配置後の配列: [2, 1, 3, 4, 7, 6, 8, 5]</li>
                <li>左側の部分配列 [2, 1, 3] に対して再帰的にクイックソートを適用します:
                    <ul>
                        <li>ピボット「3」を選択</li>
                        <li>パーティショニング: [2, 1] と []</li>
                        <li>再配置後: [2, 1, 3]</li>
                        <li>左側の [2, 1] に対してクイックソートを適用:
                            <ul>
                                <li>ピボット「1」を選択</li>
                                <li>パーティショニング: [] と [2]</li>
                                <li>再配置後: [1, 2]</li>
                            </ul>
                        </li>
                        <li>結果: [1, 2, 3]</li>
                    </ul>
                </li>
                <li>右側の部分配列 [7, 6, 8, 5] に対して再帰的にクイックソートを適用します:
                    <ul>
                        <li>ピボット「5」を選択</li>
                        <li>パーティショニング: [] と [7, 6, 8]</li>
                        <li>再配置後: [5, 7, 6, 8]</li>
                        <li>右側の [7, 6, 8] に対してクイックソートを適用:
                            <ul>
                                <li>ピボット「8」を選択</li>
                                <li>パーティショニング: [7, 6] と []</li>
                                <li>再配置後: [7, 6, 8]</li>
                                <li>[7, 6] に対してクイックソートを適用:
                                    <ul>
                                        <li>ピボット「6」を選択</li>
                                        <li>パーティショニング: [] と [7]</li>
                                        <li>再配置後: [6, 7]</li>
                                    </ul>
                                </li>
                                <li>結果: [6, 7, 8]</li>
                            </ul>
                        </li>
                        <li>結果: [5, 6, 7, 8]</li>
                    </ul>
                </li>
                <li>最終的なソート結果: [1, 2, 3, 4, 5, 6, 7, 8]</li>
            </ol>
            
            <h3>計算量</h3>
            <p>クイックソートの計算量は以下の特性を持ちます：</p>
            <ul>
                <li><strong>時間計算量</strong>:
                    <ul>
                        <li>最良の場合: O(n log n) - 各分割が常に均等な場合</li>
                        <li>平均的な場合: O(n log n) - ランダムなデータの場合</li>
                        <li>最悪の場合: O(n²) - すでにソートされた配列や全て同じ値の配列など、分割が極端に偏る場合</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>:
                    <ul>
                        <li>インプレース実装の場合: O(log n) - 再帰のスタックに必要な空間</li>
                        <li>最悪の場合: O(n) - 再帰が深くなるケース</li>
                    </ul>
                </li>
            </ul>
            
            <p>クイックソートの効率性は、ピボット選択によって大きく左右されます。最悪の場合（すでにソートされているデータに対して常に端の要素をピボットとして選択する場合など）には、O(n²)の計算量となりますが、ランダムなピボット選択や「三者中央値（Median of three）」と呼ばれる手法を使うことで、最悪のケースが発生する確率を大幅に低減できます。</p>
            
            <p>実際の実装では、小さなサブ配列に対してはクイックソートよりも挿入ソートなどのより単純なアルゴリズムを使用する「ハイブリッドアプローチ」が採用されることも多く、これによってさらに性能が向上します。</p>
            
            <p>クイックソートは比較ベースのソートアルゴリズムの理論的な下限である Ω(n log n) に平均的には達しており、多くの実用的なシナリオにおいて優れた選択となっています。</p>
        </div>
    </div>
</body>
</html>