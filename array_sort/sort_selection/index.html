<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>選択ソート</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <h1>選択ソート</h1>
    <div class="section">
        <h2>アルゴリズムの概要</h2>
        <p>選択ソートは配列内の要素を並べ替えるシンプルな比較ベースのソートアルゴリズムです。この手法は直感的で実装が容易なため、コンピュータサイエンスの入門教育でよく使用されます。アルゴリズムの基本的な考え方は、配列から最小（または最大）の要素を見つけて、それを適切な位置に配置するというプロセスを繰り返すことです。</p>
        
        <h3>基礎知識</h3>
        <p>ソートアルゴリズムとは、データの集合を特定の順序（通常は昇順または降順）に並べ替えるためのアルゴリズムです。選択ソートは「その場（in-place）」で行われるソートアルゴリズムであり、追加のメモリ空間をほとんど必要としません。</p>
        <p>選択ソートでは、配列を「ソート済み部分」と「未ソート部分」に論理的に分割し、未ソート部分から最小（または最大）の要素を選択して、ソート済み部分の末尾に追加していきます。このプロセスを繰り返すことで、最終的に配列全体がソートされます。</p>
        
        <h3>用語説明</h3>
        <ul>
            <li><strong>ソート済み部分（sorted portion）</strong>: すでに正しい順序で配置された部分配列</li>
            <li><strong>未ソート部分（unsorted portion）</strong>: まだソートされていない残りの部分配列</li>
            <li><strong>比較（comparison）</strong>: 2つの要素の大小関係を決定する操作</li>
            <li><strong>交換（swap）</strong>: 配列内の2つの要素の位置を入れ替える操作</li>
            <li><strong>安定性（stability）</strong>: 同じ値を持つ要素の相対的な順序が保存されるかどうかの性質</li>
            <li><strong>その場ソート（in-place sorting）</strong>: 追加の配列を使用せず、入力配列内でソートを完了するアルゴリズム</li>
        </ul>
        
        <h3>特徴</h3>
        <p>選択ソートの主な特徴は以下の通りです：</p>
        <ul>
            <li>シンプルで理解しやすい</li>
            <li>追加のメモリをほとんど必要としない（その場でソート）</li>
            <li>交換回数が少ない（最大でも配列の長さ分の交換のみ）</li>
            <li>比較回数は入力データの順序に関わらず常に一定</li>
            <li>小規模なデータセットでは効率的に動作する</li>
            <li>不安定ソート（同じ値を持つ要素の相対的な順序が保存されない場合がある）</li>
            <li>大規模なデータセットでは非効率的（二重ループを使用するため）</li>
            <li>アルゴリズムの実装がシンプルで直感的</li>
        </ul>
        
        <h3>適用ケース</h3>
        <p>選択ソートは以下のような場面で特に有用です：</p>
        <ul>
            <li>小規模な配列や短いリストのソート</li>
            <li>メモリ使用量が制限されている環境でのソート処理</li>
            <li>交換操作のコストが比較操作よりも高い状況（交換回数を最小化できるため）</li>
            <li>アルゴリズムの教育や学習の場面</li>
            <li>既にほぼソートされているデータへの適用（ただし挿入ソートの方が効率的）</li>
            <li>組み込みシステムなど、シンプルなコードが求められる環境</li>
            <li>他のソートアルゴリズムの一部として使用（例：ハイブリッドソートアルゴリズム）</li>
        </ul>
    </div>

    <div class="section">
        <h2>アルゴリズムの手順</h2>
        <h3>具体的な手順</h3>
        <p>選択ソートの基本的な手順は以下の通りです：</p>
        <ol>
            <li>配列全体を「ソート済み部分」（最初は空）と「未ソート部分」（最初は配列全体）に分ける</li>
            <li>未ソート部分から最小値（または最大値）を見つける</li>
            <li>見つけた最小値を未ソート部分の先頭の要素と交換する</li>
            <li>ソート済み部分の境界を1つ右に移動させる（ソート済み部分が1つ増える）</li>
            <li>配列全体がソートされるまで（未ソート部分がなくなるまで）、ステップ2〜4を繰り返す</li>
        </ol>
        
        <p>この手順を繰り返すことで、配列は徐々にソートされていきます。</p>
        
        <h4>具体例: [64, 25, 12, 22, 11]をソートする場合</h4>
        <ol>
            <li>最初の状態: [<u>64, 25, 12, 22, 11</u>]（下線は未ソート部分）</li>
            <li>未ソート部分から最小値11を見つけ、先頭の64と交換: [<strong>11</strong>, <u>25, 12, 22, 64</u>]</li>
            <li>未ソート部分から最小値12を見つけ、25と交換: [<strong>11, 12</strong>, <u>25, 22, 64</u>]</li>
            <li>未ソート部分から最小値22を見つけ、25と交換: [<strong>11, 12, 22</strong>, <u>25, 64</u>]</li>
            <li>未ソート部分から最小値25を見つけ、そのまま（すでに正しい位置にある）: [<strong>11, 12, 22, 25</strong>, <u>64</u>]</li>
            <li>残りは要素が1つだけなので、これでソート完了: [<strong>11, 12, 22, 25, 64</strong>]</li>
        </ol>
        
        <p>したがって、ソート結果は[11, 12, 22, 25, 64]となります。</p>
        
        <h3>計算量</h3>
        <p>選択ソートの計算量は以下の特性を持ちます：</p>
        <ul>
            <li><strong>時間計算量</strong>:
                <ul>
                    <li>最良の場合: O(n²) - すでにソート済みの配列でも全要素を比較する必要がある</li>
                    <li>平均的な場合: O(n²)</li>
                    <li>最悪の場合: O(n²)</li>
                </ul>
            </li>
            <li><strong>空間計算量</strong>: O(1) - 定数個の追加変数のみを使用（その場でソート）</li>
            <li><strong>比較回数</strong>: n(n-1)/2 = O(n²) - 入力データの順序に関わらず常に一定</li>
            <li><strong>交換回数</strong>: 最大でも O(n) - 各外部ループの反復ごとに最大1回の交換</li>
        </ul>
        
        <p>選択ソートは二重ループ構造を持つため、入力サイズ n に対して常に約 n²/2 回の比較が必要となります。このため、大規模なデータセットに対しては効率が悪く、ク