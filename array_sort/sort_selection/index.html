<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>選択ソート (Selection Sort)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">配列の並べ替え問題</a></li>
        <li>選択ソート</li>
    </ul>
    <div class="container">
        <h1>選択ソート (Selection Sort)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>選択ソートは、シンプルで直感的な比較ベースのソートアルゴリズムです。未ソート部分から最小（または最大）の要素を見つけて、ソート済み部分の末尾に配置する操作を繰り返すことで配列を整列します。アルゴリズムの単純さから、教育目的でよく使用されますが、大規模なデータセットではより効率的なソートアルゴリズムが好まれます。</p>
            
            <h3>基礎知識</h3>
            <p>選択ソートは配列を2つの部分に分けて考えます：既にソートされた部分と、まだソートされていない部分です。アルゴリズムは最初、配列全体がソートされていないと見なし、ソート済み部分は空です。各ステップで、未ソート部分から最小（昇順の場合）または最大（降順の場合）の要素を選択し、それを未ソート部分の先頭要素と交換します。この操作により、ソート済み部分が徐々に拡大していきます。</p>
            <p>選択ソートの主な特徴は、そのシンプルさと、データの入力状態に関係なく一定の時間計算量を持つことです。ただし、より効率的なアルゴリズムと比較すると、大きなデータセットでは性能が劣ります。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ソート済み部分（sorted portion）</strong>: 既に正しい順序で配置された要素の集合</li>
                <li><strong>未ソート部分（unsorted portion）</strong>: まだソートされていない要素の集合</li>
                <li><strong>比較（comparison）</strong>: 2つの要素の大小関係を評価する操作</li>
                <li><strong>交換（swap）</strong>: 配列内の2つの要素の位置を入れ替える操作</li>
                <li><strong>安定性（stability）</strong>: 等値要素の相対的な順序が保持されるかどうかの性質</li>
                <li><strong>インプレースソート（in-place sort）</strong>: 追加のメモリ領域をほとんど使わずに配列を並べ替えるソート方式</li>
                <li><strong>パス（pass）</strong>: 配列の未ソート部分を1回走査して最小（または最大）要素を見つける処理</li>
                <li><strong>最小値インデックス（minimum index）</strong>: 現在の未ソート部分内で最小値を持つ要素の位置</li>
            </ul>
            
            <h3>特徴</h3>
            <p>選択ソートの主な特徴は以下の通りです：</p>
            <ul>
                <li>シンプルで実装が容易</li>
                <li>インプレースソート（追加メモリがほとんど不要）</li>
                <li>データの入力状態に関わらず常に O(n²) の時間計算量</li>
                <li>交換回数が少ない（最大でも n-1 回）</li>
                <li>不安定ソート（等値要素の相対的順序が保証されない）</li>
                <li>アルゴリズムの各ステップで、ソート済み部分が確実に拡大する</li>
                <li>ソート進行の視覚化が容易で、教育目的に適している</li>
                <li>他のソートアルゴリズムと比較して実行速度が遅い（特に大規模データセット）</li>
                <li>わずかなメモリ使用量で実行可能</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>選択ソートは以下のような場面で特に有用です：</p>
            <ul>
                <li>小規模な配列やリストのソート</li>
                <li>メモリの制約が厳しい環境での実装</li>
                <li>データの書き込み操作のコストが高い状況（交換回数が少ないため）</li>
                <li>アルゴリズムの教育や説明の場面</li>
                <li>ソートアルゴリズムのデモンストレーションや可視化</li>
                <li>実装の単純さが重要視される場合</li>
                <li>配列が既にほぼソートされているかどうかに関係なく一定のパフォーマンスが必要な場合</li>
                <li>より複雑なソートアルゴリズムの一部として使用する場合（例：小さなサブ配列のソート）</li>
                <li>ハードウェアレベルの最適化が難しい環境での実装</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>選択ソートのアルゴリズムは以下の手順で実行されます：</p>
            
            <h4>1. 準備</h4>
            <ol>
                <li>配列全体を未ソート部分として考える</li>
                <li>ソート済み部分は最初は空</li>
            </ol>
            
            <h4>2. 反復処理</h4>
            <ol>
                <li>配列の先頭から始めて、以下の処理を配列の最後から2番目の要素まで繰り返す：
                    <ul>
                        <li>現在の位置を「ソート済み部分の末尾」として設定する</li>
                        <li>現在の位置から配列の最後までの未ソート部分から最小値（昇順の場合）または最大値（降順の場合）を見つける</li>
                        <li>見つけた最小値（または最大値）を持つ要素と「ソート済み部分の末尾」の要素を交換する（異なる場合のみ）</li>
                        <li>「ソート済み部分の末尾」を次の位置に移動させる（ソート済み部分を拡大する）</li>
                    </ul>
                </li>
            </ol>
            
            <h4>3. 具体的なステップ（昇順ソートの場合）</h4>
            <ol>
                <li>インデックス i = 0 から n-2 まで以下を繰り返す：
                    <ul>
                        <li>最小値のインデックス min_idx = i として初期化する</li>
                        <li>インデックス j = i+1 から n-1 まで以下を繰り返す：
                            <ul>
                                <li>配列[j] &lt; 配列[min_idx] の場合、min_idx = j に更新する</li>
                            </ul>
                        </li>
                        <li>min_idx が i と異なる場合、配列[i] と 配列[min_idx] を交換する</li>
                    </ul>
                </li>
            </ol>
            
            <h4>4. 終了条件</h4>
            <ol>
                <li>インデックス i が配列の最後から2番目の要素（n-2）に達すると、
                    <ul>
                        <li>最後の要素は自動的に正しい位置にあるため、アルゴリズムは終了する</li>
                    </ul>
                </li>
            </ol>
    
            <h3>計算量</h3>
            <p>選択ソートの計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>最良の場合</strong>: O(n²) - すでにソートされている配列でも、アルゴリズムは最小値を探すために全ての要素を走査する必要がある</li>
                <li><strong>平均の場合</strong>: O(n²) - どのような入力配列でも同じ比較回数が必要</li>
                <li><strong>最悪の場合</strong>: O(n²) - 逆順に並んでいる配列など、どのケースでも一定</li>
                <li><strong>比較回数</strong>: 常に n(n-1)/2 回の比較が必要</li>
                <li><strong>交換回数</strong>: 最大で (n-1) 回（各パスで最大1回）</li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>補助空間</strong>: O(1) - インプレースソートで、追加のメモリとして数個の変数のみ使用</li>
            </ul>
            
            <p>選択ソートの最大の欠点は、入力データのサイズが大きくなるほど性能が急激に低下することです。これは、どのような入力でも常に O(n²) の時間計算量を持つためです。例えば、配列の要素数が2倍になると、実行時間はおよそ4倍になります。</p>
            
            <p>一方、選択ソートの利点は交換回数が少ないことです。各パスで最大1回の交換しか行わないため、最大でも (n-1) 回の交換で済みます。これは、交換操作のコストが高い特定のシナリオで有利になる可能性があります。</p>
            
            <p>しかしながら、実用的な観点では、マージソート、クイックソート、ヒープソートなどの O(n log n) のアルゴリズムの方が大規模なデータセットでははるかに効率的です。選択ソートは主に、その単純さと実装の容易さから、教育目的や小規模なデータセットでの使用に限られています。</p>
        </div>
    </div>
</body>
</html>