<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>バブルソート (Bubble Sort)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">配列の並べ替え問題</a></li>
        <li>バブルソート</li>
    </ul>
    <div class="container">
        <h1>バブルソート (Bubble Sort)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>バブルソートは最も単純な並べ替えアルゴリズムの一つで、隣接する要素を比較して必要に応じて交換することを繰り返し行います。その動作が水中の泡が上昇する様子に似ていることから「バブルソート」と呼ばれています。シンプルさゆえに教育目的で広く使われていますが、大規模なデータセットに対しては非効率的です。</p>
            
            <h3>基礎知識</h3>
            <p>配列の並べ替え（ソート）とは、データ要素の集合を特定の順序（通常は昇順または降順）に並べ直す操作です。例えば、[5, 3, 8, 1, 2]という配列を昇順にソートすると[1, 2, 3, 5, 8]になります。</p>
            <p>バブルソートの基本的な考え方は、「隣接する要素を比較し、順序が正しくなければ交換する」というシンプルなものです。この操作を配列全体に対して繰り返し適用することで、徐々に大きな（または小さな）要素が正しい位置に「浮かび上がる」ように移動します。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>要素（element）</strong>: 配列内の個々のデータ項目</li>
                <li><strong>比較（comparison）</strong>: 2つの要素の大小関係を判定する操作</li>
                <li><strong>交換（swap）</strong>: 2つの要素の位置を入れ替える操作</li>
                <li><strong>パス（pass）</strong>: 配列の端から端までの一連の比較と交換の操作</li>
                <li><strong>安定ソート（stable sort）</strong>: 同じキー値を持つ要素の相対的な順序が保存されるソートアルゴリズム</li>
                <li><strong>その場ソート（in-place sort）</strong>: 追加のメモリ領域をほとんど使わずに実行できるソートアルゴリズム</li>
            </ul>
            
            <h3>特徴</h3>
            <p>バブルソートの主な特徴は以下の通りです：</p>
            <ul>
                <li>実装が非常に簡単で直感的に理解しやすい</li>
                <li>その場で行える（追加のメモリ領域をほとんど必要としない）</li>
                <li>安定ソートである（同じ値を持つ要素の相対的な順序が保存される）</li>
                <li>小さなデータセットでは十分に機能するが、大きなデータセットでは非効率的</li>
                <li>早期終了の最適化が可能（1回のパスで交換が発生しなければ、ソートが完了したと判断できる）</li>
                <li>アルゴリズムの動作が視覚的に理解しやすく、教育目的に適している</li>
                <li>各パスの終了後、少なくとも1つの要素が正しい最終位置に配置される</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>バブルソートは以下のような場面で使用されることがあります：</p>
            <ul>
                <li>教育環境でのアルゴリズム学習（シンプルさと視覚的な理解のしやすさ）</li>
                <li>要素数が非常に少ない配列のソート</li>
                <li>ほぼ整列済みの配列に対する最終的な微調整</li>
                <li>メモリ使用量が厳しく制限されている環境での使用</li>
                <li>実装の簡潔さが優先される場合</li>
                <li>安定ソートが必要な小規模なデータセット</li>
                <li>比較操作が交換操作よりも著しくコストが高い特殊なケース</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>バブルソートの基本的な手順は以下の通りです：</p>
            <ol>
                <li>配列の先頭から始めて、隣接する要素のペア（配列[j]と配列[j+1]）を比較する</li>
                <li>もし要素が正しい順序になっていなければ（例えば昇順ソートで配列[j] > 配列[j+1]の場合）、それらを交換する</li>
                <li>配列の最後まで到達するまでステップ1と2を繰り返す（これで1回のパスが完了する）</li>
                <li>このパスを配列の要素数-1回、または交換が発生しなくなるまで繰り返す</li>
            </ol>
            
            <p>各パスが終了するたびに、そのパスで最も「重い」（または「軽い」）要素が配列の正しい端に「浮かび上がる」ことになります。</p>
            
            <h4>具体例: [5, 3, 8, 1, 2]を昇順にソートする場合</h4>
            <ol>
                <li>最初のパス:
                    <ul>
                        <li>[5, 3, 8, 1, 2] → 5 > 3 なので交換 → [3, 5, 8, 1, 2]</li>
                        <li>[3, 5, 8, 1, 2] → 5 < 8 なので交換なし</li>
                        <li>[3, 5, 8, 1, 2] → 8 > 1 なので交換 → [3, 5, 1, 8, 2]</li>
                        <li>[3, 5, 1, 8, 2] → 8 > 2 なので交換 → [3, 5, 1, 2, 8]</li>
                    </ul>
                    最大値の8が最後尾に確定
                </li>
                <li>2回目のパス:
                    <ul>
                        <li>[3, 5, 1, 2, 8] → 3 < 5 なので交換なし</li>
                        <li>[3, 5, 1, 2, 8] → 5 > 1 なので交換 → [3, 1, 5, 2, 8]</li>
                        <li>[3, 1, 5, 2, 8] → 5 > 2 なので交換 → [3, 1, 2, 5, 8]</li>
                    </ul>
                    2番目に大きい値の5が正しい位置に確定
                </li>
                <li>3回目のパス:
                    <ul>
                        <li>[3, 1, 2, 5, 8] → 3 > 1 なので交換 → [1, 3, 2, 5, 8]</li>
                        <li>[1, 3, 2, 5, 8] → 3 > 2 なので交換 → [1, 2, 3, 5, 8]</li>
                    </ul>
                    3番目に大きい値の3が正しい位置に確定
                </li>
                <li>4回目のパス:
                    <ul>
                        <li>[1, 2, 3, 5, 8] → 1 < 2 なので交換なし</li>
                    </ul>
                    交換は発生せず、配列はソート済みと判断して終了
                </li>
            </ol>
            
            <p>したがって、最終的にソートされた配列は [1, 2, 3, 5, 8] となります。</p>
            
            <h3>計算量</h3>
            <p>バブルソートの計算量は以下の特性を持ちます：</p>
            <ul>
                <li><strong>時間計算量</strong>:
                    <ul>
                        <li>最悪の場合: O(n²) - 逆順に並んだ配列をソートする場合</li>
                        <li>平均的な場合: O(n²) - ランダムな配列をソートする場合</li>
                        <li>最良の場合: O(n) - すでにソート済みの配列で早期終了の最適化を使用する場合</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(1) - 追加の配列を必要とせず、交換用の一時変数のみ使用</li>
            </ul>
            
            <p>バブルソートが平均的に非効率な理由は、要素が最終的な位置に移動するために多数の交換操作が必要になる可能性があるためです。例えば、配列の最小要素が最後尾にある場合、それが先頭に移動するためには配列のほぼ全ての要素との交換が必要になります。</p>
            
            <p>このため、実用的なシナリオでは、クイックソート、マージソート、ヒープソートなどの効率的なアルゴリズム（平均計算量O(n log n)）が好まれます。しかし、バブルソートはその単純さと直感的な理解のしやすさから、アルゴリズム教育の初期段階では依然として重要な役割を果たしています。</p>
        </div>
    </div>
</body>
</html>