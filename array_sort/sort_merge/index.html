<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>マージソート</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">配列の並べ替え問題</a></li>
        <li>マージソート</li>
    </ul>
    <div class="container">
        <h1>マージソート</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>マージソートは分割統治法（divide and conquer）に基づいた安定的なソートアルゴリズムです。1945年にジョン・フォン・ノイマンによって設計され、効率性と安定性を兼ね備えた実用的なアルゴリズムとして広く使用されています。</p>
            
            <h3>基礎知識</h3>
            <p>配列の並べ替え（ソート）とは、与えられた配列の要素を特定の順序（通常は昇順または降順）に並べ替える操作です。例えば、[5, 2, 9, 1, 5, 6] を昇順にソートすると [1, 2, 5, 5, 6, 9] となります。</p>
            <p>マージソートの基礎となる原理は「分割統治法」で、大きな問題を小さな部分問題に分割し、それぞれを解いてから結果を統合するというものです。マージソートでは、配列を単一要素になるまで分割し、それらをマージ（結合）していくことで整列を行います。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>分割（Divide）</strong>: 配列を2つの部分配列に分割する操作</li>
                <li><strong>統治（Conquer）</strong>: 分割された部分配列を再帰的にソートする処理</li>
                <li><strong>結合（Merge）</strong>: ソートされた2つの部分配列を1つの整列された配列に統合する操作</li>
                <li><strong>安定ソート（Stable Sort）</strong>: 同じ値を持つ要素の相対的な順序が保存されるソートアルゴリズム</li>
                <li><strong>再帰（Recursion）</strong>: アルゴリズムが自分自身を呼び出す技法</li>
                <li><strong>in-placeソート</strong>: 追加のメモリ領域をほとんど使わずに元の配列を直接変更するソート</li>
                <li><strong>外部ソート（External Sort）</strong>: 主記憶装置に収まらない大きなデータセットを扱うためのソート技法</li>
            </ul>
            
            <h3>特徴</h3>
            <p>マージソートの主な特徴は以下の通りです：</p>
            <ul>
                <li>安定的なソートアルゴリズム（同じ値を持つ要素の元の順序が保持される）</li>
                <li>分割統治法を使用した再帰的なアプローチ</li>
                <li>最悪、最良、平均のいずれの場合でも O(n log n) の時間計算量</li>
                <li>追加のメモリ空間 O(n) を必要とする（標準的な実装では）</li>
                <li>大規模なデータセットに対して効率的に動作</li>
                <li>並列処理に適したアルゴリズム構造</li>
                <li>外部ソートの基盤として使用可能</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>マージソートは以下のような場面で特に有用です：</p>
            <ul>
                <li>安定ソートが必要な場合</li>
                <li>最悪の場合でも O(n log n) の性能が保証されたソートが必要な場合</li>
                <li>連結リストのソート（マージソートはランダムアクセスを必要としないため効率的）</li>
                <li>外部ソートが必要な場合（大規模データセットをディスクからメモリにロードしてソート）</li>
                <li>分散システムや並列処理環境でのソート</li>
                <li>予測可能な実行時間が重要な場合（例：リアルタイムシステム）</li>
                <li>ソートの安定性が要求される業務アプリケーション</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>マージソートの基本的な手順は以下の通りです：</p>
            <ol>
                <li><strong>分割（Divide）</strong>: 配列を（ほぼ）等しい大きさの2つの部分配列に分割する</li>
                <li><strong>統治（Conquer）</strong>: 部分配列を再帰的にマージソートする（部分配列のサイズが1になるまで）</li>
                <li><strong>結合（Merge）</strong>: ソートされた2つの部分配列をマージして1つの整列された配列を作成する</li>
            </ol>
            
            <p>マージ操作は以下のように行われます：</p>
            <ol>
                <li>2つの整列された部分配列がある状態から開始</li>
                <li>各部分配列の先頭要素を比較</li>
                <li>より小さい（または指定された順序による）方の要素を結果の配列に追加し、その要素を元の部分配列から「消費」する</li>
                <li>いずれかの部分配列が空になるまで、ステップ2-3を繰り返す</li>
                <li>残りの部分配列の要素をすべて結果の配列に追加</li>
            </ol>
            
            <h4>具体例: [38, 27, 43, 3, 9, 82, 10] をソートする場合</h4>
            <ol>
                <li><strong>分割</strong>: 配列を [38, 27, 43, 3] と [9, 82, 10] に分割</li>
                <li><strong>再帰的分割</strong>: 
                    <ul>
                        <li>[38, 27, 43, 3] → [38, 27] と [43, 3]</li>
                        <li>[38, 27] → [38] と [27]</li>
                        <li>[43, 3] → [43] と [3]</li>
                        <li>[9, 82, 10] → [9] と [82, 10]</li>
                        <li>[82, 10] → [82] と [10]</li>
                    </ul>
                </li>
                <li><strong>マージ</strong>: 単一要素の配列から順次マージしていく
                    <ul>
                        <li>[38] と [27] をマージ → [27, 38]</li>
                        <li>[43] と [3] をマージ → [3, 43]</li>
                        <li>[27, 38] と [3, 43] をマージ → [3, 27, 38, 43]</li>
                        <li>[9] と [10, 82] （[82] と [10] をマージ済み）をマージ → [9, 10, 82]</li>
                        <li>[3, 27, 38, 43] と [9, 10, 82] をマージ → [3, 9, 10, 27, 38, 43, 82]</li>
                    </ul>
                </li>
            </ol>
            
            <p>最終的に、完全にソートされた配列 [3, 9, 10, 27, 38, 43, 82] が得られます。</p>
            
            <h3>計算量</h3>
            <p>マージソートの計算量は以下の特性を持ちます：</p>
            <ul>
                <li><strong>時間計算量</strong>:
                    <ul>
                        <li>最良の場合: O(n log n)</li>
                        <li>平均的な場合: O(n log n)</li>
                        <li>最悪の場合: O(n log n)</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(n) - マージ操作で一時的な配列が必要</li>
            </ul>
            
            <p>マージソートの時間計算量が O(n log n) となる理由は、分割のステップが log n レベルの深さまで行われ（配列を半分ずつに分けるため）、各レベルでのマージ操作が O(n) の時間を要するためです。これは、マスター定理を用いて証明することができます。</p>
            
            <p>マージソートの主な欠点は追加のメモリ空間を必要とすることですが、この点を除けば、安定性と予測可能な性能から、多くの実際のアプリケーションやプログラミング言語の標準ライブラリで採用されています。例えば、Javaの Arrays.sort() はマージソートの変形を使用しています（オブジェクト配列のソート時）。</p>
            
            <p>また、マージソートは連結リストのソートに特に適しており、この場合は追加のメモリ空間が必要なく、ポインタの操作だけでマージが可能です。これにより、連結リスト向けのマージソートは空間効率が向上します。</p>
        </div>
    </div>
</body>
</html>