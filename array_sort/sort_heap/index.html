<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ヒープソート (Heap Sort)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">配列の並べ替え問題</a></li>
        <li>ヒープソート</li>
    </ul>
    <div class="container">
        <h1>ヒープソート (Heap Sort)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>ヒープソートは効率的な比較ベースのソートアルゴリズムで、1964年にJ.W.J.ウィリアムズによって開発され、その後ロバート・フロイドによって改良されました。このアルゴリズムはヒープデータ構造を利用して配列を並べ替える手法です。</p>
            
            <h3>基礎知識</h3>
            <p>ヒープソートはヒープデータ構造に基づいています。ヒープとは完全二分木の一種で、各ノードの値が子ノードの値より大きい（最大ヒープ）または小さい（最小ヒープ）という性質を持ちます。ソートには通常、最大ヒープが使用されます。</p>
            <p>ヒープソートの基本的な考え方は、まず入力配列からヒープを構築し、次にヒープから要素を1つずつ取り出して並べ替えられた配列を構築することです。このプロセスでは、ヒープの性質を維持するための操作（ヒープ化）が重要な役割を果たします。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ヒープ（Heap）</strong>: 親ノードが子ノードよりも大きい（または小さい）という性質を持つ完全二分木</li>
                <li><strong>最大ヒープ（Max Heap）</strong>: 各ノードの値が子ノードの値以上であるヒープ</li>
                <li><strong>最小ヒープ（Min Heap）</strong>: 各ノードの値が子ノードの値以下であるヒープ</li>
                <li><strong>ヒープ化（Heapify）</strong>: 配列をヒープ構造に変換する操作</li>
                <li><strong>完全二分木（Complete Binary Tree）</strong>: 最後のレベルを除くすべてのレベルが完全に埋まっており、最後のレベルは左から右へ詰められている二分木</li>
                <li><strong>ルートノード（Root Node）</strong>: ヒープの最上位ノード（最大値または最小値）</li>
                <li><strong>インプレースソート（In-place Sort）</strong>: 追加の配列を必要とせず、元の配列内でソートを行う方法</li>
            </ul>
            
            <h3>特徴</h3>
            <p>ヒープソートの主な特徴は以下の通りです：</p>
            <ul>
                <li>比較ベースのソートアルゴリズム</li>
                <li>インプレースでのソートが可能（追加の配列が不要）</li>
                <li>不安定ソート（同じ値を持つ要素の相対的な順序が保存されない）</li>
                <li>常に O(n log n) の時間計算量を保証（最悪・平均・最良ケースすべて）</li>
                <li>効率的なメモリ使用（空間計算量 O(1)）</li>
                <li>大規模データセットに適している</li>
                <li>部分ソート（k個の最大/最小要素を見つける）に効率的に応用可能</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>ヒープソートは以下のような場面で特に有用です：</p>
            <ul>
                <li>メモリ使用量が制限されている環境でのソート</li>
                <li>最悪ケースのパフォーマンスが重要な場面（常に O(n log n) を保証）</li>
                <li>大規模データセットのソート</li>
                <li>k個の最大値または最小値を効率的に見つける必要がある場合</li>
                <li>優先度キューの実装</li>
                <li>外部ソート（全データがメモリに収まらない場合のソート）のサブルーチンとして</li>
                <li>マージソートやクイックソートが効率的でない特定のデータ配列のパターン</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>ヒープソートは主に2つの段階に分かれています：</p>
            <ol>
                <li>配列からヒープを構築する（Build Max Heap）</li>
                <li>ヒープから要素を一つずつ取り出し、ソート済み配列を構築する（Extract elements from Heap）</li>
            </ol>
            
            <p>より詳細な手順は以下の通りです：</p>
            <ol>
                <li>入力配列をヒープに変換する（ヒープ化）
                    <ol>
                        <li>最後の非葉ノード（n/2-1、ここでnは配列の長さ）から開始</li>
                        <li>各ノードについて、そのノードを根とする部分木がヒープの性質を満たすように調整（ヒープ化）</li>
                        <li>インデックスを1つ減らし、すべての非葉ノードに対してこのプロセスを繰り返す</li>
                    </ol>
                </li>
                <li>ヒープからソート済み配列を構築する
                    <ol>
                        <li>ヒープの先頭要素（最大値）を取り出し、配列の末尾と交換</li>
                        <li>配列サイズを1減らす（最後の要素はソート済みと見なす）</li>
                        <li>新しい先頭要素を適切な位置に下げて（sift-down）、ヒープの性質を回復</li>
                        <li>ヒープサイズが1になるまでこのプロセスを繰り返す</li>
                    </ol>
                </li>
            </ol>
            
            <h4>具体例: [12, 11, 13, 5, 6, 7] をソートする場合</h4>
            <ol>
                <li>まず、この配列をヒープに変換します：
                    <ol>
                        <li>最後の非葉ノードのインデックス: (6/2)-1 = 2（値は13）</li>
                        <li>13とその子ノード（5, 6）を比較：13が最大なので変更なし</li>
                        <li>次のノード11とその子ノード（5, 7）を比較：11と7を比較、変更なし</li>
                        <li>最後に12とその子ノード（11, 13）を比較：13が最大なので12と13を交換</li>
                        <li>結果的に[13, 11, 12, 5, 6, 7]というヒープが構築される</li>
                    </ol>
                </li>
                <li>次に、ヒープから要素を取り出してソートします：
                    <ol>
                        <li>ヒープの先頭(13)と末尾(7)を交換: [7, 11, 12, 5, 6, 13]</li>
                        <li>最後の要素(13)はソート済みと見なし、ヒープサイズを5に減らす</li>
                        <li>新しい先頭(7)をヒープ化: [12, 11, 7, 5, 6]→[12, 11, 7, 5, 6, 13]</li>
                        <li>先頭(12)と末尾(6)を交換: [6, 11, 7, 5, 12, 13]</li>
                        <li>ヒープサイズを4に減らし、新しい先頭(6)をヒープ化: [11, 6, 7, 5]→[11, 6, 7, 5, 12, 13]</li>
                        <li>先頭(11)と末尾(5)を交換: [5, 6, 7, 11, 12, 13]</li>
                        <li>ヒープサイズを3に減らし、新しい先頭(5)をヒープ化: [7, 6, 5]→[7, 6, 5, 11, 12, 13]</li>
                        <li>先頭(7)と末尾(5)を交換: [5, 6, 7, 11, 12, 13]</li>
                        <li>ヒープサイズを2に減らし、新しい先頭(5)をヒープ化: [6, 5]→[6, 5, 7, 11, 12, 13]</li>
                        <li>先頭(6)と末尾(5)を交換: [5, 6, 7, 11, 12, 13]</li>
                        <li>これで配列は完全にソートされました</li>
                    </ol>
                </li>
            </ol>
            
            <p>したがって、最終的なソート結果は [5, 6, 7, 11, 12, 13] となります。</p>
            
            <h3>計算量</h3>
            <p>ヒープソートの計算量は以下の特性を持ちます：</p>
            <ul>
                <li><strong>時間計算量</strong>: 
                    <ul>
                        <li>最良の場合: O(n log n)</li>
                        <li>平均の場合: O(n log n)</li>
                        <li>最悪の場合: O(n log n)</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(1) - インプレースソートのため追加の配列を必要としない</li>
            </ul>
            
            <p>ヒープソートの時間計算量の内訳は以下の通りです：</p>
            <ul>
                <li>初期ヒープの構築: O(n)</li>
                <li>ヒープから要素を取り出す操作: O(log n) を n-1 回繰り返すため O(n log n)</li>
            </ul>
            
            <p>初期ヒープの構築が O(n) 時間で済むのは、下から上への効率的なヒープ化アプローチを使用するためです。各ヒープ化操作は O(log n) 時間かかりますが、ほとんどのノードが葉に近いため、平均すると定数時間になります。</p>
            
            <p>ヒープソートは最悪のケースでも O(n log n) を保証するという点でクイックソート（最悪ケース O(n²)）より優れていますが、実際の実装では定数係数が大きいため、多くの場合クイックソートの方が高速です。また安定ソートではないという特性から、データの順序が重要な場合はマージソートなどの安定ソートが好まれることがあります。</p>
        </div>
    </div>
</body>
</html>