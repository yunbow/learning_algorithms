<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>挿入ソート (Insertion Sort)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">配列の並べ替え問題</a></li>
        <li>挿入ソート</li>
    </ul>
    <div class="container">
        <h1>挿入ソート (Insertion Sort)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>挿入ソートは、配列の並べ替えを行うための単純かつ直感的なアルゴリズムで、日常生活でもよく使われる方法です。トランプのカードを手に持って並べ替える際の一般的な方法に例えられることが多く、小さな配列や部分的に整列された配列に対して特に効率的です。</p>
            
            <h3>基礎知識</h3>
            <p>挿入ソートは「配列を先頭から順に走査し、各要素を既にソートされた部分の適切な位置に挿入していく」という考え方に基づいています。最初の要素は既にソートされているとみなし、2番目の要素から処理を開始します。</p>
            <p>このアルゴリズムは安定ソートであり、同じ値を持つ要素の相対的な順序が保存されます。また、「オンラインアルゴリズム」としても知られ、データが全て揃う前でも部分的なソートが可能です。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>キー（key）</strong>: 現在挿入しようとしている要素の値</li>
                <li><strong>ソート済み部分（sorted portion）</strong>: 配列の先頭から現在処理中の位置までの、既に整列された部分</li>
                <li><strong>未ソート部分（unsorted portion）</strong>: まだ処理されていない配列の残りの部分</li>
                <li><strong>シフト（shift）</strong>: 挿入位置を作るために要素を右側にずらす操作</li>
                <li><strong>安定ソート（stable sort）</strong>: 同じ値を持つ要素の相対的な順序が保存されるソートアルゴリズム</li>
                <li><strong>オンラインアルゴリズム（online algorithm）</strong>: 入力データが全て揃わなくても逐次的に処理できるアルゴリズム</li>
            </ul>
            
            <h3>特徴</h3>
            <p>挿入ソートの主な特徴は以下の通りです：</p>
            <ul>
                <li>実装が単純で直感的に理解しやすい</li>
                <li>少ない要素数の配列に対して効率的</li>
                <li>既にほぼソートされている配列に対しては非常に高速</li>
                <li>安定ソートである（同じ値の要素の相対的な順序が保存される）</li>
                <li>オンラインアルゴリズムとして使用可能（データを一度に全て読み込む必要がない）</li>
                <li>追加のメモリをほとんど必要としない（インプレースアルゴリズム）</li>
                <li>アダプティブである（入力データの順序に応じて効率が変わる）</li>
                <li>他のより複雑なソートアルゴリズム（クイックソートやマージソートなど）の内部で小さな部分配列のソートに使用される</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>挿入ソートは以下のような場面で特に有用です：</p>
            <ul>
                <li>要素数が少ない配列のソート（通常10〜20要素以下）</li>
                <li>ほぼソート済みの配列の整列</li>
                <li>連続してデータが到着する状況でのリアルタイムソート</li>
                <li>より複雑なソートアルゴリズムの一部として、小さなサブ配列をソートする場合</li>
                <li>メモリ容量が制限されている環境</li>
                <li>アルゴリズムの教育や学習の初期段階</li>
                <li>組み込みシステムなど、シンプルさが重要な環境</li>
                <li>他のソートアルゴリズムのフォールバック（予備）メカニズムとして</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>挿入ソートの基本的な手順は以下の通りです：</p>
            <ol>
                <li>配列の2番目の要素から開始する（最初の要素は既にソート済みとみなす）</li>
                <li>現在の要素（キー）を取り出し、一時的に保存する</li>
                <li>キーの前にある全ての要素を後ろから順に調べていき、キーよりも大きい要素は1つ右にシフトする</li>
                <li>適切な位置（それ以上シフトする必要がない位置）が見つかったら、その位置にキーを挿入する</li>
                <li>配列の末尾に到達するまで、ステップ2〜4を繰り返す</li>
            </ol>
            
            <p>この過程により、配列の先頭から順に整列された部分が拡大していき、最終的に全体がソートされます。</p>
            
            <h4>具体例: [5, 2, 4, 6, 1, 3]をソートする場合</h4>
            <ol>
                <li>最初の要素[5]は既にソート済みとみなす: [5 | 2, 4, 6, 1, 3]（縦線の左側がソート済み部分）</li>
                <li>キー = 2を取り出し、5と比較。2 < 5なので5を右にシフトし、2を挿入: [2, 5 | 4, 6, 1, 3]</li>
                <li>キー = 4を取り出し、前の要素と比較。4 < 5なので5を右にシフト、4 > 2なのでその位置に挿入: [2, 4, 5 | 6, 1, 3]</li>
                <li>キー = 6を取り出し、前の要素と比較。6 > 5なのでそのまま配置: [2, 4, 5, 6 | 1, 3]</li>
                <li>キー = 1を取り出し、前の要素と比較。1 < 6, 1 < 5, 1 < 4, 1 < 2なので全て右にシフトし、1を先頭に挿入: [1, 2, 4, 5, 6 | 3]</li>
                <li>キー = 3を取り出し、前の要素と比較。3 < 6, 3 < 5, 3 < 4, 3 > 2, 3 > 1なので、2と4の間に挿入: [1, 2, 3, 4, 5, 6]</li>
            </ol>
            
            <p>これにより、元の配列[5, 2, 4, 6, 1, 3]が[1, 2, 3, 4, 5, 6]に整列されました。</p>
            
            <h3>計算量</h3>
            <p>挿入ソートの計算量は以下の特性を持ちます：</p>
            <ul>
                <li><strong>時間計算量</strong>: 
                    <ul>
                        <li>最良の場合: O(n) - 既にソートされている配列の場合</li>
                        <li>平均の場合: O(n²) - ランダムな順序の配列の場合</li>
                        <li>最悪の場合: O(n²) - 逆順に並んでいる配列の場合</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(1) - 追加のメモリ使用が定数サイズ（一時変数のみ）</li>
            </ul>
            
            <p>挿入ソートが二次の時間計算量になる理由は、各要素を挿入する際に、最悪の場合は既にソートされた部分の全ての要素をシフトする必要があるためです。内側のループは最大でもi回（現在の位置）実行され、外側のループはn-1回実行されるため、総操作数は最悪の場合O(n²)となります。</p>
            
            <p>ただし、ほぼソート済みの配列に対しては、内側のループの実行回数が大幅に減少するため、線形に近い性能を示します。この「アダプティブ」な特性が、挿入ソートが特定の状況で選ばれる理由の一つです。</p>
            
            <p>挿入ソートは比較回数が多くなりますが、データの移動回数は他のアルゴリズムと比べて効率的である場合が多く、要素の移動コストが高い場合には有利になることがあります。</p>
        </div>
    </div>
</body>
</html>