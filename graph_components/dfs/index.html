<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深さ優先探索 (DFS)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">グラフの連結成分問題</a></li>
        <li>深さ優先探索</li>
    </ul>
    <div class="container">
        <h1>深さ優先探索 (DFS)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>深さ優先探索（Depth-First Search, DFS）は、グラフやツリーを探索するための基本的なアルゴリズムです。グラフの連結成分とは、内部の任意の2頂点間に経路が存在する頂点の最大部分集合を指します。DFSを使用することで、グラフ内の別々の連結成分を効率的に特定し、ラベル付けすることができます。</p>
            
            <h3>基礎知識</h3>
            <p>深さ優先探索は、探索の開始頂点から可能な限り「深く」進み、それ以上進めなくなったら「バックトラック」して別の経路を探る方法です。スタックデータ構造（または再帰呼び出し）を使用して実装されることが多く、訪問した頂点を記録して再訪問を防ぎます。</p>
            <p>グラフの連結成分を見つける場合、DFSは1つの頂点から開始して到達可能なすべての頂点を訪問します。これにより1つの連結成分全体が探索されます。まだ訪問していない頂点があれば、その頂点から新たにDFSを開始することで、異なる連結成分を特定します。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>連結成分（Connected Component）</strong>: 内部の任意の2頂点間に経路が存在する頂点と辺の部分集合</li>
                <li><strong>訪問済みマーク（Visited Mark）</strong>: 頂点が探索済みかどうかを示すフラグ</li>
                <li><strong>バックトラッキング（Backtracking）</strong>: それ以上進めなくなった時に、以前の分岐点に戻って別の経路を探索すること</li>
                <li><strong>再帰（Recursion）</strong>: 関数が自分自身を呼び出す手法（DFSの実装でよく使われる）</li>
                <li><strong>スタック（Stack）</strong>: 後入れ先出し（LIFO）のデータ構造（DFSの非再帰実装で使用）</li>
                <li><strong>隣接リスト（Adjacency List）</strong>: 各頂点に隣接する頂点のリストを保持するグラフ表現</li>
                <li><strong>隣接行列（Adjacency Matrix）</strong>: 頂点間の接続関係を行列で表現するグラフ表現</li>
                <li><strong>森（Forest）</strong>: 複数の連結していない木（tree）の集合</li>
                <li><strong>DFSツリー（DFS Tree）</strong>: DFS実行中に訪問した頂点と辺で構成される木構造</li>
            </ul>
            
            <h3>特徴</h3>
            <p>DFSによるグラフの連結成分検出の主な特徴は以下の通りです：</p>
            <ul>
                <li>単純で直感的な実装（再帰または明示的なスタックを使用）</li>
                <li>各頂点と辺を正確に1回ずつ処理するため効率的</li>
                <li>空間効率が良く、頂点数に比例したメモリ使用量</li>
                <li>連結成分のラベル付けが容易（各DFSの呼び出しで新しいラベルを割り当て）</li>
                <li>グラフの構造に関する追加情報（サイクル、橋、関節点など）の検出にも拡張可能</li>
                <li>再帰呼び出しを使用する場合は、深いグラフでスタックオーバーフローの可能性がある</li>
                <li>訪問順序が深さ優先であるため、幅よりも深さを優先して探索する</li>
                <li>各連結成分内で木構造（DFSツリー）を形成する</li>
                <li>無向グラフと有向グラフの両方に適用可能（有向グラフでは強連結成分の概念が異なる）</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>DFSによるグラフの連結成分検出は以下のような場面で特に有用です：</p>
            <ul>
                <li>ネットワーク内の分離したコンポーネントの特定（通信ネットワーク、ソーシャルネットワークなど）</li>
                <li>画像処理における連結領域の識別（画像セグメンテーション）</li>
                <li>地理情報システムにおける地形や区域の解析</li>
                <li>電子回路の解析（分離した回路の特定）</li>
                <li>コミュニティ検出（ソーシャルネットワーク分析）</li>
                <li>クラスタリング問題の解決</li>
                <li>ゲーム開発（到達可能な領域の判定）</li>
                <li>Webクローリングにおけるウェブページの連結性分析</li>
                <li>サイクル検出や橋の特定などの高度なグラフ解析の前処理</li>
                <li>無向グラフの二部グラフ判定</li>
                <li>ロボット経路計画とナビゲーション</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>DFSを使用してグラフの連結成分を見つける手順は以下の通りです：</p>
            
            <h4>1. 初期化</h4>
            <ol>
                <li>すべての頂点を「未訪問」としてマークする</li>
                <li>連結成分の数を0に初期化する</li>
                <li>必要に応じて、各頂点の所属する連結成分を追跡するための配列を用意する</li>
            </ol>
            
            <h4>2. すべての頂点を処理</h4>
            <ol>
                <li>グラフ内のすべての頂点について以下を実行：
                    <ul>
                        <li>頂点がまだ「未訪問」の場合：
                            <ul>
                                <li>連結成分のカウンタをインクリメント</li>
                                <li>現在の頂点から開始してDFS関数を呼び出す</li>
                                <li>DFSで訪問したすべての頂点に現在の連結成分IDを割り当てる</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ol>
            
            <h4>3. DFS関数の実装</h4>
            <ol>
                <li>現在の頂点を「訪問済み」としてマークする</li>
                <li>現在の頂点に連結成分のラベルを割り当てる</li>
                <li>現在の頂点に隣接するすべての頂点について：
                    <ul>
                        <li>隣接頂点が「未訪問」の場合：
                            <ul>
                                <li>その隣接頂点に対してDFS関数を再帰的に呼び出す</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ol>
            
            <h4>4. 非再帰的実装（スタックを使用）</h4>
            <ol>
                <li>空のスタックを初期化する</li>
                <li>開始頂点をスタックにプッシュし、「訪問済み」としてマークする</li>
                <li>スタックが空になるまで以下を繰り返す：
                    <ul>
                        <li>スタックから頂点を取り出す（ポップ）</li>
                        <li>取り出した頂点に連結成分のラベルを割り当てる</li>
                        <li>取り出した頂点に隣接するすべての「未訪問」の頂点について：
                            <ul>
                                <li>隣接頂点を「訪問済み」としてマークする</li>
                                <li>隣接頂点をスタックにプッシュする</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ol>
            
            <h4>5. 結果の処理</h4>
            <ol>
                <li>各頂点に割り当てられた連結成分IDを使用して、グラフ内の連結成分を識別する</li>
                <li>必要に応じて、同じ連結成分に属する頂点をグループ化する</li>
                <li>連結成分の総数を返す</li>
            </ol>
    
            <h3>計算量</h3>
            <p>DFSを使用したグラフの連結成分検出の計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>隣接リスト表現の場合</strong>: O(V + E) - Vは頂点数、Eは辺数</li>
                <li><strong>隣接行列表現の場合</strong>: O(V²) - 各頂点について隣接する可能性のあるすべての頂点をチェックするため</li>
            </ul>
            
            <p>DFSでは各頂点を1回だけ訪問し、各辺も1回だけ調べます。隣接リスト表現を使用する場合、各頂点の処理にその頂点の次数（隣接頂点の数）に比例した時間がかかるため、全体では頂点数と辺数の和に比例した時間計算量になります。</p>
            
            <p>隣接行列表現の場合、各頂点について他のすべての頂点との接続関係を調べる必要があるため、頂点数の2乗に比例した時間がかかります。そのため、疎なグラフ（辺の数が少ないグラフ）では隣接リスト表現の方が効率的です。</p>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>隣接リスト表現の場合</strong>: O(V + E) - グラフの表現自体にこの空間が必要</li>
                <li><strong>隣接行列表現の場合</strong>: O(V²) - VxVの行列を保存</li>
                <li><strong>アルゴリズム自体の追加空間</strong>: O(V) - 訪問状態と連結成分ラベルの追跡に必要</li>
                <li><strong>再帰呼び出しスタック</strong>: 最悪の場合O(V) - 長い経路があるグラフでの再帰の深さ</li>
                <li><strong>明示的なスタック（非再帰実装）</strong>: 最悪の場合O(V) - すべての頂点がスタックに入る可能性</li>
            </ul>
            
            <p>全体として、DFSによるグラフの連結成分検出は計算効率が良く、大規模なグラフにも適用可能です。ただし、グラフの表現方法（隣接リストか隣接行列か）はパフォーマンスに大きな影響を与えるため、グラフの性質に応じて適切な表現を選択することが重要です。</p>
            
            <p>また、再帰を使用する実装では、非常に深いグラフ（長い経路を持つグラフ）の場合にスタックオーバーフローの可能性があるため、そのような場合は明示的なスタックを使用した非再帰実装を検討する必要があります。</p>
        </div>
    </div>
</body>
</html>