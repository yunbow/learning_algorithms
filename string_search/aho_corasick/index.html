<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aho-Corasick法 (Aho-Corasick)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">文字列検索の問題</a></li>
        <li>Aho-Corasick法</li>
    </ul>

    <div class="container">
        <h1>Aho-Corasick法 (Aho-Corasick)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>Aho-Corasick法は、1975年にAlfred V. AhoとMargaret J. Corasickによって開発された文字列検索アルゴリズムで、複数のパターン（キーワード）を一度に効率的に検索するために設計されています。このアルゴリズムは、パターンマッチングオートマトンを構築し、テキスト内を一度だけ走査することで、すべてのパターンの出現を見つけ出すことができます。</p>
            
            <h3>基礎知識</h3>
            <p>Aho-Corasick法は、トライ（Trie）データ構造をベースに発展させたアルゴリズムです。まず検索するすべてのパターンを含むトライを構築し、さらに「失敗リンク」と呼ばれる追加のエッジを追加することで、部分的なマッチが失敗した場合にも効率的に検索を続けることができます。これにより、テキストを一度走査するだけで複数のパターンを同時に検索することが可能になります。</p>
            <p>このアルゴリズムは、大量のテキストに対して多数のパターンを検索する必要がある場合に特に威力を発揮します。例えば、ウイルス検知や自然言語処理、DNAシーケンス解析などの分野で広く利用されています。また、このアルゴリズムはKMP法（Knuth-Morris-Pratt）の考え方を複数パターンに拡張したものとも考えられます。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>トライ（Trie）</strong>: 複数の文字列を格納するための木構造で、共通の接頭辞を共有することで効率的な格納と検索を実現</li>
                <li><strong>失敗リンク（Failure Link）</strong>: 現在のマッチングが失敗した場合に、次に試すべき状態を指すポインタ</li>
                <li><strong>出力関数（Output Function）</strong>: 各状態においてマッチするパターンのリストを格納する関数</li>
                <li><strong>遷移関数（Transition Function）</strong>: 現在の状態と入力文字から次の状態を決定する関数</li>
                <li><strong>パターンマッチングオートマトン</strong>: パターンの検索を行うための有限状態機械</li>
                <li><strong>接頭辞（Prefix）</strong>: 文字列の先頭から連続する部分文字列</li>
                <li><strong>サフィックス（Suffix）</strong>: 文字列の末尾から連続する部分文字列</li>
                <li><strong>状態（State）</strong>: オートマトン内の各ノードを表す概念</li>
                <li><strong>多重パターンマッチング</strong>: 複数のパターンを同時に検索する技術</li>
            </ul>
            
            <h3>特徴</h3>
            <p>Aho-Corasick法の主な特徴は以下の通りです：</p>
            <ul>
                <li>複数のパターンを一度に効率的に検索できる</li>
                <li>テキストの各文字は一度だけ走査される（線形時間）</li>
                <li>前処理としてパターンマッチングオートマトンを構築する必要がある</li>
                <li>失敗リンクにより、部分マッチング情報を再利用できる</li>
                <li>マッチングの過程でバックトラックが発生しない</li>
                <li>テキストの長さに対して線形時間で動作する</li>
                <li>すべてのマッチングを漏れなく見つけることができる</li>
                <li>パターン集合が固定され、テキストが変化する場合に特に効率的</li>
                <li>大文字/小文字の区別や近似マッチングにも拡張可能</li>
                <li>メモリ消費量はパターン集合のサイズに依存する</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>Aho-Corasick法は以下のような場面で特に有用です：</p>
            <ul>
                <li>ウイルス/マルウェア検出のためのシグネチャ検索</li>
                <li>DNAやタンパク質配列内の特定のパターン検索</li>
                <li>プレーンテキスト内の禁止語フィルタリング</li>
                <li>自然言語処理における語彙検索</li>
                <li>侵入検知システム（IDS）での悪意あるパターン検知</li>
                <li>スペルチェックや自動補完機能の実装</li>
                <li>検索エンジンでのインデックス作成</li>
                <li>大量の文書から特定のキーワードセットを抽出する処理</li>
                <li>正規表現エンジンの一部として、固定文字列パターン検索の高速化</li>
                <li>ネットワークパケット検査でのディープパケットインスペクション</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>Aho-Corasick法は、大きく分けて前処理フェーズとマッチングフェーズの2段階で構成されます：</p>
            
            <h4>1. 前処理フェーズ（オートマトンの構築）</h4>
            <ol>
                <li>トライの構築：
                    <ul>
                        <li>検索する全てのパターンをトライに挿入する</li>
                        <li>各パターンの終端ノードに、そのパターンをマークする</li>
                        <li>根から各ノードへの経路が、パターンの接頭辞を表す</li>
                    </ul>
                </li>
                <li>失敗リンクの構築：
                    <ul>
                        <li>幅優先探索を用いて、すべてのノードの失敗リンクを計算する</li>
                        <li>ルートの子ノードの失敗リンクはルートを指す</li>
                        <li>それ以外のノードについては、親ノードの失敗リンク先から遷移を試みる</li>
                        <li>遷移可能なら、その遷移先を失敗リンクとする</li>
                        <li>遷移不可能なら、さらに失敗リンクを辿って遷移を試みる</li>
                        <li>このプロセスを全てのノードに対して実行する</li>
                    </ul>
                </li>
                <li>出力関数の構築：
                    <ul>
                        <li>各ノードが複数のパターンにマッチする可能性があるため、出力関数を定義する</li>
                        <li>ノード自身がパターンの終端である場合、そのパターンを出力リストに追加する</li>
                        <li>ノードの失敗リンク先にも出力があれば、それも出力リストに追加する</li>
                        <li>これにより、サフィックスとして他のパターンを含む場合も検出できる</li>
                    </ul>
                </li>
            </ol>
            
            <h4>2. マッチングフェーズ（テキスト検索）</h4>
            <ol>
                <li>初期状態をトライの根ノードとする</li>
                <li>テキストを先頭から一文字ずつ処理する：
                    <ul>
                        <li>現在の状態から次の文字に対する遷移が存在する場合：
                            <ul>
                                <li>その遷移に従って次の状態に移動する</li>
                            </ul>
                        </li>
                        <li>遷移が存在しない場合：
                            <ul>
                                <li>失敗リンクを辿って次の状態を見つける</li>
                                <li>遷移が見つかるか、根ノードに戻るまでこれを繰り返す</li>
                            </ul>
                        </li>
                        <li>現在の状態の出力関数をチェックする：
                            <ul>
                                <li>出力があれば、マッチしたパターンと現在位置を記録する</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>テキストの終端に達するまで、上記の処理を繰り返す</li>
            </ol>
            
            <h4>例：パターン集合 {"he", "she", "his", "hers"} の場合</h4>
            <ol>
                <li>これらのパターンからトライを構築する</li>
                <li>各ノードに対して失敗リンクを設定する
                    <ul>
                        <li>例えば、"he"の"e"ノードから"h"への失敗リンクが設定される</li>
                        <li>"she"の"e"ノードは"he"の"e"ノードへの失敗リンクを持つ</li>
                    </ul>
                </li>
                <li>各ノードの出力関数を設定する
                    <ul>
                        <li>"he"の"e"ノードは"he"を出力</li>
                        <li>"she"の"e"ノードは"she"と"he"を出力（失敗リンク経由で）</li>
                    </ul>
                </li>
                <li>テキスト"ushers"を検索すると：
                    <ul>
                        <li>位置3で"she"を検出</li>
                        <li>同時に位置3で"he"も検出</li>
                        <li>位置5で"hers"を検出</li>
                    </ul>
                </li>
            </ol>
    
            <h3>計算量</h3>
            <p>Aho-Corasick法のアルゴリズムの計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>前処理フェーズ</strong>:
                    <ul>
                        <li>トライの構築：O(m) - ここでmは全パターンの長さの合計</li>
                        <li>失敗リンクの構築：O(m × |Σ|) - ここで|Σ|はアルファベットのサイズ</li>
                        <li>最適な実装では失敗リンクの構築は平均O(m)で可能</li>
                    </ul>
                </li>
                <li><strong>マッチングフェーズ</strong>: O(n + z)
                    <ul>
                        <li>n：テキストの長さ</li>
                        <li>z：検出されたマッチの総数</li>
                    </ul>
                </li>
                <li>全体としての時間計算量は O(m + n + z)</li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>トライの格納</strong>: O(m × |Σ|) - 最悪の場合</li>
                <li><strong>最適な実装</strong>: O(m) - 圧縮トライを使用した場合</li>
                <li><strong>失敗リンクと出力関数</strong>: O(m)</li>
                <li>全体としての空間計算量は O(m × |Σ|) または最適化実装では O(m)</li>
            </ul>
            
            <p>Aho-Corasick法の大きな利点は、テキストの長さ(n)に対して線形時間でマッチングが行えることです。特に、パターンの数が多い場合や、パターンが頻繁に出現する場合に効率的です。例えば、100のパターンを検索する場合、各パターンを個別に検索すると最悪O(n × 100)の時間がかかりますが、Aho-Corasick法ではO(n + z)で済みます。</p>
            
            <p>前処理にかかる時間は全パターンの長さの合計に比例しますが、一度オートマトンを構築してしまえば、複数のテキストに対して再利用することが可能です。そのため、固定されたパターン集合に対して多数のテキストを検索する場合に特に効率的なアルゴリズムと言えます。</p>
            
            <p>ただし、パターン集合が非常に大きい場合やアルファベットサイズが大きい場合には、メモリ消費量が増大する可能性があります。そのような場合は、トライの圧縮や、他のデータ構造との組み合わせによる最適化が必要になることがあります。</p>
        </div>
    </div>
</body>
</html>