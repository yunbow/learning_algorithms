<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ラビン-カープ法 (Rabin-Karp)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">文字列検索の問題</a></li>
        <li>ラビン-カープ法</li>
    </ul>
    <div class="container">
        <h1>ラビン-カープ法 (Rabin-Karp)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>ラビン-カープ法は、1987年にRichard M. KarpとMichael O. Rabinによって発表された文字列検索アルゴリズムです。このアルゴリズムはハッシュ関数を使用して、テキスト内でパターンを効率的に検索します。特に複数パターンの同時検索に適しています。</p>
            
            <h3>基礎知識</h3>
            <p>文字列検索とは、長いテキスト（ヘイスタック）から特定のパターン（ニードル）を見つけ出す処理を指します。ラビン-カープ法は、パターンとテキストの各部分文字列をハッシュ値に変換し、これらのハッシュ値を比較することで検索を行います。</p>
            <p>ハッシュ関数は文字列を数値（ハッシュ値）に変換しますが、異なる文字列が同じハッシュ値を持つ「衝突」が発生する可能性があります。そのため、ハッシュ値が一致した場合には、実際の文字列を比較して確認する必要があります。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ハッシュ関数（hash function）</strong>: 任意のデータを固定長の値に変換する関数</li>
                <li><strong>ローリングハッシュ（rolling hash）</strong>: 連続するデータのハッシュ値を効率的に計算するための手法</li>
                <li><strong>モジュロ演算（modular arithmetic）</strong>: 剰余を使用した演算体系（ハッシュ計算でオーバーフロー防止に使用）</li>
                <li><strong>衝突（collision）</strong>: 異なる入力が同じハッシュ値を生成する現象</li>
                <li><strong>偽陽性（false positive）</strong>: ハッシュ値は一致したが実際の文字列は異なるケース</li>
                <li><strong>窓（window）</strong>: テキスト内で現在比較中の部分文字列</li>
            </ul>
            
            <h3>特徴</h3>
            <p>ラビン-カープ法の主な特徴は以下の通りです：</p>
            <ul>
                <li>ハッシュ関数を利用して比較回数を削減</li>
                <li>ローリングハッシュによる効率的な計算（前の窓のハッシュ値を利用して次の窓のハッシュ値を計算）</li>
                <li>複数パターンの同時検索が可能（同じハッシュ関数を使い、ハッシュ値のセットを作成）</li>
                <li>最悪の場合でもO((n-m+1)・m)の時間計算量（nはテキスト長、mはパターン長）</li>
                <li>平均的なケースでは効率が良いが、最悪ケースでは素朴な総当たり法と同程度</li>
                <li>実装が比較的シンプル</li>
                <li>パターンとテキストの前処理が少なくて済む</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>ラビン-カープ法は以下のような場面で特に有用です：</p>
            <ul>
                <li>複数パターンの同時検索（例：剽窃検出や類似文書の検索）</li>
                <li>2次元パターンマッチング（画像内のパターン検索など）</li>
                <li>DNA配列や蛋白質配列などの生物学的配列データの解析</li>
                <li>情報検索システム</li>
                <li>データ重複検出（データ重複排除技術）</li>
                <li>インターネットコンテンツフィルタリング</li>
                <li>侵入検知システム（ネットワークパケットの分析）</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>ラビン-カープ法の基本的な手順は以下の通りです：</p>
            <ol>
                <li>検索パターンのハッシュ値を計算する</li>
                <li>テキストの最初のウィンドウ（パターンと同じ長さの部分文字列）のハッシュ値を計算する</li>
                <li>テキストを順に走査し、各ウィンドウについて：
                    <ol type="a">
                        <li>現在のウィンドウのハッシュ値とパターンのハッシュ値を比較する</li>
                        <li>ハッシュ値が一致した場合、実際の文字列を比較して完全一致を確認する</li>
                        <li>一致した場合、マッチング位置を記録する</li>
                        <li>ウィンドウを1文字分スライドし、ローリングハッシュを使って新しいウィンドウのハッシュ値を効率的に計算する</li>
                    </ol>
                </li>
                <li>全てのマッチング位置を返す</li>
            </ol>
            
            <p>このプロセスでは、ハッシュ値の比較によって明らかに異なる部分文字列を効率的に除外できるため、実際の文字列比較の回数を減らすことができます。</p>
            
            <h4>具体例: テキスト "ABCABCABD" 内でパターン "ABC" を検索する場合</h4>
            <p>簡単な例として、各文字をアルファベット順の位置（A=1, B=2, ...）に基づく数値として、基数10のハッシュ関数を使用します。</p>
            <ol>
                <li>パターン "ABC" のハッシュ値を計算: 1×10² + 2×10¹ + 3×10⁰ = 123</li>
                <li>テキストの最初のウィンドウ "ABC" のハッシュ値を計算: 1×10² + 2×10¹ + 3×10⁰ = 123</li>
                <li>ハッシュ値が一致（123 = 123）するので、文字列を比較: "ABC" = "ABC"（一致）</li>
                <li>マッチング位置として0を記録</li>
                <li>ウィンドウを1文字スライドして "BCA" のハッシュ値を計算: 
                   <br>前のハッシュ値から最上位桁（1×10²）を削除、全体を10倍して新しい文字の値を加える
                   <br>(123 - 1×10²) × 10 + 1×10⁰ = 231</li>
                <li>ハッシュ値が不一致（231 ≠ 123）なので次へ</li>
                <li>次のウィンドウ "CAB" のハッシュ値を計算: (231 - 2×10²) × 10 + 2×10⁰ = 312</li>
                <li>ハッシュ値が不一致（312 ≠ 123）なので次へ</li>
                <li>次のウィンドウ "ABC" のハッシュ値を計算: (312 - 3×10²) × 10 + 3×10⁰ = 123</li>
                <li>ハッシュ値が一致（123 = 123）するので、文字列を比較: "ABC" = "ABC"（一致）</li>
                <li>マッチング位置として3を記録</li>
                <li>残りのウィンドウ "BCA"、"CAB"、"ABD" についても同様に処理</li>
                <li>最終的に位置0と3がマッチング位置として返される</li>
            </ol>
            
            <p>実際の実装では、大きな数値のオーバーフローを防ぐためにモジュロ演算を使用します。一般的には大きな素数をモジュロとして選択します。</p>
            
            <h3>計算量</h3>
            <p>ラビン-カープ法の計算量は以下の特性を持ちます：</p>
            <ul>
                <li><strong>前処理時間計算量</strong>: O(m) - パターンのハッシュ値の計算</li>
                <li><strong>検索時間計算量</strong>:
                    <ul>
                        <li>平均的なケース: O(n + m) - n はテキストの長さ、m はパターンの長さ</li>
                        <li>最悪のケース: O((n-m+1)・m) - 全ての窓でハッシュ衝突が発生した場合</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(1) - 複数パターン検索の場合は O(k) （k はパターン数）</li>
            </ul>
            
            <p>ラビン-カープ法の効率は、使用するハッシュ関数の質に大きく依存します。良いハッシュ関数は衝突を最小限に抑え、平均的なケースでの性能を向上させます。</p>
            
            <p>特に複数パターンを同時に検索する場合、k個のパターンを検索する時間計算量はO(n + k・m)となり、各パターンを個別に検索するよりも効率的です。これが、ラビン-カープ法が剽窃検出のような複数パターン検索のアプリケーションで広く使用される理由の一つです。</p>
            
            <p>ただし、最悪のケースでは素朴な総当たり法と同程度の性能になることに注意が必要です。テキストのような実世界のデータでは、適切なハッシュ関数を選択することで、このような最悪のケースは実際にはほとんど発生しません。</p>
        </div>
    </div>
</body>
</html>