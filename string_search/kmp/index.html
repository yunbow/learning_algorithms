<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KMP法</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">文字列検索の問題</a></li>
        <li>KMP法</li>
    </ul>
    <div class="container">
        <h1>KMP法</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>KMP法（Knuth-Morris-Pratt法）は、1977年にドナルド・クヌース、ヴォーン・プラット、ジェームズ・H・モリスによって開発された効率的な文字列検索アルゴリズムです。このアルゴリズムは、パターンマッチングにおいて不要な比較を回避し、文字列検索を高速化します。</p>
            
            <h3>基礎知識</h3>
            <p>文字列検索は、テキスト（本文）から特定のパターン（検索文字列）を見つけ出す処理です。例えば、「ABABCABCABABCABD」というテキストから「ABABCABD」というパターンを検索するような場合に使用します。</p>
            <p>KMP法の基本的な考え方は、「パターン自身の情報を利用して、不要な比較を省く」というものです。文字列比較中にミスマッチが発生した場合、ナイーブな方法では先頭から再度比較しますが、KMP法では過去の比較結果を活用して次に比較を始めるべき位置を効率的に決定します。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>テキスト（Text）</strong>: 検索対象となる文字列</li>
                <li><strong>パターン（Pattern）</strong>: 検索する部分文字列</li>
                <li><strong>接頭辞（Prefix）</strong>: 文字列の先頭から連続する部分文字列</li>
                <li><strong>接尾辞（Suffix）</strong>: 文字列の末尾から連続する部分文字列</li>
                <li><strong>部分一致テーブル（Partial Match Table）</strong>: パターンの各位置における、一致する最長の接頭辞と接尾辞の長さを保持するテーブル</li>
                <li><strong>失敗関数（Failure Function）</strong>: 不一致が発生した場合にパターン内のどの位置から比較を再開すべきかを示す関数</li>
                <li><strong>ミスマッチ（Mismatch）</strong>: パターンとテキストの文字が一致しない状況</li>
            </ul>
            
            <h3>特徴</h3>
            <p>KMP法の主な特徴は以下の通りです：</p>
            <ul>
                <li>事前計算した部分一致テーブルを使用して不要な比較を回避</li>
                <li>テキスト内の各文字は最大で1回しか比較されない</li>
                <li>線形時間（O(n+m)）で動作する効率的なアルゴリズム</li>
                <li>パターン内の繰り返し構造を活用する</li>
                <li>テキストを一度だけ走査するため、ストリーミングデータの処理に適している</li>
                <li>パターンが複雑で繰り返し構造を含む場合に特に威力を発揮する</li>
                <li>Boyer-Moore法などと比較すると実装が比較的シンプル</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>KMP法は以下のような場面で特に有用です：</p>
            <ul>
                <li>大規模なテキストデータ内での文字列検索</li>
                <li>DNAシーケンス内での特定パターンの検出</li>
                <li>複雑なパターンの検索（特に繰り返し構造を含むパターン）</li>
                <li>リアルタイム検索やストリーミングデータの処理</li>
                <li>テキストエディタの検索機能</li>
                <li>バイオインフォマティクスでの配列アライメント</li>
                <li>ネットワークプロトコルにおけるパケットペイロードの検査</li>
                <li>プログラミング言語の字句解析器</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>KMP法は大きく分けて2つのステップから構成されます：</p>
            
            <ol>
                <li><strong>部分一致テーブル（失敗関数）の構築</strong>：
                    <ol>
                        <li>パターンを解析し、各位置で一致する最長の接頭辞と接尾辞の長さを計算する</li>
                        <li>これにより、不一致が発生した場合に比較を開始すべき位置が決定される</li>
                    </ol>
                </li>
                <li><strong>文字列検索</strong>：
                    <ol>
                        <li>テキストとパターンの先頭から比較を開始する</li>
                        <li>一致した場合、次の文字の比較に進む</li>
                        <li>不一致が発生した場合、部分一致テーブルを参照して比較を再開する位置を決定する</li>
                        <li>パターン全体が一致すれば、位置を記録して次の検索に進む</li>
                        <li>テキストの末尾に達するまで繰り返す</li>
                    </ol>
                </li>
            </ol>
            
            <h4>部分一致テーブルの構築手順</h4>
            <ol>
                <li>パターンの長さmに対して、長さmの配列を用意する</li>
                <li>最初の要素（インデックス0）は常に0とする</li>
                <li>2つのポインタ（位置jと前の位置の値）を使用して配列を埋めていく</li>
                <li>文字が一致すれば、値を増やしてインデックスを進める</li>
                <li>文字が一致しなければ、前の位置の値を参照して適切な位置まで戻る</li>
                <li>すべての位置について値を計算する</li>
            </ol>
            
            <h4>具体例: 「ABABCABD」でのKMP検索</h4>
            <p>パターン「ABABCABD」の部分一致テーブルを構築：</p>
            <ul>
                <li>パターン: A B A B C A B D</li>
                <li>インデックス: 0 1 2 3 4 5 6 7</li>
                <li>テーブル値: 0 0 1 2 0 1 2 0</li>
            </ul>
            
            <p>例えば、テキスト「ABABCABABCABDABABCABD」内でパターン「ABABCABD」を検索する場合：</p>
            <ol>
                <li>テキスト位置0から比較開始</li>
                <li>「ABABCAB」まで一致するが、次の文字でミスマッチ（Dが必要だがAが出現）</li>
                <li>テーブル値を参照し、パターンの位置2から比較を再開</li>
                <li>比較を続け、最終的にテキスト位置12で完全一致</li>
            </ol>
            
            <h3>計算量</h3>
            <p>KMP法の計算量は以下の特性を持ちます：</p>
            <ul>
                <li><strong>時間計算量</strong>: 
                    <ul>
                        <li>部分一致テーブルの構築: O(m) - mはパターンの長さ</li>
                        <li>文字列検索: O(n) - nはテキストの長さ</li>
                        <li>全体の時間計算量: O(n+m)</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(m) - 部分一致テーブルのサイズ</li>
            </ul>
            
            <p>KMP法の最大の利点は、テキストの各文字を最大で1回しか比較しないことです。ナイーブな文字列検索アルゴリズムの最悪時間計算量O(n×m)と比較して、大幅な改善となります。</p>
            
            <p>実際のパフォーマンスは、テキストとパターンの性質に依存します。特に、パターンに繰り返し構造がある場合や、長いパターンを扱う場合にKMP法の利点が顕著になります。</p>
            
            <p>一方で、短いパターンや単純なパターンの検索では、Boyer-Moore法などの他のアルゴリズムが実用的にはより高速に動作する場合もあります。しかし、理論的な時間計算量の面では、KMP法は最適なアルゴリズムの一つとして位置づけられています。</p>
        </div>    
    </div>
</body>
</html>