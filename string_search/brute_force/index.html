<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ブルート-フォース法 (Brute Force)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">文字列検索の問題</a></li>
        <li>ブルート-フォース法</li>
    </ul>
    <div class="container">
        <h1>ブルート-フォース法 (Brute Force)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>ブルートフォース法（総当たり法）は、文字列検索問題を解決するための最も単純かつ直接的なアプローチです。このアルゴリズムはパターンとテキストを順番に比較していき、全ての可能な位置でマッチングを試みます。シンプルであるため実装が容易である一方、大規模なテキストや複雑なパターンに対しては効率が悪くなる傾向があります。</p>
            
            <h3>基礎知識</h3>
            <p>文字列検索（String Matching）とは、与えられたテキスト（主文字列）の中から特定のパターン（検索文字列）が出現する位置を全て見つけ出す問題です。例えば、「ABABCABCABAB」というテキスト内で「ABC」というパターンを検索すると、位置4と位置7から始まる部分で一致が見つかります。</p>
            <p>ブルートフォース法の基本的な考え方は非常にシンプルで、テキストの各位置から始めてパターンとの一致を一文字ずつ確認していきます。これは直感的で理解しやすいアプローチですが、より効率的なアルゴリズム（KMP法、Boyer-Moore法、Rabin-Karp法など）と比較すると処理効率が劣ります。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>テキスト（text/主文字列）</strong>: 検索対象となる長い文字列</li>
                <li><strong>パターン（pattern/検索文字列）</strong>: テキスト内で探したい短い文字列</li>
                <li><strong>マッチング（matching）</strong>: パターンとテキストの一部が完全に一致すること</li>
                <li><strong>シフト（shift）</strong>: テキスト内でパターンを比較する位置を移動させること</li>
                <li><strong>比較回数（comparisons）</strong>: アルゴリズム実行中に行われる文字の比較の総数</li>
                <li><strong>最悪ケース（worst case）</strong>: アルゴリズムが最も非効率に動作する入力パターン</li>
            </ul>
            
            <h3>特徴</h3>
            <p>ブルートフォース法の主な特徴は以下の通りです：</p>
            <ul>
                <li>実装が非常に単純で直感的</li>
                <li>前処理が不要（他のアルゴリズムでは効率向上のための前処理が必要なことが多い）</li>
                <li>追加のメモリをほとんど必要としない</li>
                <li>小さなテキストや短いパターンに対しては十分に効率的</li>
                <li>文字列検索の基本アルゴリズムとして、他の高度なアルゴリズムと比較する際の基準点となる</li>
                <li>最悪ケースでの時間効率が悪い（O(n×m)、nはテキストの長さ、mはパターンの長さ）</li>
                <li>異なる文字集合や自然言語に対して特別な調整なしに適用可能</li>
                <li>パターンマッチングの教育的な例として優れている</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>ブルートフォース法は以下のような場面で特に適しています：</p>
            <ul>
                <li>短いテキストや検索パターンを扱う場合</li>
                <li>検索が頻繁に行われない場合（一度きりの検索など）</li>
                <li>実装の単純さが重要視される場合</li>
                <li>他のより複雑なアルゴリズムの正確性を検証する参照実装として</li>
                <li>教育環境での文字列検索アルゴリズムの導入として</li>
                <li>メモリが非常に限られている環境での実装</li>
                <li>複雑な前処理が難しい状況（例：ストリーミングデータの即時検索）</li>
                <li>小規模なテキストエディタやシンプルな検索機能の実装</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>ブルートフォース法による文字列検索の基本的な手順は以下の通りです：</p>
            <ol>
                <li>テキスト T（長さ n）とパターン P（長さ m）を入力として受け取る</li>
                <li>テキスト内の各位置 i（0 ≤ i ≤ n-m）について以下を実行：
                    <ol type="a">
                        <li>パターン P の各文字 j（0 ≤ j < m）について T[i+j] と P[j] を比較</li>
                        <li>全ての文字が一致した場合（j = m-1 まで到達）、位置 i でマッチが見つかったことを記録</li>
                        <li>一致しない文字が見つかった場合、比較を中断して次の位置（i+1）に移動</li>
                    </ol>
                </li>
                <li>テキスト内の全ての一致位置のリストを返す</li>
            </ol>
            
            <p>この過程はテキストの長さとパターンの長さに依存して、最大で O(n×m) 回の文字比較を行います。</p>
            
            <h4>具体例: テキスト「ABABCABCABAB」内でパターン「ABC」を検索する場合</h4>
            <ol>
                <li>テキスト T =「ABABCABCABAB」（長さ n = 12）、パターン P =「ABC」（長さ m = 3）</li>
                <li>位置 i = 0 から開始：
                    <ul>
                        <li>T[0] = 'A' と P[0] = 'A' を比較 → 一致</li>
                        <li>T[1] = 'B' と P[1] = 'B' を比較 → 一致</li>
                        <li>T[2] = 'A' と P[2] = 'C' を比較 → 不一致</li>
                        <li>位置 i = 1 に移動</li>
                    </ul>
                </li>
                <li>位置 i = 1：
                    <ul>
                        <li>T[1] = 'B' と P[0] = 'A' を比較 → 不一致</li>
                        <li>位置 i = 2 に移動</li>
                    </ul>
                </li>
                <li>位置 i = 2：
                    <ul>
                        <li>T[2] = 'A' と P[0] = 'A' を比較 → 一致</li>
                        <li>T[3] = 'B' と P[1] = 'B' を比較 → 一致</li>
                        <li>T[4] = 'C' と P[2] = 'C' を比較 → 一致</li>
                        <li>全て一致したので、位置 i = 2 でマッチを記録</li>
                        <li>位置 i = 3 に移動</li>
                    </ul>
                </li>
                <li>（以下同様に i = 3, 4, 5, 6, 7, 8, 9 と処理を続ける）</li>
                <li>結果として、位置 2 と位置 5 でパターン「ABC」が見つかる</li>
            </ol>
            
            <p>注意：上記の例では0から始まるインデックスを使用していますが、1から始まるインデックスを使う場合は位置を1ずつ増やして考えてください。</p>
            
            <h3>計算量</h3>
            <p>ブルートフォース法の文字列検索における計算量は以下の通りです：</p>
            <ul>
                <li><strong>時間計算量</strong>:
                    <ul>
                        <li>最悪ケース: O(n×m) - テキストとパターンがほぼ同じ文字で構成されている場合など</li>
                        <li>平均ケース: O(n) - テキストとパターンが一般的な自然言語で、早期に不一致が検出される場合</li>
                        <li>最良ケース: O(n) - パターンの最初の文字がテキスト内に稀にしか現れない場合</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(1) - 入力テキストとパターン以外に追加のメモリをほとんど使用しない</li>
            </ul>
            
            <p>ブルートフォース法の最悪ケースは、テキストとパターンが多くの部分一致を持つ場合に発生します。例えば、テキスト「AAAAAAAA」内でパターン「AAAB」を検索する場合、各位置でパターンの最後の文字まで比較が進むため、多くの無駄な比較が行われます。</p>
            
            <p>このような非効率性を解決するために、KMP法（Knuth-Morris-Pratt Algorithm）やBoyer-Moore法などの高度なアルゴリズムが開発されています。これらは前処理によってパターン内の情報を活用し、不要な比較を減らすことで効率を向上させています。</p>
            
            <p>しかしながら、実際の応用では、多くの場合パターンが短く、テキスト内に頻繁に出現しないため、ブルートフォース法でも十分な性能が得られることが多いです。また、現代のコンピュータの処理速度を考えると、小〜中規模のテキストに対しては実用上の問題が生じることは少ないといえます。</p>
        </div>
    </div>
</body>
</html>
