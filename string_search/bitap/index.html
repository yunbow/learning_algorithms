<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitap法 (Bitap Algorithm)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">文字列検索の問題</a></li>
        <li>Bitap法</li>
    </ul>

    <div class="container">
        <h1>Bitap法 (Bitap Algorithm)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>Bitap法（ビットアップ法）は、ビット並列処理を利用した高速な近似文字列検索アルゴリズムです。このアルゴリズムは、ビット操作を巧みに活用することで、効率的なパターンマッチングを実現します。特に短いパターンの検索や、編集距離を考慮した近似マッチングに適しています。</p>
            
            <h3>基礎知識</h3>
            <p>Bitap法は、元々はShift-OR（シフトOR）アルゴリズムとしても知られ、Ricardo Baeza-YatesとGonnet Gaston Gonnetによって開発されました。後にSun WuとUdi Manberによって拡張され、編集距離を考慮した近似マッチングが可能になりました。</p>
            <p>このアルゴリズムの核心は、パターンマッチングの状態をビットマスクとして表現し、ビット演算を用いて高速に状態遷移を行うことです。コンピュータのビット並列処理能力を活用することで、特に短いパターンに対して非常に効率的に動作します。</p>
            <p>Bitap法は、基本的な完全一致検索から、置換、挿入、削除などのエラーを許容する近似マッチングまで拡張可能な柔軟なアルゴリズムです。特にUnixのgrep系コマンド（特にagrep）の実装に採用されたことで知られています。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ビットマスク（bitmask）</strong>: 各ビット位置が特定の条件や状態を表す二進数値</li>
                <li><strong>ビット並列処理（bit-parallelism）</strong>: コンピュータのワード単位でのビット演算を活用した並列処理技術</li>
                <li><strong>パターン（pattern）</strong>: 検索対象となる文字列</li>
                <li><strong>テキスト（text）</strong>: 検索される元の文字列</li>
                <li><strong>エディットバッファ（edit buffer）</strong>: 近似マッチングにおいて、現在の編集状態を保持するビットベクトル</li>
                <li><strong>編集距離（edit distance）</strong>: 二つの文字列間の相違度を表す指標（レーベンシュタイン距離など）</li>
                <li><strong>シフト操作（shift operation）</strong>: ビットを左右に移動させる演算</li>
                <li><strong>ビット演算（bitwise operation）</strong>: AND、OR、XOR、NOTなどのビット単位での論理演算</li>
                <li><strong>ファジーマッチング（fuzzy matching）</strong>: 完全一致ではなく、ある程度の相違を許容するマッチング</li>
            </ul>
            
            <h3>特徴</h3>
            <p>Bitap法の主な特徴は以下の通りです：</p>
            <ul>
                <li>ビット並列処理による高速な検索が可能</li>
                <li>コンピュータのワードサイズ（32ビットや64ビット）に依存する効率性</li>
                <li>短いパターン（ワードサイズ以下）に対して特に効率的</li>
                <li>複雑なパターンマッチングをシンプルなビット操作に変換</li>
                <li>編集距離を考慮した近似マッチングに拡張可能</li>
                <li>複数のエラー（置換、挿入、削除）を許容するマッチングに対応</li>
                <li>前処理が比較的シンプルで計算量が少ない</li>
                <li>正規表現の一部の機能をサポート可能</li>
                <li>空間効率が良く、追加のデータ構造が最小限</li>
                <li>長いパターンに対しては分割して適用する必要がある</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>Bitap法は以下のような場面で特に有用です：</p>
            <ul>
                <li>テキストエディタの検索機能</li>
                <li>DNAやタンパク質配列のバイオインフォマティクス解析</li>
                <li>スペルチェッカーやオートコレクト機能</li>
                <li>ファジー検索エンジン</li>
                <li>固定長の短いパターンに対する高速検索</li>
                <li>コマンドラインツール（grepなど）の実装</li>
                <li>テキストマイニングにおける類似文字列の検出</li>
                <li>リアルタイム検索が必要なアプリケーション</li>
                <li>タイプミスや OCR エラーを含むテキストの検索</li>
                <li>音楽や音声データでのパターン検出（データをシンボル化した場合）</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>Bitap法の基本的な手順は以下の通りです。ここでは、まず完全一致の基本アルゴリズム（Shift-OR）を説明し、その後近似マッチングの拡張について説明します：</p>
            
            <h4>1. 基本的なBitap法（完全一致）</h4>
            <ol>
                <li><strong>前処理: パターンのビットマスクの作成</strong>
                    <ul>
                        <li>アルファベットの各文字cに対して、パターン内でのその文字の出現位置を表すビットマスク B[c] を作成する</li>
                        <li>パターン P = p[0]p[1]...p[m-1] (長さm) の場合</li>
                        <li>初期状態では全ての B[c] = ~0（全ビット1）とする</li>
                        <li>パターン内の各位置jに対して、B[p[j]] の j番目のビットを0にセットする</li>
                    </ul>
                </li>
                <li><strong>検索プロセス</strong>
                    <ul>
                        <li>状態変数 D を初期値 ~0（全ビット1）にセット</li>
                        <li>テキスト T = t[0]t[1]...t[n-1] (長さn) の各文字に対して以下を実行：
                            <ul>
                                <li>D = (D << 1) | B[t[i]]（シフトと論理OR演算）</li>
                                <li>もし D のm-1番目のビットが0なら、現在位置 i-(m-1) でマッチが見つかったことを意味する</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ol>
            
            <h4>2. 近似マッチング用のBitap法（k誤り許容）</h4>
            <ol>
                <li><strong>前処理: パターンのビットマスクの作成</strong>
                    <ul>
                        <li>基本的なBitap法と同様にパターンの文字ごとのビットマスク B[c] を作成</li>
                    </ul>
                </li>
                <li><strong>状態バッファの初期化</strong>
                    <ul>
                        <li>k+1個の状態バッファ R[0], R[1], ..., R[k] を用意（Rはエディットバッファ）</li>
                        <li>R[0] = ~0（全ビット1）、R[1]からR[k]は0に初期化</li>
                    </ul>
                </li>
                <li><strong>検索プロセス</strong>
                    <ul>
                        <li>テキストの各文字 t[i] に対して以下を実行：</li>
                        <li>旧状態を一時変数 oldR に保存</li>
                        <li>R[0] = ((R[0] << 1) | B[t[i]])（エラーなしの状態を更新）</li>
                        <li>各エラーレベル d（1からk）に対して：
                            <ul>
                                <li>R[d] = ((R[d] << 1) | B[t[i]])　/* 置換エラー */</li>
                                <li>      & (oldR[d-1] << 1)        /* 挿入エラー */</li>
                                <li>      & (oldR[d] << 1)          /* 削除エラー */</li>
                                <li>      & oldR[d-1]               /* 置換エラー */</li>
                            </ul>
                        </li>
                        <li>いずれかの R[d] のm-1番目のビットが0なら、現在位置でd個のエラーを持つマッチが見つかった</li>
                    </ul>
                </li>
            </ol>
            
            <h4>3. ビットマスクの更新最適化</h4>
            <ol>
                <li>シフト操作後に、マスクと状態変数の間で論理演算（AND、OR）を実行</li>
                <li>ビット並列性を活かすため、可能な限り一度の操作で複数の状態を更新</li>
                <li>ワードサイズを超えるパターンの場合は、複数のワードに分割して処理</li>
            </ol>
    
            <h3>計算量</h3>
            <p>Bitap法アルゴリズムの計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>前処理</strong>: O(m + σ) - mはパターンの長さ、σはアルファベットサイズ</li>
                <li><strong>検索（完全一致）</strong>: O(n) - nはテキストの長さ</li>
                <li><strong>検索（k誤り許容）</strong>: O(kn) - kは許容誤り数</li>
            </ul>
            
            <p>各テキスト文字に対する操作は定数時間で実行されるため、基本的なBitap法の検索フェーズはO(n)の時間計算量となります。近似マッチングの場合は、各文字に対してk個の状態を更新する必要があるため、O(kn)となります。</p>
            
            <p>ただし、これらの計算量はパターンの長さmがコンピュータのワードサイズw（通常32ビットまたは64ビット）以下の場合に適用されます。mがwより大きい場合、計算量は実質的にO(⌈m/w⌉ × n)またはO(⌈m/w⌉ × k × n)となります。</p>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>完全一致</strong>: O(σ) - σはアルファベットサイズ（文字集合の大きさ）</li>
                <li><strong>k誤り許容</strong>: O(σ + k) - kは許容誤り数</li>
            </ul>
            
            <p>Bitap法はシンプルなビットマスクのみを使用するため、空間効率が非常に良いアルゴリズムです。基本的には各文字に対応するビットマスクと、少数の状態変数のみを保持します。近似マッチングではk個の追加状態バッファが必要になりますが、それでも空間計算量は比較的小さいままです。</p>
            
            <p>このような効率的な計算量特性により、Bitap法は特に短いパターンに対する文字列検索や、リアルタイム性が求められるアプリケーションで広く利用されています。また、ビット並列処理の特性上、検索対象となるパターンが短いほど（特にワードサイズ以下の場合）、その効率は最大化されます。</p>
        </div>
    </div>
</body>
</html>