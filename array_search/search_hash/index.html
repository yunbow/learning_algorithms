<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ハッシュ探索 (Hash Search)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">配列の検索問題</a></li>
        <li>ハッシュ探索</li>
    </ul>
    <div class="container">
        <h1>ハッシュ探索 (Hash Search)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>ハッシュ探索はキーを使用してデータを検索する効率的な方法で、理想的な条件下では定数時間O(1)で要素を検索できます。ハッシュ関数を使用してキーを配列のインデックスに変換し、そのインデックスに直接アクセスすることで高速な検索が可能になります。このアルゴリズムはハッシュテーブル（連想配列やディクショナリとも呼ばれる）というデータ構造を基盤としています。</p>
            
            <h3>基礎知識</h3>
            <p>ハッシュ探索は、キーを数値（ハッシュ値またはハッシュコード）に変換するハッシュ関数を使用します。このハッシュ値はハッシュテーブルの配列インデックスとして使用され、キーに関連付けられた値を格納または検索します。理想的には、各キーは一意のインデックスにマッピングされますが、実際には異なるキーが同じハッシュ値を生成する「ハッシュ衝突」が発生することがあります。</p>
            <p>ハッシュ衝突を処理するために、「チェイニング」や「オープンアドレッシング」などの方法が使用されます。チェイニングでは、同じインデックスにマッピングされた複数の要素を連結リストで管理します。オープンアドレッシングでは、衝突が発生した場合に別の空きスロットを探す方法（線形探査、二次探査、ダブルハッシングなど）が使用されます。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ハッシュ関数（hash function）</strong>: キーをハッシュテーブルの配列インデックスに変換する関数</li>
                <li><strong>ハッシュ値/ハッシュコード（hash value/hash code）</strong>: ハッシュ関数によって生成された数値</li>
                <li><strong>ハッシュテーブル（hash table）</strong>: キーと値のペアを格納するためのデータ構造</li>
                <li><strong>ロードファクター（load factor）</strong>: ハッシュテーブル内の要素数をテーブルサイズで割った値</li>
                <li><strong>ハッシュ衝突（hash collision）</strong>: 異なるキーが同じハッシュ値を生成する現象</li>
                <li><strong>チェイニング（chaining）</strong>: 衝突解決のため、同じインデックスの要素を連結リストで管理する方法</li>
                <li><strong>オープンアドレッシング（open addressing）</strong>: 衝突時に別の空きスロットを探す方法</li>
                <li><strong>線形探査（linear probing）</strong>: 衝突時に次の空きスロットを順に探す方法</li>
                <li><strong>二次探査（quadratic probing）</strong>: 衝突時に二次関数に基づいて次のスロットを探す方法</li>
                <li><strong>ダブルハッシング（double hashing）</strong>: 2つのハッシュ関数を使用して次のスロットを決定する方法</li>
                <li><strong>リハッシュ（rehashing）</strong>: テーブルサイズを変更して全要素を再配置する処理</li>
            </ul>
            
            <h3>特徴</h3>
            <p>ハッシュ探索の主な特徴は以下の通りです：</p>
            <ul>
                <li>平均的なケースでO(1)の時間複雑性による高速な検索</li>
                <li>キーと値のペアの効率的な格納と取得</li>
                <li>ハッシュ関数の品質がパフォーマンスに大きく影響</li>
                <li>メモリ使用量と検索速度のトレードオフが可能</li>
                <li>衝突解決のための追加のメカニズムが必要</li>
                <li>キーの順序は保持されない（順序保存が必要な場合は工夫が必要）</li>
                <li>ロードファクターの増加に伴い性能が低下する</li>
                <li>動的なリサイズ（リハッシュ）によるパフォーマンスの維持</li>
                <li>多様なハッシュ関数の選択肢と適用可能性</li>
                <li>セキュリティ用途（暗号学的ハッシュ関数）としても応用可能</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>ハッシュ探索は以下のような場面で特に有用です：</p>
            <ul>
                <li>キーによる高速なデータ検索が必要な場合</li>
                <li>データベースのインデックス作成</li>
                <li>キャッシュ実装（LRUキャッシュなど）</li>
                <li>重複を排除する必要があるセット操作</li>
                <li>スペルチェッカーや辞書の実装</li>
                <li>シンボルテーブル（コンパイラやインタプリタ）</li>
                <li>ネットワークルーティングテーブル</li>
                <li>暗号化や認証メカニズム（パスワード保存など）</li>
                <li>頻度カウント（文字やワードの出現頻度など）</li>
                <li>大量のデータからの高速な検索や集計</li>
                <li>分散システムでのデータパーティショニング</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>ハッシュ探索アルゴリズムの基本的な手順は以下の通りです：</p>
            
            <h4>1. ハッシュテーブルの作成</h4>
            <ol>
                <li>適切なハッシュテーブルのサイズを決定する（通常は素数を選ぶことが多い）</li>
                <li>効率的なハッシュ関数を選択または実装する</li>
                <li>衝突解決方法（チェイニングまたはオープンアドレッシング）を選択する</li>
                <li>必要に応じてリハッシュの閾値となるロードファクターを設定する</li>
            </ol>
            
            <h4>2. 要素の挿入</h4>
            <ol>
                <li>キーからハッシュ値を計算する: index = hash(key) % table_size</li>
                <li>ハッシュ値に基づいてテーブル内の位置を特定する</li>
                <li>衝突が発生した場合は、選択した衝突解決方法に従って処理する:
                    <ul>
                        <li><strong>チェイニング</strong>: 同じインデックスの連結リストに新しい要素を追加する</li>
                        <li><strong>線形探査</strong>: (index + i) % table_size で次の空きスロットを探す</li>
                        <li><strong>二次探査</strong>: (index + i² + i) % table_size で次の空きスロットを探す</li>
                        <li><strong>ダブルハッシング</strong>: (index + i * hash2(key)) % table_size で次のスロットを探す</li>
                    </ul>
                </li>
                <li>適切な位置に要素を挿入する</li>
                <li>ロードファクターが閾値を超えた場合、テーブルサイズを拡大しリハッシュを行う</li>
            </ol>
            
            <h4>3. 要素の検索</h4>
            <ol>
                <li>検索キーからハッシュ値を計算する: index = hash(key) % table_size</li>
                <li>計算されたインデックスの位置を確認する</li>
                <li>衝突解決方法に応じて検索を続行する:
                    <ul>
                        <li><strong>チェイニング</strong>: そのインデックスの連結リストを順に探索する</li>
                        <li><strong>オープンアドレッシング</strong>: 挿入時と同じプロービング順序で要素を探す</li>
                    </ul>
                </li>
                <li>キーが一致する要素が見つかれば、関連する値を返す</li>
                <li>テーブル内にキーが存在しない場合は、存在しないことを示す結果を返す</li>
            </ol>
            
            <h4>4. 要素の削除</h4>
            <ol>
                <li>削除するキーからハッシュ値を計算する: index = hash(key) % table_size</li>
                <li>計算されたインデックスの位置を確認する</li>
                <li>衝突解決方法に応じて削除を行う:
                    <ul>
                        <li><strong>チェイニング</strong>: そのインデックスの連結リストから要素を削除する</li>
                        <li><strong>オープンアドレッシング</strong>: 要素を見つけたら、特別な「削除済み」マーカーで置き換える（単純に空にすると、後続の要素の検索に影響する）</li>
                    </ul>
                </li>
                <li>必要に応じて、テーブルサイズを縮小しリハッシュを行う</li>
            </ol>
            
            <h4>5. リハッシュ（テーブルのリサイズ）</h4>
            <ol>
                <li>新しいサイズのテーブルを作成する（通常は現在のサイズの約2倍）</li>
                <li>古いテーブルの全要素を順に取り出す</li>
                <li>各要素について、新しいテーブルサイズに基づいて再度ハッシュ値を計算する</li>
                <li>新しいハッシュ値に基づいて要素を新しいテーブルに挿入する</li>
                <li>古いテーブルを破棄し、新しいテーブルを使用する</li>
            </ol>
    
            <h3>計算量</h3>
            <p>ハッシュ探索の計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>挿入</strong>:
                    <ul>
                        <li>平均的なケース: O(1)</li>
                        <li>最悪のケース（多数の衝突）: O(n)</li>
                    </ul>
                </li>
                <li><strong>検索</strong>:
                    <ul>
                        <li>平均的なケース: O(1)</li>
                        <li>最悪のケース（多数の衝突）: O(n)</li>
                    </ul>
                </li>
                <li><strong>削除</strong>:
                    <ul>
                        <li>平均的なケース: O(1)</li>
                        <li>最悪のケース（多数の衝突）: O(n)</li>
                    </ul>
                </li>
                <li><strong>リハッシュ</strong>: O(n) - すべての要素を再挿入する必要がある</li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>チェイニングの場合</strong>: O(n) - n個の要素に加えて、衝突による連結リストのオーバーヘッド</li>
                <li><strong>オープンアドレッシングの場合</strong>: O(m) - mはテーブルサイズ（通常はn以上）</li>
            </ul>
            
            <p>ハッシュ探索のパフォーマンスは、使用するハッシュ関数の品質、テーブルサイズ、ロードファクター、衝突解決方法に大きく依存します。良いハッシュ関数は、キーを均等に分散させ、衝突を最小限に抑えることができます。</p>
            
            <p>ロードファクター（テーブル内の要素数/テーブルサイズ）が増加すると、衝突の可能性が高まり、パフォーマンスが低下します。一般的に、チェイニングでは0.75、オープンアドレッシングでは0.5を超えるとリハッシュを行うことが推奨されています。</p>
            
            <p>最適なハッシュテーブルの設計では、ハッシュ関数の選択、初期テーブルサイズ、リハッシュ戦略、衝突解決方法のトレードオフを考慮する必要があります。適切に設計されたハッシュテーブルは、大規模なデータセットでも効率的な検索、挿入、削除操作を可能にします。</p>
        </div>
    </div>
</body>
</html>