<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二分探索 (Binary Search)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">配列の検索問題</a></li>
        <li>二分探索</li>
    </ul>

    <div class="container">
        <h1>二分探索 (Binary Search)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>二分探索は、ソート済みの配列から目的の値を効率的に検索するアルゴリズムです。各ステップで探索範囲を半分に絞り込むことにより、線形探索よりも大幅に高速に動作します。特に大規模なデータセットに対して効果的で、多くの高性能アルゴリズムの基礎となっています。</p>
            
            <h3>基礎知識</h3>
            <p>二分探索はソート済みの配列に対してのみ適用可能なアルゴリズムです。ソートされていることを前提に、配列の中央の要素と検索対象の値を比較し、その結果に基づいて検索範囲を半分に絞り込む処理を繰り返します。</p>
            <p>このアルゴリズムは「分割統治法（Divide and Conquer）」の考え方に基づいており、各ステップで問題のサイズを半分に縮小することで、効率的に解を見つけます。二分探索の最大の強みは、データ量が多くなるほど線形探索との性能差が顕著になることです。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ソート済み配列（sorted array）</strong>: 要素が特定の順序（通常は昇順）で並べられた配列</li>
                <li><strong>探索範囲（search space）</strong>: 現在探索の対象となっている配列の部分範囲</li>
                <li><strong>中央値（mid value）</strong>: 現在の探索範囲の中央に位置する要素</li>
                <li><strong>下限インデックス（lower bound）</strong>: 探索範囲の開始インデックス</li>
                <li><strong>上限インデックス（upper bound）</strong>: 探索範囲の終了インデックス</li>
                <li><strong>分割統治法（divide and conquer）</strong>: 問題を小さな部分問題に分割して解決するアプローチ</li>
                <li><strong>収束（convergence）</strong>: アルゴリズムが解に到達していく過程</li>
                <li><strong>対数時間（logarithmic time）</strong>: 入力サイズの対数に比例する実行時間</li>
            </ul>
            
            <h3>特徴</h3>
            <p>二分探索の主な特徴は以下の通りです：</p>
            <ul>
                <li>ソート済みの配列に対してのみ適用可能</li>
                <li>各ステップで探索範囲が半分に縮小される</li>
                <li>対数時間（O(log n)）の計算量を持つ</li>
                <li>再帰的あるいは反復的に実装可能</li>
                <li>比較回数が最小限に抑えられる効率的なアルゴリズム</li>
                <li>インデックス計算のオーバーフローに注意が必要</li>
                <li>データ量が多いほど線形探索との性能差が顕著になる</li>
                <li>「存在確認」だけでなく「挿入位置の特定」にも利用可能</li>
                <li>配列だけでなく、ソート済みの他のデータ構造にも応用可能</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>二分探索は以下のような場面で特に有用です：</p>
            <ul>
                <li>大規模なソート済みデータからの高速検索</li>
                <li>辞書やデータベースなどのインデックス付きデータ構造の検索メカニズム</li>
                <li>数値計算における根の近似解の探索（二分法）</li>
                <li>ソート済み配列における要素の存在確認</li>
                <li>ソート済み配列における新要素の挿入位置の特定</li>
                <li>キャッシュなどの高速ルックアップメカニズム</li>
                <li>探索空間を効率的に絞り込む必要がある最適化問題</li>
                <li>回転ソート配列（一部が循環的にシフトされたソート配列）での検索</li>
                <li>ソート済み配列における最初または最後の出現位置の特定（lower_bound/upper_bound）</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>二分探索の基本的な手順は以下の通りです：</p>
            
            <h4>1. 初期化</h4>
            <ol>
                <li>ソート済み配列と検索対象の値を準備する</li>
                <li>探索範囲の下限（left）を配列の最初のインデックス（通常は0）に設定する</li>
                <li>探索範囲の上限（right）を配列の最後のインデックス（通常はn-1）に設定する</li>
            </ol>
            
            <h4>2. 探索ループ</h4>
            <ol>
                <li>下限が上限を超えるまで以下の処理を繰り返す：
                    <ul>
                        <li>中央インデックス（mid）を計算する：mid = left + (right - left) / 2</li>
                        <li>中央要素（array[mid]）と検索対象の値を比較する</li>
                        <li>中央要素が検索対象と一致する場合：
                            <ul>
                                <li>検索成功、中央インデックスを結果として返す</li>
                            </ul>
                        </li>
                        <li>中央要素が検索対象より小さい場合：
                            <ul>
                                <li>探索範囲を右半分に更新：left = mid + 1</li>
                            </ul>
                        </li>
                        <li>中央要素が検索対象より大きい場合：
                            <ul>
                                <li>探索範囲を左半分に更新：right = mid - 1</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ol>
            
            <h4>3. 結果の返却</h4>
            <ol>
                <li>ループが終了し、検索対象が見つからなかった場合（left > right）：
                    <ul>
                        <li>検索失敗を示す値（多くの場合は-1）を返す</li>
                    </ul>
                </li>
            </ol>
            
            <h4>二分探索の変種: 最初の出現位置の特定（lower_bound）</h4>
            <ol>
                <li>初期化（通常の二分探索と同様）</li>
                <li>下限が上限以下である間、以下を繰り返す：
                    <ul>
                        <li>中央インデックス（mid）を計算する</li>
                        <li>中央要素が検索対象より小さい場合：left = mid + 1</li>
                        <li>中央要素が検索対象以上の場合：
                            <ul>
                                <li>結果を現在の中央インデックスとして更新</li>
                                <li>探索範囲を左半分に更新：right = mid - 1</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>検索対象以上の最初の要素のインデックスを返す</li>
            </ol>
            
            <h4>二分探索の変種: 最後の出現位置の特定（upper_bound）</h4>
            <ol>
                <li>初期化（通常の二分探索と同様）</li>
                <li>下限が上限以下である間、以下を繰り返す：
                    <ul>
                        <li>中央インデックス（mid）を計算する</li>
                        <li>中央要素が検索対象以下の場合：left = mid + 1</li>
                        <li>中央要素が検索対象より大きい場合：
                            <ul>
                                <li>結果を現在の中央インデックスとして更新</li>
                                <li>探索範囲を左半分に更新：right = mid - 1</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>検索対象より大きい最初の要素のインデックスを返す</li>
            </ol>
    
            <h3>計算量</h3>
            <p>二分探索アルゴリズムの計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>最良の場合</strong>: O(1) - 最初の比較で検索対象が見つかる場合</li>
                <li><strong>平均の場合</strong>: O(log n) - 各ステップで探索範囲が半分になるため</li>
                <li><strong>最悪の場合</strong>: O(log n) - 検索対象が配列に存在しないか、最後の比較で見つかる場合</li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>反復実装</strong>: O(1) - 定数個の変数のみを使用</li>
                <li><strong>再帰実装</strong>: O(log n) - 再帰呼び出しのスタックフレーム</li>
            </ul>
            
            <p>二分探索の最大の強みは、O(log n)の時間計算量です。これは、入力サイズが2倍になると、必要な操作ステップが1ステップ増えるだけということを意味します。例えば、1,000個の要素を含む配列で約10回の比較、1,000,000個の要素を含む配列でも約20回の比較で目的の値を見つけることができます。</p>
            
            <p>この対数時間の特性により、二分探索は特に大規模なデータセットに対して非常に効率的です。線形探索のO(n)と比較すると、データ量が増加するほど性能差は顕著になります。例えば、10億個の要素を含む配列に対して、線形探索では最悪10億回の比較が必要になりますが、二分探索では約30回の比較で結果を得ることができます。</p>
            
            <p>ただし、二分探索はソート済みの配列を前提としている点に注意が必要です。未ソートの配列に対しては、ソートのコストを考慮する必要があります。配列のソートには少なくともO(n log n)の計算量が必要であるため、1回きりの検索のためだけに未ソート配列をソートして二分探索を適用するのは非効率です。頻繁に検索操作を行う場合や、配列が既にソートされている場合に二分探索の真価が発揮されます。</p>
        </div>
    </div>
</body>
</html>