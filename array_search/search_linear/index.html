<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>線形探索 (Linear Search)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">配列の検索問題</a></li>
        <li>線形探索</li>
    </ul>
    <div class="container">
        <h1>線形探索 (Linear Search)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>線形探索（Linear Search）は、配列やリストなどのデータ構造内で特定の値を検索するための最も単純なアルゴリズムです。配列の先頭から順番に各要素を調べていき、目的の値と一致する要素が見つかるまで、または配列の末尾に達するまで探索を続けます。シンプルで直感的なアプローチであり、事前にデータをソートする必要がないため、どのようなデータ集合に対しても適用できます。</p>
            
            <h3>基礎知識</h3>
            <p>線形探索は、配列内の各要素を順番に調べていくシーケンシャル（逐次的）なアプローチを取ります。探索対象の値と各要素を比較し、一致が見つかった時点で探索を終了します。一致する要素が見つからない場合は、配列全体を走査した後に「見つからなかった」という結果を返します。</p>
            <p>線形探索の最大の特徴は、その単純さと実装の容易さです。また、データがソートされていなくても使用できる点も重要な特徴です。しかし、大規模なデータセットでは効率が低下するため、ソート済みデータに対しては二分探索などのより効率的なアルゴリズムが好まれます。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>探索キー（search key）</strong>: 配列内で探したい値</li>
                <li><strong>ターゲット（target）</strong>: 探索対象の値</li>
                <li><strong>インデックス（index）</strong>: 配列内での要素の位置を示す数値</li>
                <li><strong>シーケンシャルサーチ（sequential search）</strong>: 線形探索の別名</li>
                <li><strong>逐次探索（sequential search）</strong>: 線形探索の別名</li>
                <li><strong>一致（match）</strong>: 探索キーと配列要素の値が等しい状態</li>
                <li><strong>最悪ケース（worst case）</strong>: 探索対象が配列内に存在せず、全要素を調べる必要がある場合</li>
                <li><strong>早期終了（early termination）</strong>: 一致が見つかった時点で探索を終了すること</li>
                <li><strong>番兵法（sentinel method）</strong>: 探索終了条件のチェックを減らすための最適化手法</li>
            </ul>
            
            <h3>特徴</h3>
            <p>線形探索の主な特徴は以下の通りです：</p>
            <ul>
                <li>シンプルで理解しやすく、実装が容易</li>
                <li>追加のメモリ空間をほとんど必要としない（in-placeアルゴリズム）</li>
                <li>データのソートが不要</li>
                <li>小さな配列やリストに対して効率的</li>
                <li>配列やリンクリストなど、様々なデータ構造に適用可能</li>
                <li>一致する要素が見つかった時点で処理を終了できる（早期終了）</li>
                <li>最悪の場合、配列内のすべての要素を調べる必要がある</li>
                <li>安定した探索アルゴリズム（同じ値を持つ複数の要素がある場合、最初に出現するものが返される）</li>
                <li>不連続なメモリアクセスパターンを持つデータ構造（連結リストなど）でも使用可能</li>
                <li>複雑なデータ構造や条件付き探索にも容易に拡張できる</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>線形探索は以下のような場面で特に有用です：</p>
            <ul>
                <li>小規模な配列やリストでの探索（要素数が少ない場合）</li>
                <li>未ソートのデータコレクションでの探索</li>
                <li>一度だけ探索を行う場合（ソートのオーバーヘッドを避けたい場合）</li>
                <li>探索操作が頻繁に行われない場合</li>
                <li>データが頻繁に更新され、ソート状態を維持するコストが高い場合</li>
                <li>複雑な条件に基づく要素の探索（単純な値の比較だけでなく、条件関数を使用）</li>
                <li>連結リストなど、ランダムアクセスが効率的でないデータ構造での探索</li>
                <li>探索キーが配列の先頭付近に存在する可能性が高い場合</li>
                <li>部分的にソートされているデータや、特定のパターンを持つデータでの探索</li>
                <li>ハードウェアの制約がある環境や、単純なアルゴリズムが好ましい場合</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>線形探索アルゴリズムの基本的な手順は以下の通りです：</p>
            
            <h4>基本的な線形探索</h4>
            <ol>
                <li>配列と探索対象の値（探索キー）を入力として受け取る</li>
                <li>配列の先頭（インデックス0）から開始する</li>
                <li>以下の処理を配列の末尾に達するまで繰り返す：
                    <ul>
                        <li>現在の要素と探索キーを比較する</li>
                        <li>一致する場合、現在のインデックスを返して探索を終了する</li>
                        <li>一致しない場合、次の要素（インデックス+1）に移動する</li>
                    </ul>
                </li>
                <li>配列の末尾まで探索して一致する要素が見つからなかった場合、「見つからなかった」ことを示す値（通常は-1や特殊な値）を返す</li>
            </ol>
            
            <h4>番兵法を用いた最適化（オプション）</h4>
            <ol>
                <li>配列の末尾に一時的に探索キーを追加する（これが「番兵」となる）</li>
                <li>インデックス0から開始し、以下の処理を繰り返す：
                    <ul>
                        <li>現在の要素と探索キーを比較する</li>
                        <li>一致する場合、ループを終了する</li>
                        <li>一致しない場合、次の要素に移動する</li>
                    </ul>
                </li>
                <li>ループ終了後、現在のインデックスが元の配列の長さよりも小さい場合は、そのインデックスを返す（要素が見つかった）</li>
                <li>そうでない場合は、「見つからなかった」ことを示す値を返す（番兵に到達した）</li>
                <li>番兵を削除して配列を元の状態に戻す</li>
            </ol>
            
            <h4>複数の一致を見つける場合（すべての出現を検索）</h4>
            <ol>
                <li>一致するインデックスを格納するための空のリストを初期化する</li>
                <li>配列の先頭から末尾まで以下の処理を繰り返す：
                    <ul>
                        <li>現在の要素と探索キーを比較する</li>
                        <li>一致する場合、現在のインデックスをリストに追加する</li>
                        <li>次の要素に移動する（早期終了せず、すべての要素を確認）</li>
                    </ul>
                </li>
                <li>探索が完了したら、一致するインデックスのリストを返す（空のリストは「見つからなかった」ことを示す）</li>
            </ol>
            
            <h4>条件付き線形探索（述語関数を使用）</h4>
            <ol>
                <li>配列と条件（述語関数）を入力として受け取る</li>
                <li>配列の先頭から末尾まで以下の処理を繰り返す：
                    <ul>
                        <li>現在の要素に対して条件関数を適用する</li>
                        <li>条件を満たす場合、現在のインデックスを返して探索を終了する</li>
                        <li>条件を満たさない場合、次の要素に移動する</li>
                    </ul>
                </li>
                <li>条件を満たす要素が見つからなかった場合、「見つからなかった」ことを示す値を返す</li>
            </ol>
    
            <h3>計算量</h3>
            <p>線形探索の計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>最良の場合（Best Case）</strong>: O(1) - 探索対象が配列の最初の要素である場合</li>
                <li><strong>平均的な場合（Average Case）</strong>: O(n/2) = O(n) - 探索対象がどの位置にも等確率で存在する場合、平均して半分の要素を調べる</li>
                <li><strong>最悪の場合（Worst Case）</strong>: O(n) - 探索対象が配列の最後の要素であるか、配列内に存在しない場合</li>
                <li><strong>すべての出現を探す場合</strong>: O(n) - 常に配列全体を走査する必要がある</li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>基本的な線形探索</strong>: O(1) - 追加のメモリ空間をほとんど使用しない</li>
                <li><strong>すべての出現を格納する場合</strong>: O(k) (kは一致する要素の数) - 最悪の場合O(n)</li>
                <li><strong>番兵法</strong>: O(1) - 配列に一時的に要素を追加するが、定数空間</li>
            </ul>
            
            <p>線形探索の主な利点は、実装が単純であること、ソートされていないデータに適用できること、そして早期終了により最良の場合はO(1)の時間で結果を返せることです。また、小さな配列では、より複雑なアルゴリズムのオーバーヘッドを考慮すると、実際には線形探索の方が効率的な場合もあります。</p>
            
            <p>一方、主な欠点は大きなデータセットでの効率の悪さです。配列のサイズが増加するにつれて、線形探索の性能は比例して低下します。ソート済みのデータに対しては、二分探索（O(log n)）などのより効率的なアルゴリズムが優れています。</p>
            
            <p>実際の応用では、データの性質や検索頻度、配列のサイズなどを考慮して、線形探索を使用するか、より高度なアルゴリズムを採用するかを決定する必要があります。少数の要素を持つ配列や、一度だけ探索を行う場合、あるいはハードウェアの制約がある環境では、線形探索が最適な選択肢となることがあります。</p>
        </div>
    </div>
</body>
</html>