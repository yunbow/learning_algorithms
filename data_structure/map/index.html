<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>マップ (Map)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">データ構造の問題</a></li>
        <li>マップ</li>
    </ul>
    <div class="container">
        <h1>マップ (Map)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>マップ（Map）は、キーと値のペアを格納するデータ構造で、キーを使って効率的に値を検索、挿入、削除できるように設計されています。キーと値の関連付けにより、辞書のように機能し、多くのプログラミング言語で基本的なデータ構造として実装されています。</p>
            
            <h3>基礎知識</h3>
            <p>マップは「連想配列」「辞書」「ハッシュマップ」などとも呼ばれ、キーを使って値を迅速に検索できる点が特徴です。マップの実装方法にはハッシュテーブルや平衡二分探索木（赤黒木、AVL木など）があり、それぞれ異なる特性と性能特性を持っています。</p>
            <p>マップの重要な特性は、各キーが一意であることです。同じキーで新しい値を格納すると、以前の値は上書きされます。これにより、特定のキーに対する値を一意に特定できます。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>キー（Key）</strong>: マップ内の値を識別するための一意の識別子</li>
                <li><strong>値（Value）</strong>: キーに関連付けられた実際のデータ</li>
                <li><strong>キー・値ペア（Key-Value Pair）</strong>: マップの基本単位となるキーと値の組み合わせ</li>
                <li><strong>ハッシュ関数（Hash Function）</strong>: キーを固定長の値（ハッシュ値）に変換する関数</li>
                <li><strong>衝突（Collision）</strong>: 異なるキーが同じハッシュ値を生成する現象</li>
                <li><strong>ロードファクター（Load Factor）</strong>: ハッシュマップの容量に対する使用率</li>
                <li><strong>バケット（Bucket）</strong>: ハッシュマップ内で同じハッシュ値を持つエントリを格納する場所</li>
                <li><strong>イテレーター（Iterator）</strong>: マップの要素を順番に処理するためのオブジェクト</li>
            </ul>
            
            <h3>特徴</h3>
            <p>マップの主な特徴は以下の通りです：</p>
            <ul>
                <li>キーによる高速なデータアクセス（理想的には定数時間）</li>
                <li>キーの一意性による重複排除</li>
                <li>動的なサイズ変更（多くの実装で自動的に拡張）</li>
                <li>様々なデータ型をキーとして使用可能（実装による）</li>
                <li>メモリ効率と検索効率のバランス</li>
                <li>順序付けに関する性質（実装によっては順序を保持、しないものもある）</li>
                <li>キーと値の関連付けによる直感的なデータモデリング</li>
                <li>複雑なデータ構造構築の基盤として活用可能</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>マップは以下のような場面で特に有用です：</p>
            <ul>
                <li>データベースのインデックス作成</li>
                <li>キャッシュの実装</li>
                <li>スペルチェックや辞書の実装</li>
                <li>頻度カウント（単語出現回数など）</li>
                <li>グラフアルゴリズムでの訪問済みノードの追跡</li>
                <li>構成設定の保存と取得</li>
                <li>オブジェクトの属性検索</li>
                <li>シンボルテーブル（コンパイラやインタプリタで使用）</li>
                <li>ネットワークルーティングテーブル</li>
                <li>重複排除が必要なデータ処理</li>
                <li>メモ化（動的プログラミングの一種）</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>マップの基本的な操作とその手順は実装方法によって異なりますが、一般的なハッシュマップの場合、以下のような手順で動作します：</p>
            
            <h4>1. 挿入操作（Insert/Put）</h4>
            <ol>
                <li>キーをハッシュ関数に渡してハッシュ値を計算する</li>
                <li>ハッシュ値をマップの配列サイズで割った余りをインデックスとして使用する</li>
                <li>そのインデックスが空いていれば、キーと値のペアを格納する</li>
                <li>すでに要素がある場合（衝突）：
                    <ul>
                        <li>チェイニング法：リンクリストに新しいペアを追加</li>
                        <li>オープンアドレス法：次の空き場所を決定するための探索を行う</li>
                    </ul>
                </li>
                <li>必要に応じてマップのサイズを拡張し、全要素を再ハッシュする</li>
            </ol>
            
            <h4>2. 検索操作（Search/Get）</h4>
            <ol>
                <li>キーをハッシュ関数に渡してハッシュ値を計算する</li>
                <li>ハッシュ値をマップの配列サイズで割った余りをインデックスとして使用する</li>
                <li>そのインデックスを調べ、目的のキーを持つペアを探す：
                    <ul>
                        <li>チェイニング法：リンクリストをたどり、キーが一致するペアを探す</li>
                        <li>オープンアドレス法：キーが一致するまで、または空の位置に到達するまで探索を続ける</li>
                    </ul>
                </li>
                <li>キーが見つかれば関連する値を返し、見つからなければ未定義値または例外を返す</li>
            </ol>
            
            <h4>3. 削除操作（Delete/Remove）</h4>
            <ol>
                <li>キーをハッシュ関数に渡してハッシュ値を計算する</li>
                <li>ハッシュ値をマップの配列サイズで割った余りをインデックスとして使用する</li>
                <li>そのインデックスを調べ、目的のキーを持つペアを探す</li>
                <li>キーが見つかれば、その要素を削除する：
                    <ul>
                        <li>チェイニング法：リンクリストからノードを削除</li>
                        <li>オープンアドレス法：特別な削除マーカーを設定し、将来の検索に影響を与えないようにする</li>
                    </ul>
                </li>
            </ol>
            
            <h4>具体例: 文字列をキーとした単語頻度カウント</h4>
            <p>例えば「hello world hello」という文字列の単語頻度をカウントする場合：</p>
            <ol>
                <li>"hello"をハッシュ関数でハッシュ値に変換し、適切なインデックスを計算</li>
                <li>マップが空なので、"hello"をキー、1を値として格納</li>
                <li>"world"についても同様に処理し、別のインデックスに格納</li>
                <li>再度"hello"が出現した場合、既存のキーを見つけ、値を1から2に更新</li>
            </ol>
            <p>結果として、{"hello": 2, "world": 1}というマップが得られます。</p>
            
            <h3>計算量</h3>
            <p>マップの計算量は実装方法によって異なりますが、一般的なケースでは：</p>
            
            <h4>ハッシュマップ実装</h4>
            <ul>
                <li><strong>平均時間計算量</strong>:
                    <ul>
                        <li>検索操作: O(1) - 理想的な状況では定数時間</li>
                        <li>挿入操作: O(1)</li>
                        <li>削除操作: O(1)</li>
                    </ul>
                </li>
                <li><strong>最悪時間計算量</strong>:
                    <ul>
                        <li>全ての操作: O(n) - 全てのキーが同じハッシュ値を持つ場合</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(n) - n個の要素を格納するためのスペース</li>
            </ul>
            
            <h4>平衡二分探索木実装（TreeMap）</h4>
            <ul>
                <li><strong>時間計算量</strong>:
                    <ul>
                        <li>検索操作: O(log n)</li>
                        <li>挿入操作: O(log n)</li>
                        <li>削除操作: O(log n)</li>
                        <li>順序付き走査: O(n) - キーでソートされた順にアクセス可能</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(n)</li>
            </ul>
            
            <p>ハッシュマップの性能は、良いハッシュ関数の選択、適切なバケットサイズ、効果的な衝突解決戦略によって大きく左右されます。ロードファクター（使用率）が高くなるとパフォーマンスが低下するため、多くの実装では自動的にサイズを調整してパフォーマンスを維持します。</p>
            
            <p>一方、平衡木ベースのマップ実装は、キーの順序関係を活用した走査や範囲クエリが必要な場合に有用です。常に対数時間の性能を保証しますが、ハッシュマップよりは平均的に遅くなります。</p>
            
            <p>アプリケーションの要件（順序保存の必要性、キーの分布、予想される操作頻度など）に応じて、適切なマップ実装を選択することが重要です。</p>
        </div>
    </div>
</body>
</html>