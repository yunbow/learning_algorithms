<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ヒープ (Heap)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">データ構造の問題</a></li>
        <li>ヒープ (Heap)</li>
    </ul>
    <div class="container">
        <h1>ヒープ  (Heap)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>ヒープは、最大値または最小値への効率的なアクセスを可能にする特殊な完全二分木構造です。1964年にJ.W.J.ウィリアムズによって最初に記述され、データ構造の分野において重要な位置を占めています。このデータ構造は単純さと効率性を兼ね備え、優先度付きキューの実装やヒープソートなどで広く使用されています。</p>
            
            <h3>基礎知識</h3>
            <p>ヒープには主に2種類あります：最大ヒープと最小ヒープです。最大ヒープでは、親ノードは常に子ノード以上の値を持ち、根ノードが最大値となります。最小ヒープでは逆に、親ノードは常に子ノード以下の値を持ち、根ノードが最小値となります。</p>
            <p>ヒープは完全二分木として表現され、通常は配列を使用して実装されます。この表現では、インデックスiのノードに対して、左の子は2i+1、右の子は2i+2、親は⌊(i-1)/2⌋のインデックスに位置します（0ベースのインデックスを使用した場合）。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>二分ヒープ（Binary Heap）</strong>: 最もよく使われるヒープの形式で、各ノードが最大2つの子を持つ完全二分木</li>
                <li><strong>最大ヒープ（Max Heap）</strong>: すべての親ノードが子ノード以上の値を持つヒープ</li>
                <li><strong>最小ヒープ（Min Heap）</strong>: すべての親ノードが子ノード以下の値を持つヒープ</li>
                <li><strong>ヒープ性質（Heap Property）</strong>: 各ノードが特定の順序関係（最大または最小）を満たす性質</li>
                <li><strong>完全二分木（Complete Binary Tree）</strong>: 最後のレベルを除くすべてのレベルが完全に満たされ、最後のレベルは左から右へ詰められた二分木</li>
                <li><strong>浮上（Heapify-up/Bubble-up）</strong>: 新しく挿入されたノードをヒープ性質を満たす位置まで上に移動させる操作</li>
                <li><strong>沈降（Heapify-down/Bubble-down）</strong>: 根から取り出した後、最後のノードを根に移動させ、ヒープ性質を再構築する操作</li>
            </ul>
            
            <h3>特徴</h3>
            <p>ヒープの主な特徴は以下の通りです：</p>
            <ul>
                <li>最大値（または最小値）への定数時間でのアクセス（O(1)）</li>
                <li>挿入と削除の対数時間での処理（O(log n)）</li>
                <li>配列による効率的なメモリ表現</li>
                <li>自己バランス型のデータ構造（操作後も常にヒープ性質を維持）</li>
                <li>親子間の順序関係のみを保証（兄弟ノード間の順序は保証されない）</li>
                <li>任意の要素の検索は効率的ではない（O(n)）</li>
                <li>優先度付きキューや並べ替えアルゴリズムの基盤として使用可能</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>ヒープは以下のような場面で特に有用です：</p>
            <ul>
                <li>優先度付きキューの実装</li>
                <li>ヒープソートアルゴリズム</li>
                <li>ダイクストラのアルゴリズムなどの最短経路問題</li>
                <li>プリム法やクラスカル法などの最小全域木アルゴリズム</li>
                <li>メディアンや上位k個の要素を高速に見つける問題</li>
                <li>メモリ管理（特にバディシステム）</li>
                <li>ハフマン符号化アルゴリズム</li>
                <li>イベント駆動型シミュレーション</li>
                <li>グラフアルゴリズムの多くの応用</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>ヒープの基本操作には、要素の挿入、最大/最小要素の取得、最大/最小要素の削除があります。以下では最大ヒープの場合の手順を説明します：</p>
            
            <h4>要素の挿入（Insert）</h4>
            <ol>
                <li>新しい要素を配列の最後に追加する</li>
                <li>この新しい要素を親と比較し、ヒープ性質を満たすまで上方向に移動させる（浮上/Heapify-up）：
                    <ol>
                        <li>親ノードのインデックスを計算する</li>
                        <li>親の値が新しい要素の値より小さい場合、両者を交換する</li>
                        <li>新しい要素が根に到達するか、親の値が新しい要素の値以上になるまで繰り返す</li>
                    </ol>
                </li>
            </ol>
            
            <h4>最大要素の取得（Get-Max）</h4>
            <ol>
                <li>配列の先頭要素（インデックス0）を返す</li>
            </ol>
            
            <h4>最大要素の削除（Extract-Max）</h4>
            <ol>
                <li>配列の先頭要素（最大値）を保存する</li>
                <li>配列の最後の要素を取り出し、それを根の位置（インデックス0）に移動する</li>
                <li>配列のサイズを1減らす</li>
                <li>新しい根を適切な位置まで下方向に移動させる（沈降/Heapify-down）：
                    <ol>
                        <li>現在のノードと左右の子ノードのうち最大のものを見つける</li>
                        <li>現在のノードが最大でない場合、最大の子と交換する</li>
                        <li>交換が発生しなくなるか、葉ノードに到達するまで繰り返す</li>
                    </ol>
                </li>
                <li>最初に保存した最大値を返す</li>
            </ol>
            
            <h4>ヒープの構築（Build-Heap）</h4>
            <ol>
                <li>n個の要素を持つ配列を考える</li>
                <li>最後の非葉ノード（インデックス⌊n/2⌋-1）から根ノードに向かって、各ノードに対してHeapify-down操作を適用する</li>
            </ol>
            
            <h4>具体例: [4, 10, 3, 5, 1]から最大ヒープを構築する場合</h4>
            <ol>
                <li>最後の非葉ノードのインデックスは⌊5/2⌋-1 = 1</li>
                <li>インデックス1（値10）からHeapify-down：
                    <ul>
                        <li>左子は5、右子は1、10が最大なので交換なし</li>
                    </ul>
                </li>
                <li>インデックス0（値4）からHeapify-down：
                    <ul>
                        <li>左子は10、右子は3、10が最大なので4と10を交換</li>
                        <li>新しい状態: [10, 4, 3, 5, 1]</li>
                        <li>さらに4について確認: 左子は5、右子は1、5が最大なので4と5を交換</li>
                        <li>最終状態: [10, 5, 3, 4, 1]</li>
                    </ul>
                </li>
            </ol>
            
            <h3>計算量</h3>
            <p>ヒープ操作の計算量は以下の通りです：</p>
            <ul>
                <li><strong>要素の挿入（Insert）</strong>: O(log n) - 最悪の場合、新しい要素が根まで浮上する</li>
                <li><strong>最大/最小要素の取得（Get-Max/Min）</strong>: O(1) - 常に配列の先頭</li>
                <li><strong>最大/最小要素の削除（Extract-Max/Min）</strong>: O(log n) - 最悪の場合、新しい根が葉まで沈降する</li>
                <li><strong>ヒープの構築（Build-Heap）</strong>: O(n) - 直感的には O(n log n) に見えるが、より厳密な解析により線形時間であることが証明されている</li>
                <li><strong>任意の要素の検索</strong>: O(n) - ヒープは検索に最適化されていない</li>
                <li><strong>空間計算量</strong>: O(n) - n個の要素を格納するための配列</li>
            </ul>
            
            <p>ヒープソートの計算量は、ヒープの構築に O(n) の時間がかかり、その後 n 回の要素抽出（各 O(log n)）を行うため、全体で O(n log n) となります。</p>
            
            <p>ヒープの効率性は、優先度付きキューの実装や、上位k個の要素を保持する必要があるアルゴリズムにおいて特に価値があります。また、ヒープソートはインプレースでの並べ替えが可能で、安定ではないものの、最悪の場合でも O(n log n) の計算量を保証します。</p>
        </div>
    </div>
</body>
</html>