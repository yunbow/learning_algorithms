<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>配列 (Array)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">データ構造の問題</a></li>
        <li>配列</li>
    </ul>

    <div class="container">
        <h1>配列 (Array)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>配列はコンピュータサイエンスにおける最も基本的かつ広く使用されているデータ構造の一つです。同じデータ型の要素を連続したメモリ領域に格納し、インデックスを使って各要素に直接アクセスできるようにします。配列は多くのプログラミング言語で基本的なデータ構造として組み込まれており、様々なアルゴリズムやデータ処理の基盤となっています。</p>
            
            <h3>基礎知識</h3>
            <p>配列は固定サイズの連続したメモリブロックに同じデータ型の要素を格納するデータ構造です。各要素は0から始まるインデックス（添え字）によって識別され、このインデックスを使って要素へ定数時間でアクセスできます。</p>
            <p>配列の主要な特性は、要素へのランダムアクセスが可能であることと、メモリ効率が良いことです。ただし、サイズが固定であるため、要素の挿入や削除には追加の操作やメモリの再割り当てが必要になる場合があります。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>インデックス（index）</strong>: 配列内の位置を特定するための数値（通常0から始まる）</li>
                <li><strong>要素（element）</strong>: 配列に格納される個々のデータ項目</li>
                <li><strong>長さ/サイズ（length/size）</strong>: 配列に格納できる要素の総数</li>
                <li><strong>多次元配列（multidimensional array）</strong>: 配列の各要素がさらに配列である構造（行列など）</li>
                <li><strong>動的配列（dynamic array）</strong>: サイズが動的に調整可能な配列の実装</li>
                <li><strong>境界チェック（bounds checking）</strong>: インデックスが有効範囲内にあるかの検証</li>
                <li><strong>トラバーサル（traversal）</strong>: 配列の全要素を順番に処理すること</li>
            </ul>
            
            <h3>特徴</h3>
            <p>配列の主な特徴は以下の通りです：</p>
            <ul>
                <li>固定サイズのメモリ割り当て（言語によっては動的サイズも可能）</li>
                <li>連続したメモリ領域への格納による優れたメモリ局所性</li>
                <li>インデックスによる要素への直接アクセス（O(1)の時間複雑性）</li>
                <li>同一データ型のみを格納可能（多くの言語の場合）</li>
                <li>多次元配列による複雑なデータ表現が可能</li>
                <li>カウントソート、基数ソートなどの一部のアルゴリズムの基盤</li>
                <li>メモリ効率が良く、オーバーヘッドが少ない</li>
                <li>キャッシュに優しい連続したメモリアクセスパターン</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>配列は以下のような場面で特に有用です：</p>
            <ul>
                <li>要素の順序が重要な場合（例：ソートされたデータ）</li>
                <li>インデックスによる高速アクセスが必要な場合</li>
                <li>サイズが事前に分かっているデータコレクション</li>
                <li>行列演算や多次元データ処理（画像処理など）</li>
                <li>スタックやキューなど他のデータ構造の実装基盤</li>
                <li>ルックアップテーブルやバッファの実装</li>
                <li>リストやセットなどより高レベルなデータ構造の基盤</li>
                <li>数値計算や統計処理における大量のデータ処理</li>
                <li>テーブル形式のデータの格納（二次元配列）</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>配列に対する基本的な操作とその手順は以下の通りです：</p>
            
            <h4>1. 配列の宣言と初期化</h4>
            <ol>
                <li>配列のデータ型を決定する</li>
                <li>配列のサイズ（要素数）を決定する</li>
                <li>必要に応じて初期値を設定する</li>
            </ol>
            
            <h4>2. 要素へのアクセス（読み取り/書き込み）</h4>
            <ol>
                <li>アクセスしたい要素のインデックスを特定する</li>
                <li>インデックスが配列の有効範囲内であることを確認する（境界チェック）</li>
                <li>インデックスを使用して要素にアクセスする</li>
            </ol>
            
            <h4>3. 配列の走査（トラバーサル）</h4>
            <ol>
                <li>インデックス変数を初期化する（通常は0から開始）</li>
                <li>インデックスが配列の長さより小さい間、以下を繰り返す：
                    <ul>
                        <li>現在のインデックスの要素に対して操作を実行する</li>
                        <li>インデックスをインクリメントする</li>
                    </ul>
                </li>
            </ol>
            
            <h4>4. 要素の検索</h4>
            <ol>
                <li>配列の先頭から開始する</li>
                <li>各要素を順に調べ、目的の値と比較する</li>
                <li>一致する要素が見つかればそのインデックスを返す</li>
                <li>配列の末尾まで検索して見つからない場合は、見つからなかったことを示す値を返す</li>
            </ol>
            
            <h4>5. 動的配列での要素の挿入</h4>
            <ol>
                <li>挿入位置を決定する</li>
                <li>配列の容量が足りない場合は、より大きなメモリ領域を確保する</li>
                <li>挿入位置より後ろの要素を1つずつ後方にシフトする</li>
                <li>指定された位置に新しい要素を挿入する</li>
                <li>配列のサイズカウンタを更新する</li>
            </ol>
            
            <h4>6. 動的配列での要素の削除</h4>
            <ol>
                <li>削除する要素の位置を特定する</li>
                <li>削除位置より後ろの要素を1つずつ前方にシフトして隙間を埋める</li>
                <li>配列のサイズカウンタを更新する</li>
                <li>必要に応じて、メモリ使用量を減らすために配列のサイズを縮小する</li>
            </ol>
    
            <h3>計算量</h3>
            <p>配列操作の計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>アクセス（読み取り/書き込み）</strong>: O(1) - インデックスを使った直接アクセス</li>
                <li><strong>探索（未ソート配列）</strong>: O(n) - 最悪の場合、全要素を確認する必要がある</li>
                <li><strong>探索（ソート済み配列・二分探索使用時）</strong>: O(log n) - 各ステップで探索範囲を半分に</li>
                <li><strong>挿入/削除（先頭/中間）</strong>: O(n) - シフト操作が必要</li>
                <li><strong>挿入/削除（末尾）</strong>: O(1) - 通常は定数時間（動的配列でのリサイズが必要な場合を除く）</li>
                <li><strong>トラバーサル</strong>: O(n) - すべての要素を1回ずつ処理</li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>静的配列</strong>: O(n) - n個の要素を格納するための固定スペース</li>
                <li><strong>動的配列</strong>: O(n) から O(2n) - 容量拡張のために余分なスペースを確保する場合がある</li>
            </ul>
            
            <p>配列の主な利点は、インデックスによる要素への直接アクセス（O(1)）と連続したメモリ領域による効率的なメモリ使用です。ただし、固定サイズであるため、要素の挿入や削除には要素のシフトが必要で、これらの操作は特に大きな配列では効率が悪くなります。</p>
            
            <p>また、動的配列の場合、容量の拡張時に新しいメモリ領域への全要素のコピーが必要となるため、最悪の場合O(n)の時間がかかります。ただし、アモタイズド（償却）計算量の観点では、動的配列の挿入操作は平均してO(1)の時間計算量となります。</p>
            
            <p>このような特性から、配列は要素へのランダムアクセスが多い場合や、要素の追加/削除が主に末尾で行われる場合に最適なデータ構造となります。一方、頻繁な挿入/削除が必要な場合は、連結リストなど他のデータ構造の方が適している場合があります。</p>
        </div>
    </div>
</body>
</html>