<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ツリー (Tree)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">データ構造の問題</a></li>
        <li>ツリー</li>
    </ul>
    <div class="container">
        <h1>ツリー (Tree)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>木構造（Tree）は階層的なデータを表現するための非線形データ構造で、コンピュータサイエンスの基本的かつ重要な概念です。木構造はノードと呼ばれる要素とそれらを接続するエッジから構成され、循環のないグラフとして定義されます。</p>
            
            <h3>基礎知識</h3>
            <p>木構造は一つの特別なノード（根/ルート）から始まり、そこから複数のノードが枝分かれしていく形をとります。各ノードは0個以上の子ノードを持ち、親子関係によって階層が形成されます。木構造の特徴として、任意の2つのノード間には必ず一意のパスが存在することが挙げられます。</p>
            <p>木構造はファイルシステム、組織図、家系図など、現実世界の多くの階層的概念をモデル化するのに適しています。また、検索、ソート、データ圧縮など様々なアルゴリズムの基盤としても広く利用されています。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ノード（Node）</strong>: 木を構成する基本要素で、データと子ノードへの参照を含む</li>
                <li><strong>エッジ（Edge）</strong>: ノード間の接続を表す線</li>
                <li><strong>ルート（Root）</strong>: 木の最上位に位置する特別なノード</li>
                <li><strong>親ノード（Parent Node）</strong>: 別のノードと直接接続していて、階層が上位にあるノード</li>
                <li><strong>子ノード（Child Node）</strong>: 親ノードに直接接続していて、階層が下位にあるノード</li>
                <li><strong>兄弟ノード（Sibling Nodes）</strong>: 同じ親を持つノード群</li>
                <li><strong>葉ノード（Leaf Node）</strong>: 子を持たないノード（木の末端）</li>
                <li><strong>内部ノード（Internal Node）</strong>: 少なくとも1つの子を持つノード</li>
                <li><strong>深さ（Depth）</strong>: ルートからあるノードまでのエッジの数</li>
                <li><strong>高さ（Height）</strong>: ノードから最も遠い葉までのエッジの数、または木全体の最大深さ</li>
                <li><strong>次数（Degree）</strong>: ノードが持つ子の数</li>
                <li><strong>部分木（Subtree）</strong>: ノードとその全ての子孫からなる木</li>
                <li><strong>バランス木（Balanced Tree）</strong>: 左右の部分木の高さが大きく異ならない木</li>
            </ul>
            
            <h3>特徴</h3>
            <p>木構造の主な特徴は以下の通りです：</p>
            <ul>
                <li>階層的データ表現が可能</li>
                <li>循環パスが存在しない（サイクルがない）</li>
                <li>任意の2つのノード間に一意のパスが存在する</li>
                <li>n個のノードを持つ木はちょうど(n-1)個のエッジを持つ</li>
                <li>効率的な検索、挿入、削除操作が可能（特定の種類の木の場合）</li>
                <li>再帰的な性質を持ち、多くの木操作が再帰的アルゴリズムで実装できる</li>
                <li>様々な特殊形態（二分木、AVL木、赤黒木など）が存在し、異なる用途に最適化されている</li>
                <li>深さ優先探索（DFS）や幅優先探索（BFS）などの探索アルゴリズムが適用可能</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>木構造は以下のような場面で特に有用です：</p>
            <ul>
                <li>階層的データの表現（ファイルシステム、XMLドキュメント、HTML DOM）</li>
                <li>効率的な検索操作（二分探索木、B木、トライ木）</li>
                <li>構文解析と式の評価（構文解析木、式木）</li>
                <li>データ圧縮（ハフマン符号化）</li>
                <li>データベースのインデックス（B木、B+木）</li>
                <li>ネットワークルーティング（最小スパニングツリー）</li>
                <li>機械学習のアルゴリズム（決定木）</li>
                <li>ゲームAI（ミニマックスツリー、モンテカルロ木探索）</li>
                <li>集合の管理（分離集合データ構造/Union-Find）</li>
                <li>3Dグラフィックスのシーングラフと衝突検出（四分木、八分木）</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>木構造に対する基本的な操作手順は以下の通りです：</p>
            
            <h4>木の作成</h4>
            <ol>
                <li>ルートノードを作成する</li>
                <li>必要に応じて子ノードを追加していく</li>
            </ol>
            
            <h4>ノードの挿入</h4>
            <ol>
                <li>新しいノードを作成する</li>
                <li>親となるノードを特定する</li>
                <li>親ノードの子リストに新しいノードを追加する</li>
            </ol>
            
            <h4>ノードの削除</h4>
            <ol>
                <li>削除するノードを特定する</li>
                <li>ノードが葉の場合は単純に削除する</li>
                <li>ノードが内部ノードの場合：
                    <ul>
                        <li>全ての子ノードも削除する（カスケード削除）、または</li>
                        <li>子ノードを親ノードに再接続する、または</li>
                        <li>子ノードを別の適切な場所に移動する（木の種類による）</li>
                    </ul>
                </li>
            </ol>
            
            <h4>木の探索方法</h4>
            <p><strong>深さ優先探索（DFS）</strong>：</p>
            <ol>
                <li>現在のノードを処理する（先行、中間、後続の順序がある）</li>
                <li>各子ノードに対して再帰的に深さ優先探索を適用する</li>
            </ol>
            
            <p><strong>幅優先探索（BFS）</strong>：</p>
            <ol>
                <li>キューを初期化し、ルートノードを追加する</li>
                <li>キューが空になるまで以下を繰り返す：
                    <ul>
                        <li>キューから先頭のノードを取り出し処理する</li>
                        <li>そのノードの全ての子をキューに追加する</li>
                    </ul>
                </li>
            </ol>
            
            <h4>具体例: 二分探索木での検索操作</h4>
            <ol>
                <li>ルートノードから開始する</li>
                <li>現在のノードの値と検索値を比較する</li>
                <li>値が一致した場合、検索成功として終了</li>
                <li>検索値が現在のノード値より小さい場合、左の子ノードに移動して手順2に戻る</li>
                <li>検索値が現在のノード値より大きい場合、右の子ノードに移動して手順2に戻る</li>
                <li>移動先のノードが存在しない場合、検索失敗として終了</li>
            </ol>
            
            <h3>計算量</h3>
            <p>木構造の計算量は木の種類や操作、また木のバランス状態によって大きく異なります：</p>
            
            <h4>一般的な木の計算量</h4>
            <ul>
                <li><strong>探索</strong>: O(n) - 最悪の場合、全てのノードを確認する必要がある</li>
                <li><strong>挿入</strong>: O(1) - 親ノードが既知の場合、ただし親ノードを見つけるのにO(n)かかる可能性がある</li>
                <li><strong>削除</strong>: O(1) - ノードへの参照が既知の場合、ただしノードを見つけるのにO(n)かかる可能性がある</li>
                <li><strong>空間計算量</strong>: O(n) - n個のノードを格納するために必要なスペース</li>
            </ul>
            
            <h4>二分探索木の計算量</h4>
            <ul>
                <li><strong>探索</strong>: 
                    <ul>
                        <li>平均的なケース: O(log n) - バランスが取れている場合</li>
                        <li>最悪のケース: O(n) - 完全に偏った木（リストのような形状）の場合</li>
                    </ul>
                </li>
                <li><strong>挿入</strong>: 
                    <ul>
                        <li>平均的なケース: O(log n)</li>
                        <li>最悪のケース: O(n)</li>
                    </ul>
                </li>
                <li><strong>削除</strong>: 
                    <ul>
                        <li>平均的なケース: O(log n)</li>
                        <li>最悪のケース: O(n)</li>
                    </ul>
                </li>
            </ul>
            
            <h4>バランス木の計算量（AVL木、赤黒木など）</h4>
            <ul>
                <li><strong>探索</strong>: O(log n) - バランスが保証されているため</li>
                <li><strong>挿入</strong>: O(log n) - 挿入後に再バランス操作を含む</li>
                <li><strong>削除</strong>: O(log n) - 削除後に再バランス操作を含む</li>
            </ul>
            
            <p>木構造の効率性は、多くの場合、木がどの程度バランスが取れているか（左右の部分木の高さがどれだけ近いか）に大きく依存します。このため、AVL木や赤黒木などの自己バランス木が開発され、常にO(log n)の操作を保証しています。</p>
            
            <p>また、特定の用途に最適化された特殊な木構造（B木、トライ木など）では、それぞれ異なる計算量の特性を持ちます。選択すべき木構造は、特定のアプリケーションの要件（検索頻度、挿入・削除の頻度、メモリ制約など）によって決まります。</p>
        </div>
    </div>
</body>
</html>