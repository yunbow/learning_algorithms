<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>キュー (Queue)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">データ構造の問題</a></li>
        <li>キュー</li>
    </ul>
    <div class="container">
        <h1>キュー (Queue)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>キュー（Queue）は「先入れ先出し（First-In-First-Out: FIFO）」の原則に基づく基本的なデータ構造です。最も初めに挿入された要素が最初に取り出されるという特性を持ちます。これは日常生活における列（行列）の仕組みと同じであり、最初に並んだ人が最初にサービスを受けられるという考え方に基づいています。</p>
            
            <h3>基礎知識</h3>
            <p>キューは線形データ構造の一種で、データの挿入（エンキュー）と削除（デキュー）の操作が異なる端で行われます。データは一方の端（後方/rear/tail）から挿入され、反対側の端（前方/front/head）から取り出されます。</p>
            <p>キューの基本操作は、新しい要素をキューの末尾に追加する「エンキュー（enqueue）」と、キューの先頭から要素を取り出す「デキュー（dequeue）」です。また、キューの先頭要素を参照するだけの「ピーク（peek）」操作も一般的に提供されます。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>エンキュー（enqueue）</strong>: キューの末尾に新しい要素を追加する操作</li>
                <li><strong>デキュー（dequeue）</strong>: キューの先頭から要素を取り出す操作</li>
                <li><strong>フロント（front）</strong>: キューの先頭位置、要素が取り出される側</li>
                <li><strong>リア（rear）</strong>: キューの末尾位置、要素が追加される側</li>
                <li><strong>FIFO（First-In-First-Out）</strong>: 先入れ先出しの原則</li>
                <li><strong>空キュー（empty queue）</strong>: 要素を持たないキュー</li>
                <li><strong>フル（full queue）</strong>: 固定サイズキューにおいて、これ以上要素を追加できない状態</li>
                <li><strong>循環キュー（circular queue）</strong>: 配列を使った実装で、末尾から先頭へ循環する形で使用するキュー</li>
            </ul>
            
            <h3>特徴</h3>
            <p>キューの主な特徴は以下の通りです：</p>
            <ul>
                <li>先入れ先出し（FIFO）の動作原理</li>
                <li>固定された順序での要素アクセス</li>
                <li>挿入と削除が異なる端で行われる</li>
                <li>中間要素への直接アクセスは一般的に提供されない</li>
                <li>キューの状態は、空（empty）、一部満杯（partially filled）、満杯（full）の3つがある</li>
                <li>配列またはリンクリストを使って実装可能</li>
                <li>基本操作（エンキュー、デキュー）の時間計算量は理想的には O(1)</li>
                <li>様々な変形（優先度キュー、双方向キュー、循環キューなど）が存在する</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>キューは以下のような場面で特に有用です：</p>
            <ul>
                <li>プロセススケジューリング（オペレーティングシステム）</li>
                <li>非同期データ転送（ファイルI/O、パイプ、ソケット）</li>
                <li>リソース共有（プリンタキュー、CPUタスクスケジューリング）</li>
                <li>幅優先探索（BFS）などのグラフアルゴリズム</li>
                <li>キャッシュ実装</li>
                <li>マルチスレッドアプリケーションでのジョブスケジューリング</li>
                <li>メッセージキューイングやバッファリング</li>
                <li>待ち行列管理システム（銀行やカスタマーサービスなど）</li>
                <li>イベント処理システム</li>
                <li>レベル順トラバーサル（木構造）</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>キューの基本操作には以下のようなものがあります：</p>
            
            <h4>キューの初期化</h4>
            <ol>
                <li>空のキューを作成する</li>
                <li>front（先頭）ポインタと rear（末尾）ポインタを適切に初期化する
                    <ul>
                        <li>配列実装の場合: front = rear = -1 または 0（実装による）</li>
                        <li>リンクリスト実装の場合: front = rear = null</li>
                    </ul>
                </li>
            </ol>
            
            <h4>エンキュー操作（要素の追加）</h4>
            <ol>
                <li>キューが満杯かどうかチェックする（固定サイズの場合）</li>
                <li>満杯であればオーバーフローエラーを返す</li>
                <li>そうでなければ：
                    <ul>
                        <li>空キューの場合、front ポインタを 0（または適切な初期値）に設定</li>
                        <li>rear ポインタを増加させる</li>
                        <li>新しい要素を rear の位置に追加する</li>
                    </ul>
                </li>
            </ol>
            
            <h4>デキュー操作（要素の取り出し）</h4>
            <ol>
                <li>キューが空かどうかチェックする</li>
                <li>空であればアンダーフローエラーを返す</li>
                <li>そうでなければ：
                    <ul>
                        <li>front 位置にある要素を取得する</li>
                        <li>front ポインタを増加させる</li>
                        <li>front > rear となった場合、キューを空の状態にリセットする</li>
                    </ul>
                </li>
                <li>取得した要素を返す</li>
            </ol>
            
            <h4>ピーク操作（先頭要素の参照）</h4>
            <ol>
                <li>キューが空かどうかチェックする</li>
                <li>空であればエラーを返す</li>
                <li>そうでなければ、front 位置にある要素を変更せずに返す</li>
            </ol>
            
            <h4>空チェック</h4>
            <ol>
                <li>front が未定義（-1 または null など）またはfront > rear の場合、キューは空</li>
                <li>そうでなければ、キューには少なくとも1つの要素が含まれている</li>
            </ol>
            
            <h4>満杯チェック（固定サイズキューの場合）</h4>
            <ol>
                <li>rear がキューの最大サイズ - 1 に等しいかどうかをチェック</li>
                <li>等しければキューは満杯</li>
            </ol>
            
            <h4>循環キューの場合の特別な考慮</h4>
            <p>循環キューでは、配列の終端に達した後、未使用のスペースを効率的に再利用するために、ポインタが配列の先頭に「循環」します：</p>
            <ol>
                <li>エンキュー操作では rear = (rear + 1) % capacity のように更新</li>
                <li>デキュー操作では front = (front + 1) % capacity のように更新</li>
                <li>満杯チェックは (rear + 1) % capacity == front で行う</li>
            </ol>
            
            <h3>計算量</h3>
            <p>キューの操作に関する計算量は以下の通りです：</p>
            <ul>
                <li><strong>空間計算量</strong>: O(n)、ここで n はキューに格納される要素の最大数</li>
                <li><strong>時間計算量</strong>:
                    <ul>
                        <li><strong>エンキュー操作（Enqueue）</strong>:
                            <ul>
                                <li>配列実装の場合: 通常は O(1)、ただし動的拡張が必要な場合は最悪 O(n)</li>
                                <li>リンクリスト実装の場合: 常に O(1)</li>
                            </ul>
                        </li>
                        <li><strong>デキュー操作（Dequeue）</strong>:
                            <ul>
                                <li>配列実装の場合: 通常は O(1)、ただし要素を前にシフトする実装の場合は O(n)</li>
                                <li>リンクリスト実装の場合: 常に O(1)</li>
                            </ul>
                        </li>
                        <li><strong>ピーク操作（Peek）</strong>: 常に O(1)</li>
                        <li><strong>空チェック</strong>: 常に O(1)</li>
                        <li><strong>満杯チェック</strong>: 常に O(1)</li>
                    </ul>
                </li>
            </ul>
            
            <p>配列を使った基本的なキューの実装では、デキュー操作を繰り返すと配列の先頭に未使用の領域が増えていくという問題があります。これを解決するための方法として、循環キューが用いられます。循環キューでは、すべての基本操作が常に O(1) の時間計算量で実行できます。</p>
            
            <p>一方、リンクリストを使った実装では、メモリ使用量が動的に調整されるため、事前に最大サイズを決める必要がありません。また、すべての基本操作が常に O(1) の時間計算量で実行できるという利点があります。ただし、各要素に対して追加のメモリ（ポインタ）が必要になるというトレードオフがあります。</p>
        </div>
    </div>
</body>
</html>