<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>連結リスト (Linked List)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">データ構造の問題</a></li>
        <li>連結リスト</li>
    </ul>
    <div class="container">
        <h1>連結リスト (Linked List)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>連結リストはコンピュータサイエンスにおいて最も基本的かつ重要なデータ構造の一つで、データ要素を線形的に配置する方法を提供します。配列とは異なり、連結リストの要素（ノード）は物理的なメモリ上で連続して配置されておらず、各ノードが次のノードへの参照（ポインタ）を保持することで接続されています。</p>
            
            <h3>基礎知識</h3>
            <p>連結リストの基本的な構成単位は「ノード」と呼ばれ、各ノードは少なくとも2つの部分から成り立っています：データ部分と、次のノードへの参照（リンク）です。リストの最後のノードは通常、次のノードが存在しないことを示すnull参照を持ちます。</p>
            <p>連結リストには主に以下の種類があります：</p>
            <ul>
                <li><strong>単方向連結リスト</strong>：各ノードが次のノードへの参照のみを持つもの</li>
                <li><strong>双方向連結リスト</strong>：各ノードが前のノードと次のノードへの両方の参照を持つもの</li>
                <li><strong>循環連結リスト</strong>：最後のノードが最初のノードを参照することで円環状になっているもの</li>
            </ul>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>ノード（Node）</strong>：連結リストの基本要素で、データと次のノードへの参照を含む</li>
                <li><strong>ヘッド（Head）</strong>：リストの最初のノードを指すポインタ</li>
                <li><strong>テイル（Tail）</strong>：リストの最後のノードを指すポインタ</li>
                <li><strong>ポインタ/参照（Pointer/Reference）</strong>：他のノードのメモリアドレスを保持する変数</li>
                <li><strong>null/nil</strong>：参照先が存在しないことを示す特殊な値</li>
                <li><strong>前任ノード（Predecessor）</strong>：あるノードの直前に位置するノード</li>
                <li><strong>後続ノード（Successor）</strong>：あるノードの直後に位置するノード</li>
                <li><strong>走査（Traversal）</strong>：リスト内の全ノードを順番に訪れる操作</li>
            </ul>
            
            <h3>特徴</h3>
            <p>連結リストの主な特徴は以下の通りです：</p>
            <ul>
                <li>動的なサイズ調整が可能（メモリを必要に応じて確保・解放できる）</li>
                <li>要素の挿入と削除が効率的（O(1)の時間複雑性）</li>
                <li>ランダムアクセスには不向き（特定の位置のノードにアクセスするにはO(n)の時間が必要）</li>
                <li>各ノードが次のノードへの参照を保持するため、余分なメモリが必要</li>
                <li>キャッシュ効率が配列より劣る（メモリの局所性が低い）</li>
                <li>ポインタ操作のミスによりデータ構造が破損するリスクがある</li>
                <li>実装が配列と比べて複雑</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>連結リストは以下のような場面で特に有用です：</p>
            <ul>
                <li>サイズが事前にわからない、または頻繁に変更されるデータ集合の管理</li>
                <li>スタックやキューなどの抽象データ型の実装</li>
                <li>要素の挿入や削除が頻繁に行われるアプリケーション</li>
                <li>メモリ管理システム（空きメモリブロックの追跡など）</li>
                <li>多項式の表現と操作</li>
                <li>大きな数値の演算（各桁を別々のノードに格納）</li>
                <li>ハッシュテーブルの衝突解決（チェイニング法）</li>
                <li>グラフの表現（隣接リスト）</li>
                <li>オペレーティングシステムのプロセススケジューリング</li>
                <li>Undo機能の実装（操作履歴の管理）</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>連結リストの基本的な操作とその手順は以下の通りです：</p>
            
            <h4>1. 初期化（空の連結リストの作成）</h4>
            <ol>
                <li>ヘッドポインタをnullに設定する</li>
            </ol>
            
            <h4>2. 先頭への挿入</h4>
            <ol>
                <li>新しいノードを作成し、データを格納する</li>
                <li>新しいノードの「次」ポインタに現在のヘッドを設定する</li>
                <li>ヘッドポインタを新しいノードに更新する</li>
            </ol>
            
            <h4>3. 末尾への挿入</h4>
            <ol>
                <li>新しいノードを作成し、データを格納する</li>
                <li>新しいノードの「次」ポインタをnullに設定する</li>
                <li>リストが空の場合、ヘッドに新しいノードを設定して終了</li>
                <li>そうでなければ、現在のノードをヘッドとして設定</li>
                <li>現在のノードの「次」がnullになるまで移動する</li>
                <li>現在のノードの「次」ポインタに新しいノードを設定する</li>
            </ol>
            
            <h4>4. 特定の位置への挿入</h4>
            <ol>
                <li>新しいノードを作成し、データを格納する</li>
                <li>挿入位置が先頭の場合、先頭への挿入手順を実行して終了</li>
                <li>そうでなければ、現在のノードをヘッドとして設定し、位置カウンタを1に初期化</li>
                <li>挿入位置の直前（位置-1）になるまで、現在のノードを次に進め、カウンタをインクリメント</li>
                <li>新しいノードの「次」ポインタに現在のノードの「次」を設定する</li>
                <li>現在のノードの「次」ポインタに新しいノードを設定する</li>
            </ol>
            
            <h4>5. 先頭からの削除</h4>
            <ol>
                <li>リストが空の場合、エラーを返すか何もしない</li>
                <li>一時変数に現在のヘッドを保存する</li>
                <li>ヘッドポインタを現在のヘッドの「次」に更新する</li>
                <li>一時変数に保存したノードのメモリを解放する</li>
            </ol>
            
            <h4>6. 末尾からの削除</h4>
            <ol>
                <li>リストが空の場合、エラーを返すか何もしない</li>
                <li>リストにノードが1つしかない場合、そのノードを削除してヘッドをnullに設定</li>
                <li>そうでなければ、現在のノードをヘッドとして設定</li>
                <li>現在のノードの「次」の「次」がnullになるまで移動する</li>
                <li>現在のノードの「次」のメモリを解放</li>
                <li>現在のノードの「次」ポインタをnullに設定する</li>
            </ol>
            
            <h4>7. 特定の位置からの削除</h4>
            <ol>
                <li>リストが空の場合、エラーを返すか何もしない</li>
                <li>削除位置が1の場合、先頭からの削除手順を実行して終了</li>
                <li>そうでなければ、現在のノードをヘッドとして設定し、位置カウンタを1に初期化</li>
                <li>削除位置の直前（位置-1）になるまで、現在のノードを次に進め、カウンタをインクリメント</li>
                <li>削除するノードを現在のノードの「次」として一時変数に保存</li>
                <li>現在のノードの「次」ポインタを、削除するノードの「次」に設定する</li>
                <li>一時変数に保存したノードのメモリを解放する</li>
            </ol>
            
            <h4>8. 走査（全要素の表示）</h4>
            <ol>
                <li>現在のノードをヘッドとして設定</li>
                <li>現在のノードがnullでない間、以下を繰り返す：
                    <ol>
                        <li>現在のノードのデータを処理（表示など）</li>
                        <li>現在のノードを「次」ノードに更新</li>
                    </ol>
                </li>
            </ol>
            
            <h4>9. 検索</h4>
            <ol>
                <li>現在のノードをヘッドとして設定し、位置カウンタを1に初期化</li>
                <li>現在のノードがnullでない間、以下を繰り返す：
                    <ol>
                        <li>現在のノードのデータが検索対象と一致する場合、位置カウンタを返して終了</li>
                        <li>現在のノードを「次」ノードに更新し、カウンタをインクリメント</li>
                    </ol>
                </li>
                <li>一致するものが見つからなかった場合、検索失敗を示す値を返す</li>
            </ol>
            
            <h3>計算量</h3>
            <p>連結リストの各操作における計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>アクセス（特定の位置の要素を取得）</strong>: O(n)</li>
                <li><strong>検索（値によるノードの検索）</strong>: O(n)</li>
                <li><strong>先頭への挿入</strong>: O(1)</li>
                <li><strong>先頭からの削除</strong>: O(1)</li>
                <li><strong>末尾への挿入</strong>: 
                    <ul>
                        <li>テイルポインタがない場合: O(n)</li>
                        <li>テイルポインタがある場合: O(1)</li>
                    </ul>
                </li>
                <li><strong>末尾からの削除</strong>: 
                    <ul>
                        <li>単方向リスト: O(n)</li>
                        <li>双方向リスト（テイルポインタあり）: O(1)</li>
                    </ul>
                </li>
                <li><strong>任意の位置への挿入/削除</strong>: 
                    <ul>
                        <li>位置が既知の場合: O(1)</li>
                        <li>位置を探す必要がある場合: O(n)</li>
                    </ul>
                </li>
                <li><strong>リストの連結</strong>: 
                    <ul>
                        <li>テイルポインタがある場合: O(1)</li>
                        <li>テイルポインタがない場合: O(n)</li>
                    </ul>
                </li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>基本的な空間要件</strong>: O(n) - n個の要素を格納するのに比例</li>
                <li><strong>オーバーヘッド</strong>: 各ノードはデータに加えて少なくとも1つのポインタ（単方向リスト）を保持するため、配列と比べて余分なメモリが必要</li>
                <li><strong>動的メモリ割り当て</strong>: 各ノードが個別にメモリ確保されるため、メモリフラグメンテーションが発生する可能性がある</li>
            </ul>
            
            <p>連結リストは要素の挿入・削除において効率的ですが、ランダムアクセスを必要とする操作では配列より性能が劣ります。また、ポインタのオーバーヘッドやメモリの局所性の低さにより、実際のパフォーマンスは理論的な計算量よりも複雑な要因に影響されることがあります。アプリケーションの要件に基づいて、連結リストと他のデータ構造（配列、動的配列、ハッシュテーブルなど）の間で適切な選択をすることが重要です。</p>
        </div>
    </div>
</body>
</html>