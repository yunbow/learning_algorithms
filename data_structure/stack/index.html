<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>スタック (Stack)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">データ構造の問題</a></li>
        <li>スタック</li>
    </ul>
    <div class="container">
        <h1>スタック (Stack)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>スタックは、後入れ先出し（Last-In-First-Out: LIFO）の原則に従うデータ構造です。これは本を積み重ねたスタックと同様の動作をします。新しい要素は常にスタックの「トップ」に追加され、要素の取り出しもトップからのみ行われます。この単純な制約によって、多くのアルゴリズムや計算プロセスにおいて重要な役割を果たします。</p>
            
            <h3>基礎知識</h3>
            <p>スタックは抽象データ型（ADT）の一種で、要素のコレクションを特定の順序で管理します。スタックの中心的な概念は、最後に挿入された要素が最初に取り出されるという点です。これはLIFO原則と呼ばれ、スタックの基本的な動作を特徴づけています。</p>
            <p>スタックは主に二つの操作を提供します。「プッシュ（push）」は新しい要素をスタックのトップに追加する操作で、「ポップ（pop）」はスタックのトップから要素を取り除いて返す操作です。これらの操作に加えて、スタックのトップ要素を参照するだけの「ピーク（peek）」や「トップ（top）」と呼ばれる操作も一般的です。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>プッシュ（push）</strong>: スタックに新しい要素を追加する操作</li>
                <li><strong>ポップ（pop）</strong>: スタックから最上位の要素を取り除き、その要素を返す操作</li>
                <li><strong>ピーク/トップ（peek/top）</strong>: スタックから要素を取り除かずに最上位の要素を参照する操作</li>
                <li><strong>空（empty）</strong>: スタックに要素が存在しない状態</li>
                <li><strong>オーバーフロー（overflow）</strong>: スタックが事前に割り当てられたメモリ容量を超えようとする状態（固定サイズの実装の場合）</li>
                <li><strong>アンダーフロー（underflow）</strong>: 空のスタックからポップを試みる状態</li>
                <li><strong>LIFO（Last-In-First-Out）</strong>: 最後に入れたものが最初に出てくる原則</li>
            </ul>
            
            <h3>特徴</h3>
            <p>スタックの主な特徴は以下の通りです：</p>
            <ul>
                <li>単純かつ効率的な実装が可能</li>
                <li>全ての操作（プッシュ、ポップ、ピーク）が定数時間O(1)で実行可能</li>
                <li>要素へのアクセスが制限されている（トップ要素のみアクセス可能）</li>
                <li>再帰的なアルゴリズムの動作を模倣するのに適している</li>
                <li>関数呼び出しのメカニズムの基礎となっている</li>
                <li>実装方法として配列またはリンクリストのどちらも使用可能</li>
                <li>履歴追跡やバックトラッキングが必要なアプリケーションに適している</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>スタックは以下のような場面で特に有用です：</p>
            <ul>
                <li>式の評価と構文解析（例：中置記法から後置記法への変換、括弧のバランスチェック）</li>
                <li>関数呼び出しとプログラム実行の管理（コールスタック）</li>
                <li>ブラウザの履歴機能（戻るボタン）</li>
                <li>テキストエディタの元に戻す（Undo）機能</li>
                <li>深さ優先探索（DFS）アルゴリズムの実装</li>
                <li>バックトラッキングを必要とする問題解決（迷路探索、パズル解決など）</li>
                <li>メモリ割り当てと管理（ヒープとスタックのメモリ領域）</li>
                <li>構文解析と言語処理（コンパイラ、インタプリタの実装）</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>スタックの基本操作は非常にシンプルで、以下の手順で実行されます：</p>
            
            <h4>スタックの基本操作</h4>
            <ol>
                <li><strong>スタックの作成（初期化）</strong>:
                    <ol>
                        <li>空のスタックを作成する</li>
                        <li>トップ要素を指すポインタを初期化する（通常は-1や空の参照）</li>
                    </ol>
                </li>
                <li><strong>プッシュ（Push）操作</strong>:
                    <ol>
                        <li>新しい要素をスタックの最上部に追加する</li>
                        <li>トップポインタを1増加させる（配列実装の場合）</li>
                    </ol>
                </li>
                <li><strong>ポップ（Pop）操作</strong>:
                    <ol>
                        <li>スタックが空でないか確認する（アンダーフロー防止）</li>
                        <li>トップ要素を取得する</li>
                        <li>トップポインタを1減少させる（配列実装の場合）</li>
                        <li>取得した要素を返す</li>
                    </ol>
                </li>
                <li><strong>ピーク/トップ（Peek/Top）操作</strong>:
                    <ol>
                        <li>スタックが空でないか確認する</li>
                        <li>トップ要素を返す（取り除かずに参照のみ）</li>
                    </ol>
                </li>
                <li><strong>空チェック（isEmpty）操作</strong>:
                    <ol>
                        <li>トップポインタが初期値（例えば-1）かどうかを確認する</li>
                        <li>初期値ならtrue（空）、そうでなければfalse（空でない）を返す</li>
                    </ol>
                </li>
            </ol>
            
            <h4>具体例: 数値スタックの操作</h4>
            <p>空のスタックから始めて、一連の操作を行う例を示します：</p>
            <ol>
                <li>初期状態: 空のスタック []、トップ = -1</li>
                <li>push(5): スタック [5]、トップ = 0</li>
                <li>push(8): スタック [5, 8]、トップ = 1</li>
                <li>push(3): スタック [5, 8, 3]、トップ = 2</li>
                <li>pop(): 3を返す、スタック [5, 8]、トップ = 1</li>
                <li>peek(): 8を返す（取り除かない）、スタック [5, 8]、トップ = 1</li>
                <li>pop(): 8を返す、スタック [5]、トップ = 0</li>
                <li>isEmpty(): false（空でない）</li>
                <li>pop(): 5を返す、スタック []、トップ = -1</li>
                <li>isEmpty(): true（空）</li>
            </ol>
            
            <h3>計算量</h3>
            <p>スタックの操作は非常に効率的で、以下の計算量特性を持ちます：</p>
            <ul>
                <li><strong>時間計算量</strong>:
                    <ul>
                        <li>プッシュ（Push）: O(1) - 常に定数時間</li>
                        <li>ポップ（Pop）: O(1) - 常に定数時間</li>
                        <li>ピーク/トップ（Peek/Top）: O(1) - 常に定数時間</li>
                        <li>空チェック（isEmpty）: O(1) - 常に定数時間</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>:
                    <ul>
                        <li>配列実装: O(n) - nは最大要素数</li>
                        <li>リンクリスト実装: O(n) - nは要素数</li>
                    </ul>
                </li>
            </ul>
            
            <p>スタックの全ての基本操作が定数時間で実行できることは、スタックが非常に効率的なデータ構造である主な理由の一つです。特に、大量のデータを処理する必要がある場合や、リアルタイム性能が重要なアプリケーションでは、この特性が重要になります。</p>
            
            <p>ただし、配列ベースの実装では、事前に固定サイズを割り当てる必要があり、要素数が多い場合はメモリの無駄や不足が生じる可能性があります。一方、リンクリストベースの実装では、動的にメモリを割り当てることができますが、ポインタのオーバーヘッドが生じます。アプリケーションの要件に応じて適切な実装を選択することが重要です。</p>
        </div>    
    </div>
</body>
</html>