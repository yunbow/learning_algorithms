<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSA</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">暗号化・複合化の問題</a></li>
        <li>RSA</li>
    </ul>

    <div class="container">
        <h1>RSA</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>RSA暗号は、1977年にRon Rivest、Adi Shamir、Leonard Adlemanによって開発された公開鍵暗号方式です。名前は開発者3人の頭文字に由来しています。RSAは、大きな整数の素因数分解の困難さを安全性の基礎としており、現代のインターネットセキュリティにおいて広く使用されています。</p>
            
            <h3>基礎知識</h3>
            <p>RSAは公開鍵暗号方式の一つで、公開鍵（暗号化に使用）と秘密鍵（復号に使用）のペアを使用します。鍵の生成は素数理論と剰余演算に基づいており、大きな素数の積を素因数分解することが計算的に困難であるという事実を利用しています。この数学的な性質により、公開鍵から秘密鍵を導き出すことが非常に困難になります。</p>
            <p>RSAは暗号化、復号化だけでなく、デジタル署名の生成と検証にも使用されます。デジタル署名では、秘密鍵でメッセージに署名し、公開鍵で署名を検証することで、メッセージの送信者の認証とメッセージの完全性を確保します。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>公開鍵（Public Key）</strong>: 暗号化やデジタル署名の検証に使用される鍵で、誰にでも公開できる</li>
                <li><strong>秘密鍵（Private Key）</strong>: 復号やデジタル署名の生成に使用される鍵で、所有者だけが持つべきもの</li>
                <li><strong>素数（Prime Number）</strong>: 1と自分自身以外に約数を持たない1より大きい整数</li>
                <li><strong>合成数（Composite Number）</strong>: 二つ以上の素数の積</li>
                <li><strong>オイラーのトーティエント関数（Euler's Totient Function）</strong>: φ(n)で表され、nと互いに素な1からnまでの正の整数の個数を表す</li>
                <li><strong>モジュラ演算（Modular Arithmetic）</strong>: 「法（mod）」を用いた剰余系における演算</li>
                <li><strong>素因数分解（Prime Factorization）</strong>: 合成数を素数の積として表すこと</li>
                <li><strong>互いに素（Coprime）</strong>: 二つの整数が1以外の共通の約数を持たないこと</li>
                <li><strong>拡張ユークリッドの互除法（Extended Euclidean Algorithm）</strong>: 二つの整数の最大公約数とベズーの等式を満たす係数を求めるアルゴリズム</li>
                <li><strong>冪剰余演算（Modular Exponentiation）</strong>: 非常に大きな数の累乗をモジュラ演算で効率的に計算する方法</li>
            </ul>
            
            <h3>特徴</h3>
            <p>RSA暗号化アルゴリズムの主な特徴は以下の通りです：</p>
            <ul>
                <li>非対称暗号方式であり、暗号化と復号に異なる鍵を使用する</li>
                <li>大きな整数の素因数分解の困難さに基づいた安全性</li>
                <li>暗号化だけでなく、デジタル署名にも使用可能</li>
                <li>鍵生成、暗号化、復号の計算コストが比較的高い</li>
                <li>大きなサイズの鍵（現在は2048ビット以上が推奨）を必要とする</li>
                <li>小さなメッセージの暗号化に適しているが、大きなデータには効率が悪い</li>
                <li>量子コンピュータによるShorのアルゴリズムに対して脆弱</li>
                <li>実装時には適切なパディング方式が必要</li>
                <li>世界中の多くの暗号標準やプロトコルに採用されている</li>
                <li>SSL/TLSなどのセキュリティプロトコルで広く使用されている</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>RSA暗号化アルゴリズムは以下のような場面で特に有用です：</p>
            <ul>
                <li>セキュアなウェブブラウジング（HTTPS）での鍵交換</li>
                <li>セキュアなメール通信（S/MIME, PGP）</li>
                <li>デジタル署名による文書の認証</li>
                <li>デジタル証明書の署名と検証</li>
                <li>セキュアシェル（SSH）などの安全なリモートアクセスプロトコル</li>
                <li>仮想プライベートネットワーク（VPN）のセキュリティ</li>
                <li>電子署名を用いた電子商取引</li>
                <li>スマートカードなどのセキュリティデバイス</li>
                <li>ブロックチェーン技術とデジタル通貨</li>
                <li>セキュアな鍵配送メカニズム</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>RSA暗号化アルゴリズムは、鍵生成、暗号化、復号化の3つの主要な手順で構成されます：</p>
            
            <h4>1. 鍵生成（Key Generation）</h4>
            <ol>
                <li>二つの大きな素数p, qを選ぶ：
                    <ul>
                        <li>これらは互いに異なり、十分に大きくなければならない</li>
                        <li>現実の実装では、各素数は1024ビット以上が推奨される</li>
                    </ul>
                </li>
                <li>モジュラスnを計算する：
                    <ul>
                        <li>n = p × q</li>
                        <li>nのビット長が実際のRSA鍵のサイズとなる</li>
                    </ul>
                </li>
                <li>オイラーのトーティエント値φ(n)を計算する：
                    <ul>
                        <li>φ(n) = (p - 1) × (q - 1)</li>
                        <li>これは1からnまでの整数のうち、nと互いに素なものの個数</li>
                    </ul>
                </li>
                <li>公開指数e（暗号化指数）を選ぶ：
                    <ul>
                        <li>eはφ(n)より小さく、φ(n)と互いに素である整数</li>
                        <li>一般的には65537（2^16 + 1）などの小さな素数が使われる</li>
                    </ul>
                </li>
                <li>秘密指数d（復号指数）を計算する：
                    <ul>
                        <li>d × e ≡ 1 (mod φ(n))となるようなd</li>
                        <li>拡張ユークリッドの互除法を使用して計算できる</li>
                        <li>すなわち、dはeの乗法的逆元（modulo φ(n)）</li>
                    </ul>
                </li>
                <li>鍵ペアを作成する：
                    <ul>
                        <li>公開鍵：(n, e)</li>
                        <li>秘密鍵：(n, d)</li>
                        <li>素数p, qとφ(n)は安全に廃棄する</li>
                    </ul>
                </li>
            </ol>
            
            <h4>2. 暗号化（Encryption）</h4>
            <ol>
                <li>平文メッセージMを数値に変換する：
                    <ul>
                        <li>Mは0 &lt; M &lt; nを満たす整数である必要がある</li>
                        <li>長いメッセージは適切なサイズのブロックに分割される</li>
                    </ul>
                </li>
                <li>公開鍵(n, e)を使用して暗号文Cを計算する：
                    <ul>
                        <li>C = M<sup>e</sup> mod n</li>
                        <li>この計算には効率的な冪剰余アルゴリズム（繰り返し二乗法）が使用される</li>
                    </ul>
                </li>
                <li>暗号文Cを送信する</li>
            </ol>
            
            <h4>3. 復号化（Decryption）</h4>
            <ol>
                <li>秘密鍵(n, d)を使用して平文Mを復元する：
                    <ul>
                        <li>M = C<sup>d</sup> mod n</li>
                        <li>これも効率的な冪剰余アルゴリズムを使用して計算される</li>
                    </ul>
                </li>
                <li>数値Mを元のメッセージ形式に変換する</li>
            </ol>
            
            <h4>4. デジタル署名（Digital Signature）</h4>
            <ol>
                <li>メッセージのハッシュ値Hを計算する：
                    <ul>
                        <li>信頼できるハッシュ関数（SHA-256など）を使用</li>
                    </ul>
                </li>
                <li>秘密鍵を使って署名Sを生成する：
                    <ul>
                        <li>S = H<sup>d</sup> mod n</li>
                    </ul>
                </li>
                <li>メッセージと署名を送信する</li>
            </ol>
            
            <h4>5. 署名検証（Signature Verification）</h4>
            <ol>
                <li>受信したメッセージからハッシュ値H'を計算する</li>
                <li>公開鍵を使って署名から値Hを復元する：
                    <ul>
                        <li>H = S<sup>e</sup> mod n</li>
                    </ul>
                </li>
                <li>H'とHを比較し、一致すれば署名は有効</li>
            </ol>
            
            <h4>例：小さな数値での簡単な例</h4>
            <ol>
                <li>素数p = 61, q = 53を選ぶ</li>
                <li>モジュラスn = 61 × 53 = 3233を計算</li>
                <li>φ(n) = (61-1) × (53-1) = 60 × 52 = 3120を計算</li>
                <li>e = 17を選択（3120と互いに素）</li>
                <li>d = 2753を計算（17 × 2753 ≡ 1 (mod 3120)）</li>
                <li>公開鍵：(3233, 17)、秘密鍵：(3233, 2753)</li>
                <li>例えば平文M = 123を暗号化すると：
                    <ul>
                        <li>C = 123<sup>17</sup> mod 3233 = 855</li>
                    </ul>
                </li>
                <li>暗号文855を復号すると：
                    <ul>
                        <li>M = 855<sup>2753</sup> mod 3233 = 123</li>
                    </ul>
                </li>
            </ol>
    
            <h3>計算量</h3>
            <p>RSA暗号化アルゴリズムの計算量は以下の通りです：</p>
            
            <h4>時間計算量</h4>
            <ul>
                <li><strong>鍵生成</strong>:
                    <ul>
                        <li>素数生成：確率的に多項式時間（ランダム化アルゴリズムを使用）</li>
                        <li>拡張ユークリッドの互除法：O((log n)²)</li>
                        <li>全体として鍵長kに対してO(k⁴)程度</li>
                    </ul>
                </li>
                <li><strong>暗号化</strong>: O((log n)³)
                    <ul>
                        <li>冪剰余計算（M<sup>e</sup> mod n）：O((log e) × (log n)²)</li>
                        <li>通常eは小さい値（65537など）を使用するため、実質的にはO((log n)²)に近い</li>
                    </ul>
                </li>
                <li><strong>復号化</strong>: O((log n)³)
                    <ul>
                        <li>冪剰余計算（C<sup>d</sup> mod n）：O((log d) × (log n)²)</li>
                        <li>dはnとほぼ同じ大きさなので、計算量はO((log n)³)となる</li>
                        <li>中国剰余定理（CRT）を使用すると計算を高速化できる</li>
                    </ul>
                </li>
            </ul>
            
            <h4>空間計算量</h4>
            <ul>
                <li><strong>鍵サイズ</strong>:
                    <ul>
                        <li>n, e, dはそれぞれO(log n)ビット</li>
                        <li>nは通常2048ビット以上が推奨される</li>
                    </ul>
                </li>
                <li><strong>メッセージサイズ</strong>:
                    <ul>
                        <li>RSAで直接暗号化できるメッセージサイズはnのビット長より小さくなければならない</li>
                        <li>実際には安全性のためパディングを適用するため、さらに小さくなる</li>
                        <li>2048ビット鍵の場合、最大で約245バイト程度</li>
                    </ul>
                </li>
                <li><strong>暗号文サイズ</strong>:
                    <ul>
                        <li>暗号文のサイズは常にモジュラスnのサイズと同じ</li>
                        <li>つまり2048ビット鍵では、暗号文は常に256バイト</li>
                    </ul>
                </li>
            </ul>
            
            <p>RSAの計算量の特性から、一般的には大量のデータを暗号化する場合、RSAだけを使用するのではなく、RSAで対称鍵を安全に交換し、その対称鍵を使ってAESなどの高速な対称暗号でデータを暗号化するハイブリッド方式が採用されています。これにより、RSAの安全性と対称暗号の効率性を組み合わせることができます。</p>
            
            <p>また、RSAの安全性は鍵サイズに大きく依存します。計算機の性能向上や暗号解読技術の進歩に伴い、推奨される鍵サイズも徐々に大きくなっています。2023年時点では、一般的な用途には3072ビット以上、重要なデータには4096ビット以上の鍵サイズが推奨されています。ただし、鍵サイズを大きくすると計算コストも増大するため、使用環境やセキュリティ要件に応じて適切なサイズを選択する必要があります。</p>
            
            <p>量子コンピュータの発展により、Shorのアルゴリズムを使用した効率的な素因数分解が可能になる可能性があるため、RSAの長期的な安全性には懸念があります。そのため、耐量子暗号（Post-Quantum Cryptography）への移行も検討されています。</p>
        </div>
    </div>
</body>
</html>