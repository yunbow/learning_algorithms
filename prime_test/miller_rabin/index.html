<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ミラー-ラビン法 (Miller-Rabin)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">素数判定の問題</a></li>
        <li>ミラー-ラビン法</li>
    </ul>
    <div class="container">
        <h1>ミラー-ラビン法 (Miller-Rabin)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>ミラー-ラビン法は、与えられた数が素数かどうかを確率的に判定するアルゴリズムです。1976年にゲーリー・ミラーによって提案され、1980年にマイケル・O・ラビンによって改良されました。このアルゴリズムは高速かつ効率的で、特に大きな数の素数判定に広く使われています。</p>
            
            <h3>基礎知識</h3>
            <p>素数とは、1と自分自身以外に約数を持たない自然数のことです。例えば、2, 3, 5, 7, 11, 13などが素数です。素数判定は、暗号理論や数論において重要な役割を果たしています。</p>
            <p>ミラー-ラビン法は、フェルマーの小定理と二次剰余の性質を拡張した数学的原理に基づいています。これにより、確率的ではあるものの非常に高い精度で素数判定を行うことができます。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>素数（prime number）</strong>: 1と自分自身以外に約数を持たない自然数</li>
                <li><strong>合成数（composite number）</strong>: 素数でない1より大きい自然数</li>
                <li><strong>フェルマーの小定理（Fermat's Little Theorem）</strong>: 素数pと、pの倍数でない整数aに対して、a^(p-1) ≡ 1 (mod p)が成り立つという定理</li>
                <li><strong>モジュラ演算（modular arithmetic）</strong>: 剰余を使った計算体系</li>
                <li><strong>疑素数（pseudoprime）</strong>: 素数ではないが、ある特定のテストでは素数のように振る舞う数</li>
                <li><strong>確率的アルゴリズム（probabilistic algorithm）</strong>: 結果が確率的に正しいアルゴリズム</li>
                <li><strong>ウィットネス（witness）</strong>: ある数が合成数であることを証明するための数</li>
                <li><strong>強疑素数（strong pseudoprime）</strong>: ミラー-ラビンテストで素数と判定される合成数</li>
            </ul>
            
            <h3>特徴</h3>
            <p>ミラー-ラビン法の主な特徴は以下の通りです：</p>
            <ul>
                <li>確率的なアルゴリズムであり、誤って合成数を素数と判定する可能性が存在する</li>
                <li>ただし、テストの回数を増やすことで誤判定の確率を非常に小さくできる</li>
                <li>k回のテストでは、誤判定の確率は最大で4^(-k)となる</li>
                <li>高速な計算が可能なため、大きな数の素数判定に適している</li>
                <li>実装が比較的容易で、モジュラ累乗演算のみを基本として使用</li>
                <li>決定論的な変種も存在するが、より複雑な実装が必要</li>
                <li>暗号システムにおける鍵生成など、厳密な素数判定が不要なケースに特に有用</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>ミラー-ラビン法は以下のような場面で特に有用です：</p>
            <ul>
                <li>RSA暗号やその他の公開鍵暗号システムにおける大きな素数の生成</li>
                <li>暗号学的に安全な乱数生成</li>
                <li>素数を利用した様々な数論的アルゴリズム</li>
                <li>大きな数の素因数分解の前処理</li>
                <li>計算機科学の研究や教育</li>
                <li>分散システムにおけるハッシュ関数の設計</li>
                <li>高速で正確さが求められる数値計算ライブラリ</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>ミラー-ラビン法の基本的な手順は以下の通りです：</p>
            <ol>
                <li>判定対象の数をnとする（nが2または3の場合は素数として即時判定）</li>
                <li>nが偶数の場合、nが2でなければ合成数として判定して終了</li>
                <li>n-1を次の形に書き換える：n-1 = 2^s × d（dは奇数）</li>
                <li>判定の精度を決めるパラメータkを選択する（テスト回数）</li>
                <li>k回のテストを以下のように実行する：
                    <ol>
                        <li>2からn-2までの範囲からランダムな数aを選ぶ</li>
                        <li>x = a^d mod nを計算する</li>
                        <li>xが1または n-1 なら、このテストではnは「おそらく素数」と判定し、次のテストに進む</li>
                        <li>そうでなければ、以下の手順を最大s-1回繰り返す：
                            <ol>
                                <li>x = x^2 mod nを計算する</li>
                                <li>xが1なら、nは確実に合成数と判定して終了</li>
                                <li>xがn-1なら、このテストではnは「おそらく素数」と判定し、次のテストに進む</li>
                            </ol>
                        </li>
                        <li>上記の繰り返しが終了してもどの条件も満たさなければ、nは確実に合成数と判定して終了</li>
                    </ol>
                </li>
                <li>全てのk回のテストで「おそらく素数」と判定された場合、nは確率的に素数と判定する</li>
            </ol>
            
            <p>この過程をk回繰り返すことで、誤判定の確率を4^(-k)以下に抑えることができます。</p>
            
            <h4>具体例: n = 221を判定する場合</h4>
            <ol>
                <li>n = 221は奇数なので、次のステップに進む</li>
                <li>n-1 = 220を2^s × dの形に書き換える：220 = 2^2 × 55（s=2, d=55）</li>
                <li>a = 174をランダムに選択（例として）</li>
                <li>x = 174^55 mod 221 = 47を計算</li>
                <li>xは1でもn-1（つまり220）でもないので、繰り返し処理に入る</li>
                <li>x = 47^2 mod 221 = 1を計算</li>
                <li>x = 1になったが、直前のxはn-1ではないので、nは合成数と判定される</li>
            </ol>
            
            <p>実際、221 = 13 × 17なので、確かに合成数です。</p>
            
            <h3>計算量</h3>
            <p>ミラー-ラビン法の計算量は以下の特性を持ちます：</p>
            <ul>
                <li><strong>時間計算量</strong>: O(k × log³n)
                    <ul>
                        <li>kはテスト回数</li>
                        <li>主な計算コストはモジュラ累乗の計算（繰り返し二乗法でO(log²n)）</li>
                        <li>s回の反復（各反復でO(log n)の演算）を行う</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(log n)
                    <ul>
                        <li>入力の大きさに対して対数的な作業領域しか必要としない</li>
                        <li>モジュラ累乗計算のための一時変数のみを使用</li>
                    </ul>
                </li>
            </ul>
            
            <p>ミラー-ラビン法の効率性は、高速なモジュラ累乗アルゴリズム（繰り返し二乗法）に大きく依存しています。これにより、数百桁の大きな数でも実用的な時間で素数判定が可能になります。</p>
            
            <p>誤判定の確率を抑えるためには、テスト回数kを増やす必要がありますが、一般的な用途では20〜40回程度のテストで十分な精度が得られます。これは、誤判定の確率が4^(-20)〜4^(-40)と非常に小さくなるためです。</p>
            
            <p>また、特定の小さな数のセット（2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37など）を基底として使用することで、一定の大きさまでの数に対しては決定論的なアルゴリズムとして機能します。</p>
        </div>
    </div>
</body>
</html>