<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>フェルマーテスト (Fermat test)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">素数判定の問題</a></li>
        <li>フェルマーテスト</li>
    </ul>
    <div class="container">
        <h1>フェルマーテスト (Fermat test)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>フェルマーテストは、ある数が素数であるか合成数であるかを確率的に判定するための素数性テストです。この方法は17世紀の数学者ピエール・ド・フェルマーの小定理に基づいており、完全に正確ではないものの、非常に効率的で大きな数の素数判定に広く利用されています。</p>
            
            <h3>基礎知識</h3>
            <p>素数とは、1と自分自身以外に正の約数を持たない1より大きい自然数です。例えば、2, 3, 5, 7, 11などが素数です。</p>
            <p>フェルマーの小定理によれば、pが素数で、aがpの倍数でない任意の整数であれば、「a^(p-1) ≡ 1 (mod p)」が成り立ちます。つまり、a^(p-1)をpで割った余りは1になります。この定理を素数判定に応用したものがフェルマーテストです。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>素数（prime number）</strong>: 1と自分自身のみを約数に持つ1より大きい自然数</li>
                <li><strong>合成数（composite number）</strong>: 素数でない1より大きい自然数</li>
                <li><strong>モジュラ演算（modular arithmetic）</strong>: 整数を法（modulo）とする剰余の演算体系</li>
                <li><strong>フェルマーの小定理（Fermat's Little Theorem）</strong>: 素数pに対して、pと互いに素なaについて、a^(p-1) ≡ 1 (mod p)が成立するという定理</li>
                <li><strong>確率的アルゴリズム（probabilistic algorithm）</strong>: 確率に基づいて結果を出力するアルゴリズム</li>
                <li><strong>擬素数（pseudoprime）</strong>: 素数ではないがフェルマーテストに合格する数</li>
                <li><strong>カーマイケル数（Carmichael number）</strong>: すべてのaに対してフェルマーテストをパスする特殊な合成数</li>
                <li><strong>繰り返し二乗法（repeated squaring/binary exponentiation）</strong>: 効率的にべき乗を計算する方法</li>
            </ul>
            
            <h3>特徴</h3>
            <p>フェルマーテストの主な特徴は以下の通りです：</p>
            <ul>
                <li>確率的な素数判定法である（絶対的に正確ではない）</li>
                <li>複数回のテストを実行することで精度を高めることができる</li>
                <li>大きな数に対して効率的に動作する</li>
                <li>実装が比較的簡単である</li>
                <li>モジュラべき乗の計算に繰り返し二乗法を使用することで効率化できる</li>
                <li>カーマイケル数など、特定の合成数に対して誤った判定をすることがある</li>
                <li>ミラー・ラビンテストなどのより高度な素数性テストの基礎となっている</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>フェルマーテストは以下のような場面で特に有用です：</p>
            <ul>
                <li>暗号理論における大きな素数の生成（RSA暗号など）</li>
                <li>乱数生成アルゴリズムの一部として</li>
                <li>素因数分解アルゴリズムの前処理として</li>
                <li>計算数論の研究と応用</li>
                <li>高速な素数判定が必要な場面（完全な正確さが必須でない場合）</li>
                <li>分散型コンピューティングプロジェクトにおける大きな素数の探索</li>
                <li>数学的問題解決や数学的遊戯のアルゴリズム</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>フェルマーテストの基本的な手順は以下の通りです：</p>
            <ol>
                <li>テスト対象の数nと試行回数kを入力として受け取る</li>
                <li>nが2または3の場合は素数として「素数」を返す</li>
                <li>nが2未満または偶数の場合は「合成数」を返す</li>
                <li>k回の試行を行う：
                    <ol>
                        <li>1からn-1の範囲でランダムな整数aを選ぶ</li>
                        <li>a^(n-1) mod nを計算する（繰り返し二乗法を使用）</li>
                        <li>計算結果が1でなければ、確実に「合成数」を返して終了</li>
                    </ol>
                </li>
                <li>すべての試行がパスした場合は「おそらく素数」を返す</li>
            </ol>
            
            <p>このアルゴリズムは、nが素数でない場合、少なくとも75%の確率で各試行が失敗することを利用しています。そのため、k回の独立した試行をすべてパスする確率は、nが合成数であれば(1/4)^k以下になります。</p>
            
            <h4>具体例: n = 221をテストする場合</h4>
            <ol>
                <li>n = 221（= 13 × 17で合成数）</li>
                <li>試行回数k = 3とする</li>
                <li>n = 221は2より大きく奇数なのでテストを続行</li>
                <li>1回目の試行:
                    <ul>
                        <li>a = 38を選ぶ</li>
                        <li>38^220 mod 221を計算すると1になる（これはフェルマーテストをパスする）</li>
                    </ul>
                </li>
                <li>2回目の試行:
                    <ul>
                        <li>a = 24を選ぶ</li>
                        <li>24^220 mod 221を計算すると81になる（1ではないので合成数と判定）</li>
                    </ul>
                </li>
                <li>1 ≠ 81なので、nは合成数と判定される</li>
            </ol>
            
            <p>この例では、1回目の試行ではフェルマーテストをパスしましたが（これは擬似素数の性質）、2回目の試行で合成数であることが明らかになりました。これはフェルマーテストの確率的な性質を示しています。</p>
            
            <h3>計算量</h3>
            <p>フェルマーテストの計算量は以下の特性を持ちます：</p>
            <ul>
                <li><strong>時間計算量</strong>: 
                    <ul>
                        <li>1回の試行につき: O(log n) - 繰り返し二乗法を使用した場合のモジュラーべき乗の計算量</li>
                        <li>k回の試行: O(k log n)</li>
                    </ul>
                </li>
                <li><strong>空間計算量</strong>: O(log n) - nのビット長に比例</li>
            </ul>
            
            <p>フェルマーテストの主要な計算コストは、モジュラべき乗（a^(n-1) mod n）の計算にあります。繰り返し二乗法を使用することで、この計算を効率的に行うことができ、nのビット長に対して対数時間で計算が可能です。</p>
            
            <p>フェルマーテストの確率的特性により、試行回数kを増やすことで誤判定の確率を指数関数的に減少させることができますが、計算時間も線形に増加します。実際の応用では、精度と効率のバランスを考慮してkの値を選ぶ必要があります。</p>
            
            <p>より高度なミラー・ラビンテストは、フェルマーテストを拡張し、カーマイケル数に対する誤判定を減らす改良が施されています。実用的な素数判定では、フェルマーテストよりもミラー・ラビンテストが広く使用されていますが、フェルマーテストはその理論的基礎として重要な役割を果たしています。</p>
        </div>
    </div>
</body>
</html>