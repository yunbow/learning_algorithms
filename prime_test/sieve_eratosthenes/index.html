<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>エラトステネスのふるい (Sieve of Eratosthenes)</title>
    <link rel="stylesheet" href="./../../styles.css">
</head>
<body>
    <ul class="breadcrumb">
        <li><a href="./../../">アルゴリズムの学習</a></li>
        <li><a href="./../">素数判定の問題</a></li>
        <li>エラトステネスのふるい</li>
    </ul>
    <div class="container">
        <h1>エラトステネスのふるい (Sieve of Eratosthenes)</h1>
        <div class="section">
            <h2>アルゴリズムの概要</h2>
            <p>エラトステネスのふるいは、与えられた上限値までのすべての素数を効率的に見つけるための古典的なアルゴリズムです。紀元前3世紀頃にギリシャの数学者エラトステネスによって考案されました。その単純さと効率の良さから、現代でも広く使用されている素数生成アルゴリズムの一つです。</p>
            
            <h3>基礎知識</h3>
            <p>素数とは、1とその数自身以外に約数を持たない1より大きい自然数のことです。例えば、2, 3, 5, 7, 11, 13などが素数です。一方、4, 6, 8, 9, 10などは合成数（素数でない数）です。</p>
            <p>エラトステネスのふるいの基本原理は、「ある数が素数であれば、その倍数はすべて合成数である」というシンプルな性質を利用しています。この原理に基づいて、順次合成数を「ふるい落とし」ていくことで、残った数が素数となります。</p>
            
            <h3>用語説明</h3>
            <ul>
                <li><strong>素数（prime number）</strong>: 1とその数自身以外に約数を持たない1より大きい自然数</li>
                <li><strong>合成数（composite number）</strong>: 素数でない1より大きい自然数</li>
                <li><strong>ふるい（sieve）</strong>: 不要なものを取り除く道具の比喩として使用されている</li>
                <li><strong>倍数（multiple）</strong>: ある数を整数倍した結果得られる数</li>
                <li><strong>マーキング（marking）</strong>: このアルゴリズムにおいて、合成数を識別するために印をつける操作</li>
                <li><strong>前処理（preprocessing）</strong>: 事前計算により後の処理を効率化する技法</li>
            </ul>
            
            <h3>特徴</h3>
            <p>エラトステネスのふるいの主な特徴は以下の通りです：</p>
            <ul>
                <li>シンプルで理解しやすい素数生成アルゴリズム</li>
                <li>与えられた上限までのすべての素数を一度に求められる</li>
                <li>素数判定の前処理として非常に効率的</li>
                <li>配列やビット配列を使用した実装が可能</li>
                <li>並列処理に適したアルゴリズム構造</li>
                <li>メモリ効率を改善した変種（分割エラトステネスのふるいなど）が存在する</li>
                <li>大きな数の範囲でも比較的効率よく動作する</li>
            </ul>
            
            <h3>適用ケース</h3>
            <p>エラトステネスのふるいは以下のような場面で特に有用です：</p>
            <ul>
                <li>特定の範囲内のすべての素数を列挙する必要がある場合</li>
                <li>素数に関連する数学的研究や問題解決</li>
                <li>暗号理論での素数生成（小〜中規模の素数）</li>
                <li>数論の教育や学習</li>
                <li>競技プログラミングや算法設計の課題</li>
                <li>素数判定を繰り返し行う必要がある場合の前処理</li>
                <li>素数分布の研究や素数定理の実証</li>
            </ul>
        </div>
    
        <div class="section">
            <h2>アルゴリズムの手順</h2>
            <h3>具体的な手順</h3>
            <p>エラトステネスのふるいの基本的な手順は以下の通りです：</p>
            <ol>
                <li>求めたい素数の上限値nを決める</li>
                <li>2からnまでのすべての整数をリストアップする</li>
                <li>まだ処理していない最小の数pを見つける（最初は2）</li>
                <li>pを素数として記録する</li>
                <li>pの倍数（2p, 3p, 4p, ...）をすべて合成数としてマークする</li>
                <li>まだ処理していない数が残っていれば、ステップ3に戻る</li>
                <li>マークされていない数のリストを返す（これらがすべて素数）</li>
            </ol>
            
            <p>このアルゴリズムは終了時に、2からnまでのすべての素数を特定します。</p>
            
            <h4>具体例: n=30までの素数を見つける場合</h4>
            <ol>
                <li>上限値n=30を設定</li>
                <li>数列[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]を用意</li>
                <li>最小の未処理数p=2を素数として記録</li>
                <li>2の倍数[4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]をすべてマーク</li>
                <li>次の未処理数p=3を素数として記録</li>
                <li>3の倍数[6, 9, 12, 15, 18, 21, 24, 27, 30]をすべてマーク</li>
                <li>次の未処理数p=5を素数として記録</li>
                <li>5の倍数[10, 15, 20, 25, 30]をすべてマーク</li>
                <li>次の未処理数p=7を素数として記録</li>
                <li>7の倍数[14, 21, 28]をすべてマーク</li>
                <li>√30 ≈ 5.5より大きいため、これ以上のチェックは不要</li>
                <li>マークされていない数[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]が素数のリスト</li>
            </ol>
            
            <p>したがって、30以下の素数は2, 3, 5, 7, 11, 13, 17, 19, 23, 29です。</p>
            
            <h3>計算量</h3>
            <p>エラトステネスのふるいの計算量は以下の特性を持ちます：</p>
            <ul>
                <li><strong>時間計算量</strong>: O(n log log n)</li>
                <li><strong>空間計算量</strong>: O(n)</li>
            </ul>
            
            <p>時間計算量O(n log log n)は、各素数pについて、nまでのp倍数をマークする操作に由来します。具体的には、n以下の数についてマーキング操作を行うと、n/2 + n/3 + n/5 + n/7 + ... （pは素数）という回数の操作が必要になります。この和は数学的に約n log log nに比例することが知られています。</p>
            
            <p>最適化の一つとして、p^2以上の倍数だけをマークする方法があります。なぜなら、p^2未満のp倍数は、それより小さい素数の倍数としてすでにマークされているからです。この最適化により、特に大きな上限値に対しての効率が向上します。</p>
            
            <p>また、エラトステネスのふるいは平方根最適化を適用できます。つまり、√n以下の素数の倍数だけをマークすれば十分です。これにより、アルゴリズムの実行時間がさらに短縮されます。</p>
            
            <p>メモリ使用量については、基本的な実装では上限値nに比例する配列が必要ですが、ビット配列を使用することで空間効率を8倍程度改善できます。さらに、分割エラトステネスのふるいなどの変種を使用すれば、メモリ使用量をさらに削減できます。</p>
            
            <p>これらの特性により、エラトステネスのふるいは中規模（10^9程度まで）の上限値に対して非常に効率的に動作し、素数生成の標準的なアルゴリズムとして広く使用されています。</p>
        </div>
    </div>
</body>
</html>